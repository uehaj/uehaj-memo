{"componentChunkName":"component---src-templates-blog-post-tsx","path":"/blog/969ef20ccef850d2e9b1/","result":{"data":{"site":{"siteMetadata":{"title":"Gatsby Starter Blog Grommet v2","author":"Ivan Ganev"}},"markdownRemark":{"id":"e2c5f404-095d-57cc-a078-7bd2910d5e90","excerpt":"Material UIでのスタイル指定方法を説明します。Material UIのスタイルシステムの実体はJSSです。themeについては言及しません。もっと基礎的なところだけです。 classNameで即値指定 HTMLで言うclass=の指定。Material UI…","html":"<p>Material UIでのスタイル指定方法を説明します。Material UIのスタイルシステムの実体はJSSです。themeについては言及しません。もっと基礎的なところだけです。</p>\n<h1>classNameで即値指定</h1>\n<p>HTMLで言うclass=の指定。Material UI的には何もしない。BEMやscssでもなんでもいいのですが、外部スタイルシートを定義してあてがっていくパターン。</p>\n<pre><code class=\"language-jsx\">&#x3C;Hoge className=\"hoge fuga\"/>\n</code></pre>\n<h1>styleで指定</h1>\n<p>styleプロパティの指定。Material UI的には何もしない。オブジェクトがdomのstyle属性に変換されて付けられる、Reactの仕組み。</p>\n<pre><code class=\"language-jsx\">&#x3C;Hoge style={{fontSize:1, padding: '1rem'} />\n</code></pre>\n<p>DOM上は、要素に直接紐付いたスタイル指定(devtool上、element.styleで表示される)となる。疑似要素は原理的に指定不可。</p>\n<h1>StyledComponent💅で指定。</h1>\n<p><a href=\"https://material-ui.com/styles/api/#styled-component-styles-options-component\">こちら</a>を参照。本資料では説明を割愛する。</p>\n<h1>JSSのスタイルシートオブジェクトで指定</h1>\n<p>Material UIがかかわるのはここから。JSSは基本的にDOMのインラインスタイル属性ではなく、クラス名による指定の仕組みである。</p>\n<h2>大きな流れ</h2>\n<p>以下のような流れとなる。</p>\n<ol>\n<li>スタイルシートの元になる「元のスタイルシートオブジェクト」をJSで作る<code>const styles = { root: { backgroundColor: 'red', }, };</code></li>\n<li>「元のスタイルシートオブジェクト」を元に、Material UIが準備しているHoCやhooksを使って、以下を生成する。</li>\n<li>「元のスタイルシートオブジェクト」のプロパティ名と、コンポーネントローカルにリネームされた実際に生成される「クラス名の対応表」。こんなやつ:\n<code>{\"tabBar\":\"TabBar-tabBar-284\",\"selectedTab\":\"TabBar-selectedTab-285\"}</code><br/>この値自体をプログラマが意識することは(デバッグ時を除き)基本的にはない。</li>\n<li>この実クラス名でのスタイル定義が、背後で&#x3C;head>に挿入される(プログラマは意識しないでよい)。</li>\n<li>\n<p>「クラス名の対応表」をMaterial UIが提供するReactコンポーネントにおいて以下のいずれかの方法で利用する</p>\n<ul>\n<li>「クラス名の対応表」から実クラス名を取得して「classNames」propsで指定する。</li>\n<li>「クラス名の対応表」から実クラス名を「classes」propsで指定する。</li>\n</ul>\n</li>\n</ol>\n<h2>「元のスタイルシートオブジェクト」の作りかた</h2>\n<h3>単なるJSオブジェクトとして「スタイルシートオブジェクト」を作る</h3>\n<pre><code class=\"language-jsx\">const styles = {\n  root: {\n    backgroundColor: 'red',\n  },\n};\n</code></pre>\n<p>もしくは</p>\n<pre><code class=\"language-jsx\">const styles = createStyles({\n  root: {\n    backgroundColor: 'red',\n  },\n});\n</code></pre>\n<p>両者の意味は同じである。後者ではTypeScriptの型エラーを黙らすことができる。</p>\n<h2>themeを引数とする関数として「スタイルシートオブジェクト」を作る</h2>\n<pre><code class=\"language-jsx\">const styles = (theme: Theme) =>{\n  root: {\n    backgroundColor: theme.color.red,\n  },\n};\n</code></pre>\n<p>もしくは</p>\n<pre><code class=\"language-jsx\">const styles = (theme: Theme) => createStyles({\n  root: {\n    backgroundColor: theme.color.red,\n  },\n});\n</code></pre>\n<p>両者の意味は同じである。後者ではTypeScriptの型エラーを黙らすことができる。</p>\n<p>ここでは、Reactのインラインstyle属性のようにJavaScriptオブジェクトを用いるが、rootの階層が入っていることが異なる。この階層の名前は、(実CSSクラス名を隠蔽した)、ローカルなCSSクラス名と思ってよい。</p>\n<p>CSSクラスなので疑似クラスも指定できる。たとえば、以下のように:hover疑似クラスが指定できる。(JSSの機能)</p>\n<pre><code class=\"language-jsx\">const styles: any = (theme: Theme): StyleRules =>\n  createStyles({\n    button: {\n      margin: '0.3rem',\n      '&#x26;:hover': { transform: 'scale(1.1)' },\n    },\n</code></pre>\n<h2>「元のスタイルシートオブジェクト」から「クラス名の対応表」を入手する</h2>\n<h3>React Hooks系で</h3>\n<p><a href=\"https://material-ui.com/styles/api/#makestyles-styles-options-hook\">こちらから</a>引用だが、以下のように「makeStyles」の引数に「元のスタイルシートオブジェクト」を渡すと、「クラス名の対応表」を取得できるフック関数を入手することができる。そのフック関数の呼び出し結果をclasses変数に取得している。(createStylesは使用していない。)</p>\n<pre><code class=\"language-jsx\">import React from 'react';\nimport { makeStyles } from '@material-ui/core/styles';\n\nconst useStyles = makeStyles({\n  root: {\n    backgroundColor: 'red',\n    color: props => props.color,\n  },\n});\n\nexport default function MyComponent(props) {\n  const classes = useStyles(props);\n  return &#x3C;div className={classes.root} />;\n}\n</code></pre>\n<h3>HoC系で</h3>\n<p>HoCである<a href=\"https://material-ui.com/styles/api/#withstyles-styles-options-higher-order-component\">withStyles</a>を使う。こちらも引用だが以下となる。意味はHooks系と同じだが、「元のスタイルシートオブジェクト」をwithStylesの入力として与え、「クラス名の対応表」がprops.classesに得られるようなコンポーネントを生成している。</p>\n<pre><code class=\"language-jsx\">import React from 'react';\nimport { withStyles } from '@material-ui/core/styles';\n\nconst styles = {\n  root: {\n    backgroundColor: 'red',\n  },\n};\n\nfunction MyComponent(props) {\n  return &#x3C;div className={props.classes.root} />;\n}\n\nexport default withStyles(styles)(MyComponent);\n</code></pre>\n<h2>取得した「クラス名の対応表」の使いかた</h2>\n<p>「クラス名の対応表」は、入手方法としてHooksでもHoCで得ることができるが、同じものである。上記サンプルでは、入手した「クラス名の対応表」はclassesという名前のprops(props.classes)もしくは変数classesに格納している。</p>\n<p>「クラス名の対応表」には2つの使いかたがある。</p>\n<h2>classNameに与える</h2>\n<p>サンプルにもあるが、</p>\n<pre><code class=\"language-jsx\">  return &#x3C;div className={classes.root} />;\n</code></pre>\n<p>のように指定する。複数あれば</p>\n<pre><code class=\"language-jsx\">  return &#x3C;div className={classNames(classes.root,classes.hoge)} />;\n</code></pre>\n<p>のようにNPMモジュールclassnamesを使うのがよいだろう。classnamesはクラス名を結合させているだけである。(<a href=\"https://qiita.com/taqm/items/c38855d8158cdd9d5a3e\">clsx</a>というのもあり効率がよいらしい)。</p>\n<h2>classesで指定</h2>\n<p>最後になったが、これがJSSの本領である。Material UIのコンポーネントにはCSS APIというものが定義されており、それを使ってカスタマイズすることができる。\nたとえば、<a href=\"https://material-ui.com/api/tabs/\">Tabsコンポーネントには以下のようにかかれている</a>。</p>\n<p><strong><em>CSS</em></strong></p>\n<ul>\n<li>Style sheet name: MuiTab.</li>\n<li>Style sheet details:</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Rule name</th>\n<th align=\"left\">Global class</th>\n<th align=\"left\">Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"left\">root</td>\n<td align=\"left\">.MuiTab-root</td>\n<td align=\"left\">Styles applied to the root element.</td>\n</tr>\n<tr>\n<td align=\"left\">labelIcon</td>\n<td align=\"left\">.MuiTab-labelIcon</td>\n<td align=\"left\">Styles applied to the root element if both icon and label are provided.</td>\n</tr>\n<tr>\n<td align=\"left\">textColorInherit</td>\n<td align=\"left\">.MuiTab-textColorInherit</td>\n<td align=\"left\">Styles applied to the root element if the parent Tabs has textColor=“inherit”.</td>\n</tr>\n<tr>\n<td align=\"left\">textColorPrimary</td>\n<td align=\"left\">.MuiTab-textColorPrimary</td>\n<td align=\"left\">Styles applied to the root element if the parent Tabs has textColor=“primary”.</td>\n</tr>\n<tr>\n<td align=\"left\">textColorSecondary</td>\n<td align=\"left\">.MuiTab-textColorSecondary</td>\n<td align=\"left\">Styles applied to the root element if the parent Tabs has textColor=“secondary”.</td>\n</tr>\n<tr>\n<td align=\"left\"><font color=\"red\">selected</font></td>\n<td align=\"left\">.Mui-selected</td>\n<td align=\"left\">Pseudo-class applied to the root element if selected={true} (controlled by the Tabs component).</td>\n</tr>\n</tbody>\n</table>\n<p>これらを必要に応じてオーバーライド定義することができる。赤字”selected”は後述の説明で例として使用するCSS APIのキー名である。このスタイルをオーバーライドする方法は3つある。</p>\n<ul>\n<li>With a rule name of the classes object prop.(classes propsのルール名)</li>\n<li>With a global class name. (グローバルクラス名)</li>\n<li>With a theme and an overrides property..(テーマと上書きプロパティ)</li>\n</ul>\n<p>以降では最初の「 rule name of the classes object prop.」について説明する。\nやるべきことは、classes属性に、指定したCSS API名をキー(ここではslected)とし「クラス名の対応表」の実クラス名を指定するのである。</p>\n<pre><code class=\"language-jsx\">const styles = (theme: any) =>\n  createStyles({\n    selectedTab: {\n      backgroundColor: '#eeeeff',\n      fontWeight: 'bold',\n    },\n  });\n:\n          &#x3C;Tabs>\n            &#x3C;Tab\n              classes={{ selected: classes.selectedTab }} />\n               :\n          &#x3C;/Tabs>\n</code></pre>\n<p>するともともとMUIで定義されていたCSSに上書きされる形でCSSスタイルが定義される。</p>","frontmatter":{"title":"Material UIのスタイル指定(JSS)","date":"February 20, 2020","cover":null}}},"pageContext":{"slug":"/blog/969ef20ccef850d2e9b1/","previous":{"fields":{"slug":"/blog/99f7cd014e2c0fa1fc4e/"},"frontmatter":{"title":"React HooksのuseCallbackを正しく理解する"}},"next":{"fields":{"slug":"/blog/944cd9903c3827f1d1bc/"},"frontmatter":{"title":"第13回オフラインリアルタイムどう書くの参考問題をFregeで解く"}}}}}