{"componentChunkName":"component---src-templates-blog-post-tsx","path":"/blog/5d9fec1ba6cc4c76e378/","result":{"data":{"site":{"siteMetadata":{"title":"Gatsby Starter Blog Grommet v2","author":"Ivan Ganev"}},"markdownRemark":{"id":"199b1e1e-1b6f-5fb8-af22-c56a811f4567","excerpt":"Node.jsでC言語のgetchar()マクロ(getc()関数)に相当するような、標準入力から1文字文字を読みとる処理を書くやりかた。NPMを使わずに手軽に直接できる方法を見つけられなかったため作成。仕様は以下のとおり。 Promise…","html":"<p>Node.jsでC言語のgetchar()マクロ(getc()関数)に相当するような、標準入力から1文字文字を読みとる処理を書くやりかた。NPMを使わずに手軽に直接できる方法を見つけられなかったため作成。仕様は以下のとおり。</p>\n<ul>\n<li>Promiseベース。以下で「〜を返す」は、「〜をPromiseのresolve値とするPromiseを返す」と読みかえてほしい。</li>\n<li>呼ぶごとに標準入力から1文字ずつ取得したUnicodeのコードポイント値を返す。readlineから得たstringからcharCodeAtしているのでサロゲートペアは別に対処が必要。</li>\n<li>バッファにデータがなければブロッキングして入力を待つ(stdinがTTYの場合)。</li>\n<li>行単位のバッファリングは行う。改行キーを押さない限りブロックは解除されない。</li>\n<li>バッファにデータが存在する限り、バッファから1文字を取り出し文字コードを返す。</li>\n<li>EOFでnullを返す。</li>\n</ul>\n<pre><code class=\"language-js\">const readline = require('readline');\nconst rl  = readline.createInterface(process.stdin);\nlet buf = \"\";\n\nfunction getchar() {\n  if (buf.length == 0) {\n    if (process.stdin.AtEndOfStream) {\n      return Promise.resolve(null); // EOF\n    }\n    return new Promise((resolve, reject) => {\n      rl.once('line', (line) => {\n        buf = buf + line + \"\\n\";\n        resolve(getchar());\n      });\n    });\n  } else {\n    const result = buf.charCodeAt(0);\n    buf = buf.substring(1);\n    return Promise.resolve(result);\n  }\n}\n\nasync function test() {\n  let ch\n  while ((ch = await getchar()) !== null) {\n    console.log(ch);\n  }\n}\n\ntest();\n</code></pre>","frontmatter":{"title":"Node.jsでgetchar","date":"February 20, 2020","cover":null}}},"pageContext":{"slug":"/blog/5d9fec1ba6cc4c76e378/","previous":{"fields":{"slug":"/blog/5cd1e9a1ea3d451e784e/"},"frontmatter":{"title":"Grails3で、Grails2と同様に設定ファイルを外部化する"}},"next":{"fields":{"slug":"/blog/53460a9772f2bfbaa3c1/"},"frontmatter":{"title":"第19回 オフラインリアルタイムどう書くの問題「不良セクタの隣」を、Haskellで解く"}}}}}