{"componentChunkName":"component---src-templates-blog-post-tsx","path":"/blog/5f46b012f13e1d3cee55/","result":{"data":{"site":{"siteMetadata":{"title":"Gatsby Starter Blog Grommet v2","author":"Ivan Ganev"}},"markdownRemark":{"id":"e6c4c531-ba13-5981-b28e-c5eee2cd57ff","excerpt":"第12回 オフラインリアルタイムどう書くの問題「サイコロを転がす」を、Haskellで解きました。\nStateモナド厨。","html":"<p><a href=\"http://qiita.com/Nabetani/items/f3cca410428f90333e28\">第12回 オフラインリアルタイムどう書く</a>の問題「<a href=\"http://nabetani.sakura.ne.jp/hena/ord12rotdice/\">サイコロを転がす</a>」を、Haskellで解きました。\nStateモナド厨。</p>\n<pre><code class=\"language-diceState.hs\">-- http://nabetani.sakura.ne.jp/hena/ord12rotdice/\nimport Data.List\nimport Control.Monad.State\n\n-- 1と2の向きで表わしたサイコロの方向の状態。NEは「1の目が北(N)、2の目が東(E)」を表わす。Uは上、Dは下を表わす。\ndata DiceState = NE|ES|SW|WN|EN|SE|WS|NW|UN|ND|DS|SU|NU|DN|SD|US|UE|ED|DW|WU|EU|DE|WD|UW deriving (Show, Eq)\n\n-- それぞれのサイコロの状態で上面の数字(目)を表わす連想リスト。\ndeuce :: [(DiceState, Char)]\ndeuce = [(NE,'4'),(ES,'4'),(SW,'4'),(WN,'4'),(EN,'3'),(SE,'3'),\n         (WS,'3'),(NW,'3'),(UN,'1'),(ND,'5'),(DS,'6'),(SU,'2'),\n         (NU,'2'),(DN,'6'),(SD,'5'),(US,'1'),(UE,'1'),(ED,'5'),\n         (DW,'6'),(WU,'2'),(EU,'2'),(DE,'6'),(WD,'5'),(UW,'1')]\n\n-- ころがし操作。'N':北へころがす, 'W':西へころがす, 'S':南へころがす, 'E':東へころがす\ntype Roll = Char\n\n-- サイコロの状態における目(上を向いている面の数値)を返す\ngetDeuce :: DiceState -> Char\ngetDeuce state = let (Just n) = lookup state deuce in n\n\nmkpair :: (t, t, t, t) -> [(t, t)]\nmkpair (a,b,c,d) = [(a,b),(b,c),(c,d),(d,a)]\n\n-- 東にころがす回転('E')におけるサイコロ状態の変化\n-- [(回転前の状態,回転後の状態), ...]の連想リスト\nmoveDataToEast :: [(DiceState, DiceState)]\nmoveDataToEast = concat [mkpair (UN,EN,DN,WN),\n                         mkpair (ND,NW,NU,NE),\n                         mkpair (DS,WS,US,ES),\n                         mkpair (SU,SE,SD,SW),\n                         mkpair (ED,DW,WU,UE),\n                         mkpair (EU,DE,WD,UW)]\n-- 北にころがす回転('N')におけるサイコロ状態の変化\n-- [(回転前の状態,回転後の状態), ...]の連想リスト\nmoveDataToNorth :: [(DiceState, DiceState)]\nmoveDataToNorth = concat [mkpair (UN,ND,DS,SU),\n                          mkpair (EN,ED,ES,EU),\n                          mkpair (DN,SD,US,NU),\n                          mkpair (WN,WD,WS,WU),\n                          mkpair (NW,DW,SW,UW),\n                          mkpair (SE,UE,NE,DE)]\n\n-- 指定した状態に対して、ころがし操作を与えたとき、次状態を得る\nstep :: Roll -> DiceState -> DiceState\nstep r direc = case r of\n                 'N' -> moveN direc\n                 'W' -> moveW direc\n                 'S' -> moveS direc\n                 'E' -> moveE direc\n               where\n                 -- 北にころがしたときの次状態を返す\n                 moveN :: DiceState -> DiceState\n                 moveN s = let (Just d) = lookup s moveDataToNorth in d\n                 -- 西にころがしたときの次状態を返す\n                 moveW :: DiceState -> DiceState\n                 moveW s = moveE $ moveE $ moveE s\n                 -- 南にころがしたときの次状態を返す\n                 moveS :: DiceState -> DiceState\n                 moveS s = moveN $ moveN $ moveN s\n                 -- 東にころがしたときの次状態を返す\n                 moveE :: DiceState -> DiceState\n                 moveE s = let (Just d) = lookup s moveDataToEast in d\n\n-- ころがし操作を与えると次の状態モナドを返すモナディック関数\n-- 状態は、(サイコロ上面の数値(目)の履歴, サイコロの状態)というタプルで表現。\nstepSt :: Roll -> State (String, DiceState) ()\nstepSt ch = do\n  (xs, direc) &#x3C;- get\n  let nextDirec = step ch direc\n  state $ const ((), (getDeuce nextDirec:xs, nextDirec))\n\n-- ころがし操作の列と、結果(目の履歴)の期待値を与え、一致しているかどうかを返す\ntest :: String -> String -> Bool\ntest opr expected = let (xs, _) = execState (mapM stepSt opr) (['1'], UN)\n                    in (reverse xs == expected)\n\nmain :: IO ()\nmain = do\n    print $ test \"NNESWWS\" \"15635624\"  {-- 0 --}\n    print $ test \"EEEE\" \"13641\"  {-- 1 --}\n    print $ test \"WWWW\" \"14631\"  {-- 2 --}\n    print $ test \"SSSS\" \"12651\"  {-- 3 --}\n    print $ test \"NNNN\" \"15621\"  {-- 4 --}\n    print $ test \"EENN\" \"13651\"  {-- 5 --}\n    print $ test \"WWNN\" \"14651\"  {-- 6 --}\n    print $ test \"SSNN\" \"12621\"  {-- 7 --}\n    print $ test \"NENNN\" \"153641\"  {-- 8 --}\n    print $ test \"NWNNN\" \"154631\"  {-- 9 --}\n    print $ test \"SWWWSNEEEN\" \"12453635421\"  {-- 10 --}\n    print $ test \"SENWSWSNSWE\" \"123123656545\"  {-- 11 --}\n    print $ test \"SSSWNNNE\" \"126546315\"  {-- 12 --}\n    print $ test \"SWNWSSSWWE\" \"12415423646\"  {-- 13 --}\n    print $ test \"ENNWWS\" \"1354135\"  {-- 14 --}\n    print $ test \"ESWNNW\" \"1321365\"  {-- 15 --}\n    print $ test \"NWSSE\" \"154135\"  {-- 16 --}\n    print $ test \"SWNWEWSEEN\" \"12415154135\"  {-- 17 --}\n    print $ test \"EWNWEEEEWN\" \"13154532426\"  {-- 18 --}\n    print $ test \"WNEWEWWWSNW\" \"145151562421\"  {-- 19 --}\n    print $ test \"NNEE\" \"15631\"  {-- 20 --}\n    print $ test \"EEEEWNWSW\" \"1364145642\"  {-- 21 --}\n    print $ test \"SENNWWES\" \"123142321\"  {-- 22 --}\n    print $ test \"SWWWSNSNESWW\" \"1245363635631\"  {-- 23 --}\n    print $ test \"WESSENSE\" \"141263231\"  {-- 24 --}\n    print $ test \"SWNSSESESSS\" \"124146231562\"  {-- 25 --}\n    print $ test \"ENS\" \"1353\"  {-- 26 --}\n    print $ test \"WNN\" \"1453\"  {-- 27 --}\n    print $ test \"SSEENEEEN\" \"1263124536\"  {-- 28 --}\n    print $ test \"NWSNNNW\" \"15414632\"  {-- 29 --}\n    print $ test \"ESSSSSWW\" \"132453215\"  {-- 30 --}\n    print $ test \"ESE\" \"1326\"  {-- 31 --}\n    print $ test \"SNWNWWNSSSS\" \"121456232453\"  {-- 32 --}\n    print $ test \"SWEESEN\" \"12423653\"  {-- 33 --}\n    print $ test \"NEEWNSSWWW\" \"15323631562\"  {-- 34 --}\n    print $ test \"WSEW\" \"14212\"  {-- 35 --}\n    print $ test \"SWSNNNSNWE\" \"12464131353\"  {-- 36 --}\n    print $ test \"ENWEWSEEW\" \"1351513545\"  {-- 37 --}\n    print $ test \"WSEWN\" \"142124\"  {-- 38 --}\n    print $ test \"EWNEESEWE\" \"1315321414\"  {-- 39 --}\n    print $ test \"NESEEN\" \"1531263\"  {-- 40 --}\n    print $ test \"WSW\" \"1426\"  {-- 41 --}\n    print $ test \"ENEWE\" \"135656\"  {-- 42 --}\n</code></pre>","frontmatter":{"title":"第12回オフラインリアルタイムどう書くの問題「サイコロを転がす」をHaskellで解く","date":"February 20, 2020","cover":null}}},"pageContext":{"slug":"/blog/5f46b012f13e1d3cee55/","previous":{"fields":{"slug":"/blog/68fa097e03d0572aefe4/"},"frontmatter":{"title":"Node.jsでPEG.jsでBrainf*ck"}},"next":{"fields":{"slug":"/blog/5d9fec1ba6cc4c76e378/"},"frontmatter":{"title":"Node.jsでgetchar"}}}}}