{"componentChunkName":"component---src-templates-blog-post-tsx","path":"/blog/80056c1ff10c63dc7810/","result":{"data":{"site":{"siteMetadata":{"title":"Gatsby Starter Blog Grommet v2","author":"Ivan Ganev"}},"markdownRemark":{"id":"74859ef6-663a-5d35-b552-cffa92a877b1","excerpt":"追記(2017/05/2) redux-sagaでの非同期バージョンの紹介とリンクを追記。 追記(2017/2/23修正) 元記事の追記…","html":"<h1>追記(2017/05/2)</h1>\n<p>redux-sagaでの非同期バージョンの紹介とリンクを追記。</p>\n<h1>追記(2017/2/23修正)</h1>\n<p><font color=\"red\"><a href=\"http://qiita.com/hiruberuto/items/39e4126f470d8b84b291#%E8%BF%BD%E8%A8%98%EF%BC%93%E3%82%AB%E3%82%A6%E3%83%B3%E3%82%BF%E3%83%BC%E3%82%A8%E3%83%B3%E3%83%88%E3%83%AA%E3%82%92%E9%A0%82%E3%81%84%E3%81%9F%E3%81%AE%E3%81%A7%E3%81%99%E3%81%8C%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%A0%E3%81%AB%E8%AA%A4%E3%82%8A%E3%81%8C%E3%81%82%E3%82%8A%E3%81%BE%E3%81%99\">元記事の追記3</a>にて言及を頂いたように、</font>以下の「見易い版」コードは元コードが実現していた機能が抜けおちているという誤りがあります。遅くなりましたが、お詫びの上修正させていただきます。\n修正内容は以下の「<a href=\"http://qiita.com/uehaj/items/80056c1ff10c63dc7810#refresh%E3%83%9C%E3%82%BF%E3%83%B3%E6%8A%BC%E4%B8%8B%E3%81%A7%E3%81%99%E3%81%B9%E3%81%A6%E3%81%AE%E5%80%99%E8%A3%9C%E3%82%92%E6%B6%88%E5%8E%BB2017223%E8%BF%BD%E8%A8%98\">refreshボタン押下ですべての候補を消去</a>」の項目に追記しました。</p>\n<p>上記追記の趣旨として、リアクティブプログラミングはそれほど判り難いのだ、というご指摘になっていますが、返す言葉もございません。</p>\n<h1>はじめに</h1>\n<p>先日「<a href=\"http://qiita.com/hiruberuto/items/39e4126f470d8b84b291\">リアクティブプログラミングとは何だったか</a>」という記事を目にしまして、内容はたいへん興味深かったのですが、以下の記述がありました。</p>\n<blockquote>\n<p>『宣言的』といえそうなのはわかりますし、パラダイムとして従来のコードとは一線を画すものであることは確かですが、どう贔屓目にみてもひたすら読みづらいとしか感じられません。ここでもう一度、先に示したモナド版のほうを見て比較してみます。</p>\n</blockquote>\n<p>比較しているのは、<a href=\"http://jsfiddle.net/staltz/8jFJH/48/\">RxJS版</a>と、<a href=\"https://gist.github.com/aratama/fa9fd5eca5573fc2e6dd\">PurescriptのAffモナド版</a>なのですが、わたしはいずれについても詳しい知識はありませんが、ReactiveXのObservableは、私の理解では<strong>「ストリームモナド」</strong>であり、Affモナドも(名前から判断する限り)どっちもモナドなわけで、基本的な記述でなぜそのような差が出るのかが良くわかりませんでした。 </p>\n<p>ということで、調べてみました。</p>\n<h1>TL;DR</h1>\n<p>リアクティブプログラミングが読み難いかどうかは、書き方によるが、簡単なケースでは言うほど読みにくい、というわけでもない(個人の感想です)。また読者の背景知識にもよる。</p>\n<h1>「ひたすら読み難い」と言われているコード</h1>\n<p>先の記事中で比較対象は<a href=\"http://ninjinkun.hatenablog.com/entry/introrxja\">「あなたが求めていたリアクティブプログラミング入門」</a><a href=\"https://gist.github.com/staltz/868e7e9bc2a7b8c1f754\">(original)</a>に示されていた<a href=\"https://github.com/Reactive-Extensions/RxJS\">RxJS</a>のコード(<a href=\"http://jsfiddle.net/staltz/8jFJH/48/\">全体はこちら</a>)です。</p>\n<p>一部引用するとこんな感じ。</p>\n<pre><code class=\"language-JavaScript\">var refreshClickStream = Rx.Observable.fromEvent(refreshButton, 'click');\nvar close1ClickStream = Rx.Observable.fromEvent(closeButton1, 'click');\nvar close2ClickStream = Rx.Observable.fromEvent(closeButton2, 'click');\nvar close3ClickStream = Rx.Observable.fromEvent(closeButton3, 'click');\n\nvar requestStream = refreshClickStream.startWith('startup click')\n    .map(function() {\n        var randomOffset = Math.floor(Math.random()*500);\n        return 'https://api.github.com/users?since=' + randomOffset;\n    });\n\nvar responseStream = requestStream\n    .flatMap(function (requestUrl) {\n        return Rx.Observable.fromPromise($.getJSON(requestUrl));\n    });\n\nfunction createSuggestionStream(closeClickStream) {\n    return closeClickStream.startWith('startup click')\n        .combineLatest(responseStream,             \n            function(click, listUsers) {\n                return listUsers[Math.floor(Math.random()*listUsers.length)];\n            }\n        )\n        .merge(\n            refreshClickStream.map(function(){ \n                return null;\n            })\n        )\n        .startWith(null);\n}\nvar suggestion1Stream = createSuggestionStream(close1ClickStream);\nvar suggestion2Stream = createSuggestionStream(close2ClickStream);\nvar suggestion3Stream = createSuggestionStream(close3ClickStream);\n ：\nsuggestion1Stream.subscribe(function (suggestedUser) {\n    renderSuggestion(suggestedUser, '.suggestion1');\n});\n\nsuggestion2Stream.subscribe(function (suggestedUser) {\n    renderSuggestion(suggestedUser, '.suggestion2');\n});\n\nsuggestion3Stream.subscribe(function (suggestedUser) {\n    renderSuggestion(suggestedUser, '.suggestion3');\n});\n</code></pre>\n<p>なるほどなるほど。確かに確かに。</p>\n<h1>なぜ読み難いのか</h1>\n<h2>変数の多用</h2>\n<p>一見してわかるのは、ストリーム(=Observable)を保持するための変数を多用しているということです。この理由はおそらく、本文中での説明時の参照のしやすさ、特に図表で説明するためではないかと思いました。たとえば、</p>\n<pre><code>    requestStream: --r--------------->\n   responseStream: ------R----------->\nclose1ClickStream: ------------c----->\nsuggestion1Stream: ------s-----s----->\n</code></pre>\n<p>上記の左の桁にストリームを特定するための変数名を書きたかった、ということです。</p>\n<p>結果として読む流れが上に行ったり下に行ったりしてしまいます。ただこれは使用箇所で値を展開するようにすれば改善されるでしょう。</p>\n<h2>不要な処理(2017/2/23訂正)</h2>\n<p><del>いくつか不要な処理が混入していることに気付きました。具体的にはmergeの呼び出しや、startwithを2回呼び出していることなどです。ステップバイステップで改良しつつ説明していくときに、古いステップで必要だったが、処理を追加することで不要になったものを削除しわすれてる、って気がします。</del></p>\n<p><del>この結果、 refreshClickStreamが2箇所で使用され、最後に合流していくように見え、なんだこりゃ、と思えるようになっていました。でもそれで動くっていうのもある意味すごい。</del></p>\n<p>当初、refreshStreamのmergeによる合流は不要な処理と思いましたが、後述のように重要な仕様を実現するためのもので不要ではありませんでした。startwithの2回の呼び出しのうち1回は不要な処理だと思っています。</p>\n<h2>ES2015の不使用</h2>\n<p>アロー関数をつかってないので煩雑に見えます。枝葉ですけどね。</p>\n<h1>書き直してみた</h1>\n<p>上記を中心に修正してみると、先ほど引用した部分に対応する部分は以下のようになりました。(全体および詳しい説明は<a href=\"http://jsdo.it/uehaj/rxjs1\">こちら</a>。)</p>\n<pre><code class=\"language-JavaScript\">// お奨めユーザ一覧を取得する非同期通信の発行結果のプロミスをストリームで包んで返す。\nfunction getNewUsers() {\n    const randomOffset = Math.floor(Math.random()*500);\n    const requestUrl = 'https://api.github.com/users?since=' + randomOffset\n    return Rx.Observable.fromPromise($.getJSON(requestUrl))\n}\n\n// closeボタンにイベントストリームを設定するぜ!\n[[closeButton1, \".suggestion1\"],\n [closeButton2, \".suggestion2\"],\n [closeButton3, \".suggestion3\"]]\n    .forEach(([closeButton, selector]) =>\n             Rx.Observable.fromEvent(closeButton, 'click')\n             .startWith('startup click')\n             .combineLatest(\n                 Rx.Observable.fromEvent(refreshButton, 'click')\n                     .startWith('startup click')\n                     .flatMap(() => getNewUsers()),\n                 (_, listUsers) => listUsers[Math.floor(Math.random()*listUsers.length)])\n             .subscribe((suggestedUser) => renderSuggestion(suggestedUser, selector)))\n</code></pre>\n<h2>refreshボタン押下ですべての候補を消去(2017/2/23追記)</h2>\n<p>当初、本記事は、上記まででしたが、重要な仕様である「refreshボタン押下の瞬間に一旦すべての候補が消去される」が実装されていませんでした。私の理解不足によるもので申し訳なく思います。該当機能を実装した版を以下にしめします。</p>\n<pre><code class=\"language-JavaScript\">// お奨めユーザ一覧を取得する非同期通信の発行結果のプロミスをストリームで包んで返す。\nfunction getNewUsers() {\n    const randomOffset = Math.floor(Math.random()*500);\n    const requestUrl = 'https://api.github.com/users?since=' + randomOffset\n    return Rx.Observable.fromPromise($.getJSON(requestUrl))\n}\n\nconst refreshClickStream = Rx.Observable.fromEvent(refreshButton, 'click'); //追加\n\n// closeボタンにイベントストリームを設定するぜ!\n[[closeButton1, \".suggestion1\"],\n [closeButton2, \".suggestion2\"],\n [closeButton3, \".suggestion3\"]]\n    .forEach(([closeButton, selector]) =>\n             Rx.Observable.fromEvent(closeButton, 'click')\n             .startWith('startup click')\n             .combineLatest(\n                 refreshClickStream // 変更\n                     .startWith('startup click')\n                     .flatMap(() => getNewUsers()),\n                 (_, listUsers) => listUsers[Math.floor(Math.random()*listUsers.length)])\n             .merge(refreshClickStream.map(()=>null))// 追加。refreshボタンが押されたらsuggestedUser==nullという出力を折り込む\n             .subscribe((suggestedUser) => renderSuggestion(suggestedUser, selector)))\n</code></pre>\n<p>修正版の全体は<a href=\"http://jsdo.it/uehaj/45A9\">こちら</a>。</p>\n<h2>combineLatestの使用</h2>\n<p>上記では特に<a href=\"http://reactivex.io/documentation/operators/combinelatest.html\">combineLatest</a>のところが難解に感じられるかもしれませんので説明します。このサンプルコードでは、個々の推奨ユーザに付随するcloseボタンの押下ではAJAXのXHRリクエストが発行されずに、最後に実行したrefreshで取得した推奨ユーザリストの値を再利用するようにしています。</p>\n<p>combineLatestは2つのストリームに関数を適用したストリームを返す、Haskellのリスト処理で言えば、「zipWith」に対応するものです。ただしストリームは非同期で離散的な値であるので、イベント生成タイミングとzipするべきペアは自明ではありません。combineLatestは「いずれかのストリームのイベント発生のタイミングで、それぞれのストリームの直近で最後の値」に対して、指定した関数を適用し、その結果から成るストリームを返します。</p>\n<p>このコードでは、refreshボタンのストリームから「推奨ユーザリストのストリーム」を生成させ、combineLatestで組合せることによって、close時に利用できる「refreshで最後に取得した推奨ユーザリスト」のイベントストリームを生成します。</p>\n<p>もちろん上記のコードはcombineLatestの意味がわからないと理解できませんが、ReactiveXの中核価値の一つは、ストリームに対する高機能なオペレータが数多く取り揃えられていることであり、それらを適切に使い分けて活用するのがRxのキモの一つだと思います。興味を引くための例示コードとしては適切だと言えましょう。</p>\n<p>実際、<a href=\"http://ninjinkun.hatenablog.com/entry/introrxja\">「あなたが求めていたリアクティブプログラミング入門」</a>でも(太字は引用者)、こんな風に書かれています。</p>\n<blockquote>\n<p>これは1つをクリックしただけなのに、クローズして全ての候補を再読み込みする。この問題を解決する方法は色々あるが、<strong>面白さを保つために</strong>も、先ほどのレスポンスを再利用して解決してみる。APIレスポンスのページサイズは100人のユーザー分あるが、我々は3人分しか使っていない。そこにはまだ豊富な新しいデータがある。追加のリクエストをする必要は無い</p>\n</blockquote>\n<h2>キャッシュしないバージョン</h2>\n<p>Affモナド版では、推奨ユーザ一覧の<del>キャッシュ処理を(おそらく)していません。「同機能なものに対するコード比較」をしてみるのも意味があるかと思うので、</del>(訂正、されておりました。大変もうしわけありません)。</p>\n<p>RxJSでキャッシュをしないバージョンも書いてみました(全体は<a href=\"http://jsdo.it/uehaj/rxjs2\">こちら</a>)。</p>\n<pre><code class=\"language-JavaScript\">// closeボタンにイベントストリームを設定するぜ!\n[[closeButton1, \".suggestion1\"],\n [closeButton2, \".suggestion2\"],\n [closeButton3, \".suggestion3\"]]\n    .forEach(([closeButton, selector]) =>\n             Rx.Observable.fromEvent(closeButton, 'click')\n             .startWith(null)\n             .merge(Rx.Observable.fromEvent(refreshButton, 'click').startWith(null))\n             .flatMap(() => getNewUsers())\n             .subscribe((listUsers) => renderSuggestion(listUsers[Math.floor(Math.random()*listUsers.length)], selector)))\n</code></pre>\n<p>上記ではcombineLatestは使用せずに、単にmergeをしています。「refreshを押したかあるいはその推奨ユーザに対するcloseを押したか」のいずれかで都度推奨ユーザ一覧の取得処理が行なわれます。</p>\n<p>ずいぶんと分かりやすくなった気がしますがいかがしょうか。</p>\n<h1>読み難いのか?</h1>\n<p>ここまで見てきたように、ReactiveX/RxJSのコードを読むにはストリームオペレータに関する知識を必要とします。でもそれは、例えばHaskellのList処理で、foldlとかscanl,zipWithなどの標準ライブラリ関数を使ったコードに対して、それらの関数が何をするかを知らないと理解が難しいと感じるのと同様です。</p>\n<p>逆にそれらに習熟したならば、短く書け、むしろ読みやすいと感じる場合も多々あるでしょう。</p>\n<p>ちなみに、このコードはRxの真価を発揮するのにはたぶん単純すぎます。複数の関連し合うイベントソースに対する処理記述において、モジュラリティとコンポーザビリティが得られることが、真にユニークな、ほかの方法では得られないリアクティブプログラミングの利点です。しかしだからといって、単純なケースが書きにくいわけではないと思います。例えば非同期モナド(Promise想定)などと少なくとも同程度ではないでしょうか。</p>\n<p>もちろん、ストリームが何個もあって、相互に絡みあう結合・分岐が複雑になってくると、わかりにくくなって、図表とかが必要になってくるでしょう。かと言ってそれをストリームを使わないで書いた場合、その何倍もツラいコードになる気がします。</p>\n<h2>んでやっぱり読み難いのか?(2017/2/23追記)</h2>\n<p>やってしまってもう恥かしいので、読者の判断におまかせしたいと思います。今後、redux-sagaなどで非同期バージョンを書いて比較してみようと思います。</p>\n<h1>redux-sagaでの非同期バージョン(2017/5/2追記)</h1>\n<p><a href=\"https://github.com/uehaj/followbox-redux-saga/blob/master/sagas.js\">redux-sagaでの非同期バージョン</a>を書いた。元の仕様に加えて、リフレッシュ・リムーブについてモーダルダイアログでの確認も追加している(sagaらしくて面白いので)。<a href=\"https://followbox-redux-saga-vevubwrmcf.now.sh/\">デモ</a></p>\n<pre><code class=\"language-javascript\">// show modal dialog and get user response(Ok/Cancel) synchronously\nfunction* askYesNo(content) {\n  yield put(Actions.setModal({ show: true, title: 'Are you sure?', content }));\n  const answer = yield race({\n    ok: take(Types.UI_MODAL_OK),\n    cancel: take(Types.UI_MODAL_CANCEL),\n  });\n  yield put(Actions.setModal({ show: false }));\n  return answer;\n}\n\n// remove and get new follower\nfunction* remove(users, action) {\n  // make sure to remove\n  if (\n    action.payload.verify &#x26;&#x26;\n    !(yield askYesNo(&#x3C;div>Delete and refresh this follower?&#x3C;/div>)).ok\n  ) {\n    return;\n  }\n  // get one random user from the users list\n  const user = users[Math.floor(Math.random() * users.length)];\n  yield put(Actions.setFollower({ idx: action.payload.idx, user }));\n}\n\n// refresh all folllowers\nexport function* refresh(action) {\n  // make sure to refresh\n  if (\n    action.payload.verify &#x26;&#x26;\n    !(yield askYesNo(&#x3C;div>Refresh all followers?&#x3C;br />&#x3C;/div>)).ok\n  ) {\n    return;\n  }\n  // remove all followers on screen immediately\n  yield [0, 1, 2].map(i =>\n    put(Actions.setFollower({ idx: i, user: { avatar_url: null } }))\n  );\n\n  try {\n    // get user list pool (reuse following remove calls)\n    yield put(Actions.setLoading(true));\n    const users = yield call(Api.getNewUsers);\n    yield put(Actions.setLoading(false));\n    // remove and refresh all followers\n    yield [0, 1, 2].map(i =>\n      fork(remove, users, Actions.remove({ idx: i, verify: false }))\n    );\n    // wait until remove link[x] clicks\n    yield takeLatest(Types.UI_REMOVE, remove, users);\n  } catch (e) {\n    console.error(e);\n  }\n}\n\n// single entry point to start all Sagas at once\nexport default function* rootSaga() {\n  yield takeLatest(Types.UI_REFRESH, refresh);\n}\n</code></pre>\n<h1>その他</h1>\n<ul>\n<li>元記事の「あなたが求めていたリアクティブプログラミング入門」のサンプルコードだけを読むと、結構ひどいという印象になるのはしょうがない気がする。かといって、稠密なプロフェッショナルコードが入門記事のサンプルとしてふさわしいか、というと違う気もする。難しいところです。</li>\n<li>ReactiveXの利点は他にもある。バックプレッシャーつきバッファリング、他言語での同アーキテクチャ共有などなど。</li>\n<li>私はReactiveX/RxJSの知識はあんまりありません(この記事を書くために調べただけで本格的に使ったことはない)ので、不足や間違いなどありましたらご指摘ください。</li>\n<li>この記事では流れでReactiveX/RxJSをもって「リアクティブプログラミングの代表」みたいな話にしてしまってますが、一例です。本当はそれどころかReactiveX/RxJSが厳密な意味でリアクティブプログラミングにあてはまるかは不明です(参考→<a href=\"http://postd.cc/what-is-functional-reactive-programming/\">FRP</a>。わけわかんねー。)。この記事では、少なくとも「広義のリアクティブプログラミング」にはあてはまるものだとみなしています。</li>\n<li>flatMapをネストさせていくときに、JSではdo記法がないので煩雑になるかと思いましたが(当初それが原因かと当て推量していた)、今回のコードではそんな複雑なものではありませんでした。</li>\n</ul>\n<h1>おわりに</h1>\n<p>元記事「リアクティブプログラミングとは何だったか」をかかれた、hiruberutoさまにおかれましては、上記調査のきっかけを作ってくださったことを感謝いたします。ありがとうございました。</p>","frontmatter":{"title":"「リアクティブプログラミングが読み難い」というのは本当なのか?","date":"February 20, 2020","cover":null}}},"pageContext":{"slug":"/blog/80056c1ff10c63dc7810/","previous":{"fields":{"slug":"/blog/969ef20ccef850d2e9b1/"},"frontmatter":{"title":"Material UIのスタイル指定(JSS)"}},"next":{"fields":{"slug":"/blog/7de2d1b0fb2aabf2f27d/"},"frontmatter":{"title":"第28回 オフラインリアルタイムどう書くの問題「十字の壁がそそり立つ世界の中を君は螺旋状に歩く」をRustで解く"}}}}}