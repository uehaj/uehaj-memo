{"componentChunkName":"component---src-templates-blog-post-tsx","path":"/blog/7de2d1b0fb2aabf2f27d/","result":{"data":{"site":{"siteMetadata":{"title":"Gatsby Starter Blog Grommet v2","author":"Ivan Ganev"}},"markdownRemark":{"id":"4697ae5e-535d-5b14-bce3-449d42d51d4b","excerpt":"第28回 オフラインリアルタイムどう書くの問題「十字の壁がそそり立つ世界の中を君は螺旋状に歩く」を、Rust(2015-02-22 nightly)で解きました。 u32だったのをu64にして、末尾再帰をloop…","html":"<p><a href=\"http://qiita.com/Nabetani/items/ce3b4f8a34de8987c6bc\">第28回 オフラインリアルタイムどう書くの問題「十字の壁がそそり立つ世界の中を君は螺旋状に歩く」</a>を、Rust(2015-02-22 nightly)で解きました。</p>\n<p>u32だったのをu64にして、末尾再帰をloopに置き換えただけで、追加問題も難なく実行できました。</p>\n<h1>感想</h1>\n<ul>\n<li>\n<p>このレベル(並列なし、Owned Pointerなし、traitなし)だと、Rustは単に「すばらしいC言語」。何もデメリットがない。C言語経験者だったら、単に楽しく便利なだけ。</p>\n<ul>\n<li>Boxとか駆使してライフタイムがごにょり始めると、コンパイルエラーを乗り越えるための苦痛が予想される…</li>\n</ul>\n</li>\n<li>Rustは関数型プログラミングと相性が悪いと思う。&#x26;mutとかとどう折り合いつけるの? 逆に&#x26;mutを避けたいなら、Rust使う意味あんの？</li>\n</ul>\n<h1>コード</h1>\n<pre><code class=\"language-rust\">#![allow(unused_variables)]\n#![allow(dead_code)]\n\nstatic DIREC_STR:[&#x26;'static str;4] = [\"E\", \"S\", \"W\", \"N\"];\nstatic TURN_RIGHT:i32 = 1;\nstatic TURN_LEFT:i32 = -1;\nstatic FORWARD:i32 = 0;\n\n#[derive(Debug)]\nstruct Segment {\n    steps: u64,\n    next_direc: i32\n}\n\nimpl Segment {\n    fn new(steps: u64, next_direc: i32) -> Segment {\n        Segment { next_direc:next_direc, steps:steps }\n    }\n}\n\n#[derive(Debug)]\nstruct You {\n    pos: u64,\n    direc: u32\n}\n\nfn trace_segment_and_turn(day_of_answer:u64, segment: &#x26;Segment, you: &#x26;mut You)\n{\n    if day_of_answer &#x3C; you.pos + (*segment).steps  {\n        you.pos = day_of_answer;\n        return;\n    }\n    you.pos += (*segment).steps;\n    you.direc = ((you.direc as i32+(*segment).next_direc + 4) % 4) as u32;\n}\n\nfn create_segments(n:u64, e:u64, s:u64, w:u64, wall_thickness: u64) -> Vec&#x3C;Segment>\n{\n    let mut segments = vec![\n        Segment::new(e,              TURN_RIGHT),\n        Segment::new(wall_thickness, TURN_RIGHT),\n        Segment::new(e,              TURN_LEFT),\n        Segment::new(s,              TURN_RIGHT),\n        Segment::new(wall_thickness, TURN_RIGHT),\n        Segment::new(s,              TURN_LEFT),\n        Segment::new(w,              TURN_RIGHT),\n        Segment::new(wall_thickness, TURN_RIGHT),\n        Segment::new(w,              TURN_LEFT),\n        Segment::new(n,              TURN_RIGHT)];\n    if n > 1 {\n        segments.push(Segment::new(wall_thickness, TURN_RIGHT));\n        segments.push(Segment::new(n-1,   TURN_LEFT));\n    } else {\n        segments.push(Segment::new(wall_thickness, FORWARD));\n    }\n    segments\n}\n\nfn trace_path(day_of_answer:u64, you: &#x26;mut You,\n              n:u64, e:u64, s:u64, w:u64, mut wall_thickness: u64) {\n    loop {\n        for segment in create_segments(n, e, s, w, wall_thickness).iter() {\n            trace_segment_and_turn(day_of_answer, segment, you);\n            if you.pos >= day_of_answer { return; }\n        }\n        you.pos += 1;\n        wall_thickness += 2;\n    }\n}\n\nfn solve(e:u64, s:u64, w:u64, n:u64, day_of_answer:u64) -> &#x26;'static str {\n    let mut you = You {pos:0, direc:0};\n    trace_path(day_of_answer, &#x26;mut you, e, s, w, n, 2);\n    return DIREC_STR[you.direc as usize]\n}\n\nfn test(e:u64, s:u64, w:u64, n:u64, day_of_answer:u64, expected:&#x26;str) {\n    assert_eq!(solve(e, s, w, n, day_of_answer), expected);\n}\n\n#[test]\nfn test_case() {\n    /*0*/ test( 2, 3, 5, 4, 85, \"S\" );\n    /*1*/ test( 1, 2, 3, 4, 1, \"E\" );\n    /*2*/ test( 1, 2, 3, 4, 2, \"S\" );\n    /*3*/ test( 1, 2, 3, 4, 3, \"S\" );\n    /*4*/ test( 1, 2, 3, 4, 4, \"W\" );\n    test( 2, 3, 5, 4,  85, \"S\");\n    test( 1, 2, 3, 4,  1, \"E\");\n    test( 1, 2, 3, 4,  2, \"S\");\n    test( 1, 2, 3, 4,  3, \"S\");\n    test( 1, 2, 3, 4,  4, \"W\");\n    test( 1, 2, 3, 4,  27, \"E\");\n    test( 1, 2, 3, 4,  63, \"E\");\n    test( 1, 2, 3, 4,  40, \"W\");\n    test( 1, 4, 3, 2,  40, \"S\");\n    test( 3, 3, 3, 3,  30, \"S\");\n    test( 3, 3, 3, 3,  31, \"E\");\n    test( 3, 3, 3, 3,  32, \"E\");\n    test( 3, 3, 3, 3,  70, \"S\");\n    test( 3, 3, 3, 3,  71, \"E\");\n    test( 3, 3, 3, 3,  72, \"E\");\n    test( 1, 1, 1, 1,  7, \"N\");\n    test( 1, 2, 1, 1,  7, \"W\");\n    test( 1, 6, 1, 1,  7, \"S\");\n    test( 1, 8, 1, 1,  7, \"E\");\n    test( 1, 1, 1, 1,  30, \"N\");\n    test( 1, 2, 1, 1,  30, \"W\");\n    test( 1, 5, 1, 1,  30, \"S\");\n    test( 1, 8, 1, 1,  30, \"E\");\n    test( 9, 9, 9, 9,  99, \"W\");\n    test( 5, 6, 3, 8,  3, \"E\");\n    test( 5, 8, 1, 1,  11, \"W\");\n    test( 2, 8, 1, 2,  18, \"S\");\n    test( 3, 2, 3, 1,  20, \"N\");\n    test( 3, 3, 8, 1,  28, \"N\");\n    test( 2, 5, 1, 2,  32, \"E\");\n    test( 2, 5, 1, 6,  33, \"E\");\n    test( 1, 2, 5, 7,  34, \"N\");\n    test( 3, 6, 5, 6,  36, \"E\");\n    test( 6, 2, 8, 1,  39, \"S\");\n    test( 3, 1, 2, 3,  41, \"W\");\n    test( 1, 1, 3, 4,  45, \"W\");\n    test( 1, 3, 1, 2,  46, \"N\");\n    test( 4, 4, 4, 4,  49, \"W\");\n    test( 3, 1, 4, 4,  55, \"N\");\n    test( 6, 6, 2, 1,  56, \"W\");\n    test( 3, 2, 1, 2,  59, \"S\");\n    test( 2, 7, 7, 1,  60, \"S\");\n    test( 3, 1, 1, 1,  63, \"N\");\n    test( 4, 6, 4, 1,  78, \"E\");\n    test( 7, 5, 3, 6,  79, \"W\");\n    test( 7, 8, 3, 1,  81, \"E\");\n    test( 3, 2, 5, 2,  82, \"S\");\n    test( 1, 1, 3, 4,  84, \"N\");\n    test( 7, 4, 1, 5,  88, \"S\");\n    test( 3, 6, 5, 3,  89, \"S\");\n    test( 1, 4, 2, 3,  92, \"N\");\n    test( 1, 3, 4, 5,  93, \"W\");\n    test( 2, 4, 8, 1,  94, \"W\");\n    test( 3, 6, 1, 7,  99, \"S\");\n}\n\nfn main() {\n    assert_eq!(solve(1234, 2345, 3456, 4567, 978593417), \"E\");\n    assert_eq!(solve(1234, 2345, 3456, 4567, 978593418), \"S\");\n    assert_eq!(solve(31415, 92653, 58979, 32384, 9812336139), \"W\");\n    assert_eq!(solve(31415, 92653, 58979, 32384, 9812336140), \"S\");\n    assert_eq!(solve(314159, 265358, 979323, 84626, 89099331642), \"S\");\n    assert_eq!(solve(314159, 265358, 979323, 84626, 89099331643), \"W\");\n}\n</code></pre>","frontmatter":{"title":"第28回 オフラインリアルタイムどう書くの問題「十字の壁がそそり立つ世界の中を君は螺旋状に歩く」をRustで解く","date":"February 20, 2020","cover":null}}},"pageContext":{"slug":"/blog/7de2d1b0fb2aabf2f27d/","previous":{"fields":{"slug":"/blog/48cb682cc3441f1066a3/"},"frontmatter":{"title":"第14回オフラインリアルタイムどう書くの参考問題をHaskellで解く"}},"next":{"fields":{"slug":"/blog/969ef20ccef850d2e9b1/"},"frontmatter":{"title":"Material UIのスタイル指定(JSS)"}}}}}