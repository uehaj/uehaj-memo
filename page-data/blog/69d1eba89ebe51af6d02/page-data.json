{"componentChunkName":"component---src-templates-blog-post-tsx","path":"/blog/69d1eba89ebe51af6d02/","result":{"data":{"site":{"siteMetadata":{"title":"Gatsby Starter Blog Grommet v2","author":"Ivan Ganev"}},"markdownRemark":{"id":"d720323a-9c86-569d-9b2f-716eed8026bc","excerpt":"DartのIsolateを使って相互に通信をする例。 追記あり Isolate→spawn元(main)の方向の通信は、ReceivePort.sendPortをspawn時に渡してやれば良いが、逆方向の通信(main→Isolate)は、spawnしたIsolate…","html":"<p>DartのIsolateを使って相互に通信をする例。</p>\n<p><a href=\"https://qiita.com/uehaj/items/69d1eba89ebe51af6d02#%E8%BF%BD%E8%A8%982\">追記あり</a></p>\n<p>Isolate→spawn元(main)の方向の通信は、ReceivePort.sendPortをspawn時に渡してやれば良いが、逆方向の通信(main→Isolate)は、spawnしたIsolate先でReceivePortを作成し、そのsendPortをmainに戻してもらい、そのsendport経由で送信することになる。</p>\n<p>sendPortをどうやって戻すかだが、以下ではIsolateに渡すReceivePort経由で受けとっている。(これ以外の良い方法は、グローバル変数にするとか以外にあるかな。どなたかご存知の方教えて!)</p>\n<p>そのとき、sendPortをStream.firstで受けとろうとすると、<a href=\"https://api.dartlang.org/stable/1.24.3/dart-async/Stream/first.html\">Stream.firstはSteramをlistenし受信後にsubscriptionをcancelしてしまう</a>ので、listenerを一回限りしか設定できないsingle-subscription streamでは継続受信できなくなってしまう。なのでStream. asBroadcastStreamでbroadcast streamにしておく必要がある。</p>\n<pre><code class=\"language-dart\">import 'dart:isolate';\nimport \"dart:async\";\n\nmain() async {\n  try {\n    var singleChannel = new ReceivePort();\n    await Isolate.spawn(echo, singleChannel.sendPort);\n\n    var multiChannel = singleChannel.asBroadcastStream();\n    var callbackSendPort = await multiChannel.first;\n    multiChannel.listen((msg) {\n      print('main: received ${msg}');\n      callbackSendPort.send('hoy!');\n    });\n  } catch (e) {\n    print('error ${e}');\n  }\n}\n\n// the entry point for the isolate\nvoid echo(sendPort) async {\n\n  var callBackReceivePort = new ReceivePort();\n  sendPort.send(callBackReceivePort.sendPort);\n  callBackReceivePort.listen((msg){\n    print('echo: received ${msg}');\n  });\n  while (true) {\n    await new Future.delayed(new Duration(seconds: 1));\n    sendPort.send(\"hello\");\n  }\n}\n</code></pre>\n<p>結果</p>\n<pre><code>% dart web/index2.dart\nmain: received hello\necho: received hoy!\nmain: received hello\necho: received hoy!\nmain: received hello\necho: received hoy!\n:\n</code></pre>\n<p>sendPortを送り戻してもらう他の方法としては、firstを使わずにストリームで最初に受けとる要素として取り出すという方法もあるだろう。\nこんな感じ。</p>\n<pre><code>    var callbackSendPort = null;\n    multiChannel.listen((msg) {\n      if (callbackSendPort == null) {\n        callbackSendPort = msg;\n      }\n      else {\n        print('main: received ${msg}');\n        callbackSendPort.send('hoy!');\n      }\n    });\n</code></pre>\n<p>これが嫌なのはまちがいない<sup id=\"fnref-1\"><a href=\"#fn-1\" class=\"footnote-ref\">1</a></sup>が、asBroadcastStreamも相当である。良い方法があればおしえてください。</p>\n<h1>追記</h1>\n<p><a href=\"https://www.cresc.co.jp/tech/java/Google_Dart/DartLanguageGuide.pdf\">https://www.cresc.co.jp/tech/java/Google_Dart/DartLanguageGuide.pdf</a>\n18.5節 アイソレート間の通信リンクの確立</p>\n<p>を見ると、後者の方法に近く、ただ</p>\n<pre><code>    var callbackSendPort = null;\n    multiChannel.listen((msg) {\n      if (msg is SendPort) {\n        callbackSendPort = msg;\n      }\n      else {\n        print('main: received ${msg}');\n        callbackSendPort.send('hoy!');\n      }\n    });\n</code></pre>\n<p>に相当するような、実行時の型で切りわけをしていますね。また接続状態を状態遷移でしっかりと管理している。</p>\n<h1>追記2</h1>\n<p>StreamIteratorを使うのが良いみたい。asBroadcastStream()が不要であり、型も気持ち守れて、状態変数を導入しなくてよい。</p>\n<pre><code class=\"language-dart\">import 'dart:isolate';\nimport \"dart:async\";\n\nmain() async {\n  try {\n    var channel = new ReceivePort();\n    await Isolate.spawn(echo, channel.sendPort);\n\n    StreamIterator itr = new StreamIterator(channel);\n    if (await itr.moveNext()) {\n       SendPort callbackSendPort = itr.current;\n       while (await itr.moveNext()) {\n         print('main: received ${itr.current}');\n         callbackSendPort.send('hoy!');\n       }\n    }\n  } catch (e) {\n    print('error ${e}');\n  }\n}\n\n// the entry point for the isolate\nFuture echo(sendPort) async {\n\n  var callBackReceivePort = new ReceivePort();\n  sendPort.send(callBackReceivePort.sendPort);\n  callBackReceivePort.listen((msg){\n    print('echo: received ${msg}');\n  });\n  while (true) {\n    await new Future.delayed(new Duration(seconds: 1));\n    sendPort.send(\"hello\");\n  }\n}\n</code></pre>\n<p>こちらも参考に\n<a href=\"https://speakerdeck.com/uehaj/dart-isolate-port-and-capabilities\">https://speakerdeck.com/uehaj/dart-isolate-port-and-capabilities</a></p>\n<div class=\"footnotes\">\n<hr>\n<ol>\n<li id=\"fn-1\">\n<p>型制約できなくなる気がする。Dartにユニオン型ってあったっけ。</p>\n<a href=\"#fnref-1\" class=\"footnote-backref\">↩</a>\n</li>\n</ol>\n</div>","frontmatter":{"title":"Dartのアイソレート間で相互通信をする例","date":"February 20, 2020","cover":null}}},"pageContext":{"slug":"/blog/69d1eba89ebe51af6d02/","previous":{"fields":{"slug":"/blog/60abb9be0dfac0755dcf/"},"frontmatter":{"title":"第13回オフラインリアルタイムどう書くの問題をFregeで解く"}},"next":{"fields":{"slug":"/blog/5f46b012f13e1d3cee55/"},"frontmatter":{"title":"第12回オフラインリアルタイムどう書くの問題「サイコロを転がす」をHaskellで解く"}}}}}