{"componentChunkName":"component---src-templates-blog-post-tsx","path":"/blog/79c277301f89d109c11d/","result":{"data":{"site":{"siteMetadata":{"title":"Gatsby Starter Blog Grommet v2","author":"Ivan Ganev"}},"markdownRemark":{"id":"47e76d10-4529-56bd-b699-e10b73f611ba","excerpt":"はじめに TypeScriptの関数型について、いまいちすっきりしてなかったので整理してみました。\nまず、準備としてとして とします。 関数定義の基本パターン 次に、関数定義の基本パターンとして とします。このときfunc1の型は「function func1(a: IHoge…","html":"<h1>はじめに</h1>\n<p>TypeScriptの関数型について、いまいちすっきりしてなかったので整理してみました。\nまず、準備としてとして</p>\n<pre><code class=\"language-TypeScript\">type IHoge = {\n    a: number;\n    b: string;\n}\n</code></pre>\n<p>とします。</p>\n<h1>関数定義の基本パターン</h1>\n<p>次に、関数定義の基本パターンとして</p>\n<pre><code class=\"language-TypeScript\">function func1(a: IHoge): IHoge {\n    return { a: 3, b: 'a'};\n}\n</code></pre>\n<p>とします。このときfunc1の型は「<code>function func1(a: IHoge): IHoge</code>」です。\n以降、このバリエーションを見ていきます。意味的にはすべて同じです。</p>\n<h1>アロー式での関数定義</h1>\n<pre><code class=\"language-TypeScript\">//-------------------------これ以上できないぐらいの型のフル指定(アロー式リテラル版)。------------------\n const func2: (a: IHoge) => IHoge\n    = (a: IHoge): IHoge => ({ a: 3, b: 'a'}) ;\n</code></pre>\n<p>アロー式で定義します。このときfunc2の型は「<code>const func2: (a: IHoge) => IHoge</code>」です。\nfunc1のfunction型とは型としては異なることがわかります。しかし両者の型は実質的には同じで、以下のように代入が可能です。</p>\n<pre><code class=\"language-TypeScript\">const func2_a: (a: IHoge) => IHoge = func1;\n</code></pre>\n<p>「これ以上できないぐらいの型のフル指定」では、func2というシンボルの型と、関数本体の定義の方で、関数と引数と返り値の型を二重に指定していることがわかると思います。これは無駄なので、省略を試みます。\nまず、シンボルの型を省略してみます。省略された場所は「<code>/**/</code>」で示します。</p>\n<pre><code class=\"language-TypeScript\">//-------------------------以下の2つは型推論によりほぼ同じ(アロー式リテラル版)------------------\nconst func3 /**/\n     = (a: IHoge): IHoge => ({ a: 3, b: 'a'}) ;\n\nconst func4 /**/\n    = (a: IHoge) /**/ => ({ a: 3, b: 'a'}) ;\n</code></pre>\n<p>のようになります。戻り値の型を省略したfunc4の場合、戻り値の型は関数本体から推論されていることになります。func4の戻り値の型は「<code>{ a: number; b: string; }</code>」で、IHogeとはノミナルな意味では一致しませんが、TypeScriptでは特に問題はありません。しかし一般には、この推論があたっているとは限らないので、func3のように明示したいところです。型チェックの意義が薄れるからです。</p>\n<p>次、引数の型を省略を試みます。</p>\n<pre><code class=\"language-TypeScript\">//-------------------------引数は型推論しないので型指定すべき(アロー式リテラル版)------------------\nconst func5 /**/\n    = (a: any/**/) : IHoge => ({ a: 3, b: 'a'}) ;\n</code></pre>\n<p>引数の型を省略すると、TypeScriptは呼び出し側の引数から型推論をすることはないので、「Parameter ‘a’ implicitly has an ‘any’ type.」というエラーになると思います(オプションによる)。ここではanyを補っていますが、こういうことをすると、引数の型チェックがなされなくなるので、やめるべきです。func1よりもコンパイル時に型エラーチェックできる能力が減損しています。</p>\n<p>次に、シンボルの型の方ではなく、関数定義本体の方の型を省略してみます。</p>\n<pre><code class=\"language-TypeScript\">//-------------------------以下の三つは同じ(アロー式リテラル版)------------------\nconst func6: (a: IHoge) => IHoge\n     = (a /**/) /**/ => ({ a: 3, b: 'a'}) ;\n\nconst func7: (a: IHoge) => IHoge\n     = (a /**/): IHoge => ({ a: 3, b: 'a'}) ;\n\nconst func8: (a: IHoge) => IHoge\n     = (a : IHoge) /**/ => ({ a: 3, b: 'a'}) ;\n</code></pre>\n<p>これでわかるように、関数定義本体の方の型は省略しても不都合がありません。\nfunc7, func8は二重指定になっています。\n<strong><em>個人的にはfunc6のパターンがお勧めです。</em></strong></p>\n<p>なお、func2〜3, 6〜8の型は「<code>const func*: (a: IHoge) => IHoge</code>」です。\nfunc4の型は「<code>const func11: (a: IHoge) => { a: number; b: string; }</code>」です。\nfunc5の型は「<code>const func5: (a: any) => IHoge</code>」です。</p>\n<h1>functionリテラル形式での関数定義</h1>\n<p>さて、今まではアロー式で型を与えてきましたが、まったく同じことがfunction形式の関数でも言えます。</p>\n<pre><code class=\"language-TypeScript\">//-------------------------これ以上できないぐらいの型のフル指定(functionリテラル版)。------------------\nconst func9: (a: IHoge) => IHoge\n    = function(a: IHoge): IHoge { return ({ a: 3, b: 'a'}) }\n\n//-------------------------以下の2つは型推論によりほぼ同じ(functionリテラル版)------------------\nconst func10 /**/\n    = function(a: IHoge): IHoge { return ({ a: 3, b: 'a'}) };\n\nconst func11 /**/\n    = function(a: IHoge) { return ({ a: 3, b: 'a'}) }\n\n//-------------------------引数は型推論しないので型指定すべき(functionリテラル版)------------------\nconst func12 /**/\n    = function(a: any/**/) : IHoge { return ({ a: 3, b: 'a'}) }\n\n//-------------------------以下の三つは同じ(functionリテラル版)------------------\nconst func13: (a: IHoge) => IHoge\n    = function(a /**/) /**/ { return ({ a: 3, b: 'a'}) }\n\nconst func14: (a: IHoge) => IHoge\n    = function(a /**/): IHoge { return ({ a: 3, b: 'a'}) }\n\nconst func15: (a: IHoge) => IHoge\n    = function(a : IHoge) { return ({ a: 3, b: 'a'}) }\n</code></pre>\n<p>個人的おすすめはこのfunc13のパターンです。</p>\n<p>このとき、func9〜10, 13〜15の型は「<code>const func*: (a: IHoge) => IHoge</code>」です。(functionではない)。\nfunc11の型は「<code>const func11: (a: IHoge) => { a: number; b: string; }</code>」です。\nfunc12の型は「<code>const func12: (a: any) => IHoge</code>」です。</p>\n<p>以下はテストコード。</p>\n<pre><code class=\"language-TypeScript\">const d = {a: 3, b: 'abc'};\nconst x1: number = func1(3); const y1: number = func1(d); const z1: IHoge = func1(d);\nconst x2: number = func2(3); const y2: number = func2(d); const z2: IHoge = func2(d);\nconst x3: number = func3(3); const y3: number = func3(d); const z3: IHoge = func3(d);\nconst x4: number = func4(3); const y4: number = func4(d); const z4: IHoge = func4(d);\nconst x5: number = func5(3); const y5: number = func5(d); const z5: IHoge = func5(d);\nconst x6: number = func6(3); const y6: number = func6(d); const z6: IHoge = func6(d);\nconst x7: number = func7(3); const y7: number = func7(d); const z7: IHoge = func7(d);\nconst x8: number = func8(3); const y8: number = func8(d); const z8: IHoge = func8(d);\nconst x9: number = func9(3); const y9: number = func9(d); const z9: IHoge = func9(d);\nconst x10: number = func10(3); const y10: number = func10(d); const z10: IHoge = func10(d);\nconst x11: number = func11(3); const y11: number = func11(d); const z11: IHoge = func11(d);\nconst x12: number = func12(3); const y12: number = func12(d); const z12: IHoge = func12(d);\nconst x13: number = func13(3); const y13: number = func13(d); const z13: IHoge = func13(d);\nconst x14: number = func14(3); const y14: number = func14(d); const z14: IHoge = func14(d);\nconst x15: number = func15(3); const y15: number = func15(d); const z15: IHoge = func15(d);\n</code></pre>\n<h1>まとめ</h1>\n<p>まとめますと、TypeScriptで関数の型定義は論理的には多種多様なパターンがありますが、個人的おすすめとして、</p>\n<pre><code class=\"language-TypeScript\">function シンボル(引数と型指定): 戻り値型指定 {\n 本体\n}\n</code></pre>\n<p>か、</p>\n<pre><code class=\"language-TypeScript\">const シンボル: (引数と型指定) => 戻り値型指定 = (引数指定) => {\n 本体\n}\n</code></pre>\n<p>が良いです。この2つで比べると、「=>」が出てこない上の方が一見簡単です。しかし「関数をかえす関数」の場合にはいずれにせよ「=>」を使わざるを得なくなります。</p>\n<pre><code class=\"language-TypeScript\">// 関数を返す関数\nfunction シンボル(引数と型指定A): (引数と型指定B) => 戻り値型指定 {\n return (引数指定B) => { 本体 }\n}\n</code></pre>\n<pre><code class=\"language-TypeScript\">// 関数を返す関数\nconst シンボル: (引数と型指定A) => (引数と型指定B) => 戻り値型指定\n = (引数指定A) => {\n return (引数指定B) => { 本体 }\n}\n</code></pre>\n<p>これの各箇所で型指定を省略する、しないのパターンがあるので組み合わせ的に爆裂していき、ややこしです。</p>\n<p>このルールをわかりやすく書きたかったのですが力およばず。読むポイントは、型アノテーションがどこか、型アノテーションはどこで終るか、です。</p>\n<p>そして、型指定を、本体側でがんばるか、シンボル側でがんばるかですが、シンボル側に直接指定する型指定の部分をがんばって定義し、本体から暗黙の推論をさせないほうが、きっちりした型エラーチェックができると思います。特に、型が「関数を返す関数を…」といった複雑になる場合は、リターン型からの推論は、コードをまちがえたら終わりで、ある意味anyを使うのと同じだからです。</p>\n<p>本体側からは型を省略していく方針もあれば、「重複をおそれずに」という方針もありえます。まあそこは適当に。</p>","frontmatter":{"title":"TypeScriptの関数の型指定まとめ","date":"February 20, 2020","cover":null}}},"pageContext":{"slug":"/blog/79c277301f89d109c11d/","previous":{"fields":{"slug":"/blog/60abb9be0dfac0755dcf/"},"frontmatter":{"title":"第13回オフラインリアルタイムどう書くの問題をFregeで解く"}},"next":{"fields":{"slug":"/blog/69d1eba89ebe51af6d02/"},"frontmatter":{"title":"Dartのアイソレート間で相互通信をする例"}}}}}