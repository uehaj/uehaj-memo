{"componentChunkName":"component---src-templates-blog-post-tsx","path":"/blog/3a65b9c7dcbcc800fbf4/","result":{"data":{"site":{"siteMetadata":{"title":"Gatsby Starter Blog Grommet v2","author":"Ivan Ganev"}},"markdownRemark":{"id":"f9341fa4-c4bc-5744-8287-fa7e1a22faf4","excerpt":"G* Advent Calendar 2017 20日目の記事です。 GrailsのO/Rマッピングライブラリである「GORM」は、Grailsから切りはなして単体で使用することもできます。これをスタンドアローンGORMと呼びます。 非WebアプリやGrails…","html":"<p>G* Advent Calendar 2017 20日目の記事です。</p>\n<p>Grailsの<a href=\"http://gorm.grails.org/latest/\">O/Rマッピングライブラリである「GORM」</a>は、Grailsから切りはなして単体で使用することもできます。これをスタンドアローンGORMと呼びます。</p>\n<p>非WebアプリやGrails以外の他のフレームワークから高機能なORMとして使うことも可能ですし、Grailsでのシステム開発の一部として、バッチやシェルスクリプトやsshでキックしたいとか、シェルアカウントの管理者権限者だけがデータベースにアクセスしたいときには、スタンドアローンGORMが有用なケースがあります。</p>\n<p>というのも、そういうケースでは以下のような選択肢があるにはあるのですが、いずれも固有の課題を抱えているからです。</p>\n<ol>\n<li><a href=\"http://docs.grails.org/latest/guide/commandLine.html#creatingCustomScripts\">grails scripts</a>としてGrailsサービスやGrailsドメインクラスを呼び出す処理などを記述し、Grailsのプロジェクトフォルダ(GRAILS_PROJ/scriptsを含む)に格納して、grailsコマンドで起動。\n問題は、プロジェクトソースコードを運用環境に展開しておく必要があること。</li>\n<li>DB処理をWeb APIとして公開して、それを叩くクライアントを開発する。\n転送速度がネックになったり、ポートを公開することでセキュリティの問題になるかもしれない。</li>\n<li>Service層をGrailsの<a href=\"https://grails.org/plugin/remoting\">Remoting Plugin</a>を使って公開する。\n問題は同上。</li>\n<li>SQLを叩く別プログラムを開発する(Groovy SQL, ..)。\nこの場合の問題は、GrailsのドメインクラスからDDL生成されたデータベースに対して、生SQLを書くのはかったるいだけではなく、ドメインクラスの制約(constraint)の処理を別途しなければならないということ。</li>\n</ol>\n<p>それぞれのケースで示した問題が許容できないとき、スタンドアローンGORMが有用です。</p>\n<p>さて、具体的な使用方法としては、Spring Bootのアプリケーションから呼び出すこともできるでしょう。\n本記事では、もっとストレートに素のGroovyスクリプトからGORMを呼び出す例を紹介します。</p>\n<h1>方法</h1>\n<p>たとえば、こんな感じでGroovyスクリプトを書いて、</p>\n<pre><code class=\"language-groovy\">@Grab('org.grails:grails-datastore-gorm-hibernate5:6.1.0.RELEASE')\n@GrabExclude('javax.transaction:jta')\n@Grab('com.h2database:h2:1.4.192')\n@Grab('org.apache.tomcat:tomcat-jdbc:8.5.0')\n@Grab('org.slf4j:slf4j-log4j12')\nimport java.lang.String\nimport org.grails.orm.hibernate.HibernateDatastore\nimport grails.gorm.annotation.Entity\n\n@Entity\nclass Book {\n    String title\n    static hasMany = [authors: Author]\n    String toString() {\"$id: $title\"}\n}\n\n@Entity\nclass Author {\n    String name\n    static hasMany = [books: Book]\n    static belongsTo = Book\n    String toString() {\"$id: $name\"}\n}\n\ndef hibernateDatastore = new HibernateDatastore([\n        'hibernate.hbm2ddl.auto': 'create-drop',\n        'dataSource.driverClassName': 'org.h2.Driver',\n        'dataSource.url': 'jdbc:h2:mem:devDb;MVCC=TRUE;LOCK_TIMEOUT=10000;DB_CLOSE_ON_EXIT=FALSE',\n        'dataSource.username': 'sa',\n        'dataSource.password': '',\n    ],\n    Author)\n\nAuthor.withTransaction {\n    Author a = new Author(name:'上原 潤二');\n    Book b1 = new Book(title: 'プログラミングGROOVY').addToAuthors(a).save()\n    Book b2 = new Book(title: 'Grails徹底入門').addToAuthors(a).save()\n    println Book.findByTitleLike('G%')\n}\n</code></pre>\n<p>GroovyおよびJDKがインストールされていれば、以下で実行できます。</p>\n<pre><code>> groovy groovyスクリプトファイル名\n</code></pre>\n<p>GroovyやJDK以外の何かを事前ダウンロードしたりインストールしたりフォルダ構成を考えたりコンパイルしたりビルドしたりビルドスクリプトを書いたりデプロイしたりパッケージングしたりが一切不要なのが利点です✌。</p>\n<p>なお、上記では@Entityでドメインクラスを定義していますが、データベースがGrailsアプリケーションの一部であるなら、Grailsアプリケーション本体のwar(やjar)に含まれるドメインクラスのクラスファイルのjarをクラスパスに含めれば別に書かなくても利用可能です(多分)。</p>","frontmatter":{"title":"スタンドアローンGORMをGroovyスクリプトからシュっと利用する","date":"February 20, 2020","cover":null}}},"pageContext":{"slug":"/blog/3a65b9c7dcbcc800fbf4/","previous":{"fields":{"slug":"/blog/53460a9772f2bfbaa3c1/"},"frontmatter":{"title":"第19回 オフラインリアルタイムどう書くの問題「不良セクタの隣」を、Haskellで解く"}},"next":{"fields":{"slug":"/blog/443580da712d2ccee159/"},"frontmatter":{"title":"npmのモジュールバージョン指定におけるチルダ(~)とキャレット(^)の違いについての直感的な理解"}}}}}