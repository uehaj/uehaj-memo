{"componentChunkName":"component---src-templates-blog-post-tsx","path":"/blog/48cb682cc3441f1066a3/","result":{"data":{"site":{"siteMetadata":{"title":"Gatsby Starter Blog Grommet v2","author":"Ivan Ganev"}},"markdownRemark":{"id":"3a6bd052-bc70-5f08-b14d-a264bb024e1a","excerpt":"第14回 オフラインリアルタイムどう書くの参考問題「眠れるモンスターを狩る」を、Haskellで解きました。Stateモナドを使ってみたけど苦労のわりには…。","html":"<p><a href=\"http://qiita.com/Nabetani/items/0597bd3af481e5834ae1\">第14回 オフラインリアルタイムどう書く</a>の参考問題「<a href=\"http://nabetani.sakura.ne.jp/hena/ord14linedung/\">眠れるモンスターを狩る</a>」を、Haskellで解きました。Stateモナドを使ってみたけど苦労のわりには…。</p>\n<pre><code class=\"language-haskell:monster.hs\">-- http://nabetani.sakura.ne.jp/hena/ord14linedung/\nimport Control.Monad\nimport Control.Monad.State\n    \ndata Monster = B|D|F|H|J|L deriving (Eq, Show)\ndata Arm = A|C|E|G|I|K deriving (Eq, Show)\n\nremoveOne e xs\n    | after == [] = before\n    | otherwise = before ++ tail(after)\n    where\n      before = takeWhile (\\t-> t /= e) xs\n      after = dropWhile (\\t-> t /= e) xs\n\nstep (ms, as, n)\n    | A `elem` as &#x26;&#x26; B `elem` ms = (True, (removeOne B ms, C:as, n+1))\n    | C `elem` as &#x26;&#x26; D `elem` ms = (True, (removeOne D ms, E:as, n+1))\n    | E `elem` as &#x26;&#x26; F `elem` ms = (True, (removeOne F ms, G:as, n+1))\n    | G `elem` as &#x26;&#x26; H `elem` ms = (True, (removeOne H ms, I:as, n+1))\n    | I `elem` as &#x26;&#x26; J `elem` ms = (True, (removeOne J ms, K:as, n+1))\n    | K `elem` as &#x26;&#x26; L `elem` ms = (True, (removeOne L ms, A:as, n+1))\n    | otherwise = (False, (ms, as, n))\n\nnext :: State ([Monster],[Arm],Int) Bool\nnext = state $ \\(ms, as, n) -> step (ms, as, n)\n\ntoMonster :: [Monster] -> Char -> [Monster]\ntoMonster xs ch = case ch of\n                    'B' -> B:xs\n                    'D' -> D:xs\n                    'F' -> F:xs\n                    'H' -> H:xs\n                    'J' -> J:xs\n                    'L' -> L:xs\n                    _ -> xs\n\ntoArm :: [Arm] -> Char -> [Arm]\ntoArm xs ch = case ch of\n                'a' -> A:xs\n                'c' -> C:xs\n                'e' -> E:xs\n                'g' -> G:xs\n                'i' -> I:xs\n                'k' -> K:xs\n                _ -> xs\n\ntoState :: [Char] -> ([Monster], [Arm], Int)\ntoState str = (foldl (toMonster) [] str, foldl (toArm) [] str, 0)\n\nsolve :: State ([Monster], [Arm], Int) ()\nsolve = do\n  result &#x3C;- next\n  if (result == False) then return () else solve\n\nsolve' :: [Char] -> ([Monster], [Arm], Int)\nsolve' str = do\n  execState solve (toState str)\n   \ntest :: [Char] -> String -> Bool\ntest str expected = do\n  let (_, _, n) = solve' str\n  n == read expected\n\nmain :: IO ()\nmain = do\n  print $ test \"gLDLBgBgHDaD\" \"6\" {-0-}\n  print $ test \"DBcDLaLgDBH\" \"6\" {-1-}\n  print $ test \"JJca\" \"0\" {-2-}\n  print $ test \"FJDLBH\" \"0\" {-3-}\n  print $ test \"HJBLFDg\" \"6\" {-4-}\n  print $ test \"HBaDLFJ\" \"6\" {-5-}\n  print $ test \"DJaHLB\" \"2\" {-6-}\n  print $ test \"gDLHJF\" \"3\" {-7-}\n  print $ test \"cJFgLHD\" \"5\" {-8-}\n  print $ test \"FFBJaJJ\" \"1\" {-9-}\n  print $ test \"FJeJFBJ\" \"2\" {-10-}\n  print $ test \"iJFFJJB\" \"3\" {-11-}\n  print $ test \"JBJiLFJF\" \"5\" {-12-}\n  print $ test \"JDiFLFBJJ\" \"8\" {-13-}\n  print $ test \"BDFDFFDFFLLFFJFDBFDFFFFDDFaDBFFB\" \"28\" {-14-}\n  print $ test \"DDFBFcBDFFFFFFLBFDFFBFLFDFDJDFDF\" \"24\" {-15-}\n  print $ test \"FDLBFDDBFFFeFFFFFDFBLDDFDDFBFFJF\" \"16\" {-16-}\n  print $ test \"FDBFFLFDFFDBBDFFBJDLFgDFFFDFFDFF\" \"0\" {-17-}\n  print $ test \"FDiFLDFFFFBDDJDDBFBFDFFFBFFDFLFF\" \"31\" {-18-}\n  print $ test \"FDFDJBLBLBFFDDFFFDFFFFFDDFBkFDFF\" \"30\" {-19-}\n  print $ test \"HBkFFFFHBLH\" \"3\" {-20-}\n  print $ test \"FBHHFFFHLaB\" \"2\" {-21-}\n  print $ test \"LFHFBBcHFHF\" \"0\" {-22-}\n  print $ test \"LFBHFFeFHBH\" \"7\" {-23-}\n  print $ test \"LgFHHHBFBFF\" \"3\" {-24-}\n  print $ test \"FFiFHBHLBFH\" \"0\" {-25-}\n  print $ test \"BFHHFFHBeFLk\" \"10\" {-26-}\n  print $ test \"FHFaBBHFHLFg\" \"5\" {-27-}\n  print $ test \"FFgacaFg\" \"0\" {-28-}\n  print $ test \"JHDaDcBJiiHccBHDBDH\" \"9\" {-29-}\n  print $ test \"FHJJLckFckFJHDFF\" \"12\" {-30-}\n  print $ test \"DeDHJHDFHJBLHDLLDHJLBDD\" \"22\" {-31-}\n  print $ test \"gJLLLJgJgJLJL\" \"0\" {-32-}\n  print $ test \"DaaaDDD\" \"0\" {-33-}\n  print $ test \"HFeJFHiBiiBJeJBBFFB\" \"9\" {-34-}\n  print $ test \"FJFFJDBHBHaLJBHJHDLHkLLLFFFgJgHJLHkJkB\" \"32\" {-35-}\n  print $ test \"giFLBiBJLLJgHBFJigJJJBLHFLDLL\" \"23\" {-36-}\n  print $ test \"cgkLJcLJJJJgJc\" \"2\" {-37-}\n  print $ test \"LDFHJHcFBDBLJBLFLcFJcDFBL\" \"22\" {-38-}\n  print $ test \"JJHHHkHJkHLJk\" \"1\" {-39-}\n  print $ test \"kHHBBaBgHagHgaHBBB\" \"11\" {-40-}\n  print $ test \"HDBFFDHHHDFLDcHHLFDcJD\" \"20\" {-41-}\n  print $ test \"HFFFHeFFee\" \"7\" {-42-}\n  print $ test \"gLLDHgDLgFL\" \"1\" {-43-}\n  print $ test \"JJJBBaBBHBBHaLBHJ\" \"7\" {-44-}\n  print $ test \"FBFBgJBDBDgF\" \"0\" {-45-}\n  print $ test \"LLLLakakLakLL\" \"7\" {-46-}\n  print $ test \"HeJHeJe\" \"0\" {-47-}\n  print $ test \"LDFLBLLeBLDBBFFBLFBB\" \"4\" {-48-}\n</code></pre>","frontmatter":{"title":"第14回オフラインリアルタイムどう書くの参考問題をHaskellで解く","date":"February 20, 2020","cover":null}}},"pageContext":{"slug":"/blog/48cb682cc3441f1066a3/","previous":{"fields":{"slug":"/blog/260f188851045cc091ac/"},"frontmatter":{"title":"React-SpringのHooks APIでブラウザアニメーションを基本から極めよう!"}},"next":{"fields":{"slug":"/blog/5f46b012f13e1d3cee55/"},"frontmatter":{"title":"第12回オフラインリアルタイムどう書くの問題「サイコロを転がす」をHaskellで解く"}}}}}