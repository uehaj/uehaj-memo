<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[Gatsby Starter Blog Grommet v2]]></title><description><![CDATA[This is a DEMO site! SSG - Gatsby JS, UI - Grommet v2]]></description><link>https://ganevru.github.io/gatsby-starter-blog-grommet</link><generator>GatsbyJS</generator><lastBuildDate>Sun, 29 Mar 2020 19:43:59 GMT</lastBuildDate><item><title><![CDATA[第12回オフラインリアルタイムどう書くの参考問題をFregeで解く]]></title><description><![CDATA[第12回 オフラインリアルタイムどう書くの参考問題「道なりの亀」を、JVM上で動作するHaskellライクな言語Frege(フレーゲ)で解きました。]]></description><link>https://ganevru.github.io/gatsby-starter-blog-grommet/blog/0e0e7979b7e2b19e55f5/</link><guid isPermaLink="false">https://ganevru.github.io/gatsby-starter-blog-grommet/blog/0e0e7979b7e2b19e55f5/</guid><pubDate>Thu, 20 Feb 2020 15:08:12 GMT</pubDate><content:encoded>&lt;p&gt;&lt;a href=&quot;http://qiita.com/Nabetani/items/1de39df381dfeee305ab&quot;&gt;第12回 オフラインリアルタイムどう書くの参考問題「道なりの亀」&lt;/a&gt;を、JVM上で動作するHaskellライクな言語&lt;a href=&quot;https://github.com/Frege/frege/wiki/_pages&quot;&gt;Frege&lt;/a&gt;(フレーゲ)で解きました。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-frege:turtle.fr&quot;&gt;package sample.Turtle where

type Position = Char
type Direction = Char
type Command = Char

pure native elemIndex indexOf :: String -&gt; Int -&gt; Int

ewData :: String
ewData = &quot;?&quot;++packed [&apos;A&apos;..&apos;K&apos;]++&quot;?&quot;++packed [&apos;L&apos;..&apos;V&apos;]++&quot;?&quot;++packed [&apos;W&apos;..&apos;Z&apos;]++packed [&apos;a&apos;..&apos;g&apos;]++&quot;?&quot;
         ++&quot;?hij?klm?nop?qrs?tuv?wxy?z01?234?567?&quot;

nsData :: String
nsData = &quot;?&quot;++&quot;ALWhknqtwz25&quot;++&quot;?&quot;++&quot;BMXilorux036&quot;++&quot;?&quot;++&quot;CNYjmpsvy147&quot;
         ++ &quot;?&quot; ++&quot;DOZ&quot; ++ &quot;?&quot; ++ &quot;EPa&quot; ++ &quot;?&quot; ++ &quot;FQb&quot; ++ &quot;?&quot; ++ &quot;GRc&quot; ++ &quot;?&quot; ++ &quot;HSd&quot;
         ++ &quot;?&quot; ++ &quot;ITe&quot; ++ &quot;?&quot; ++ &quot;JUf&quot; ++ &quot;?&quot; ++ &quot;KVg&quot; ++ &quot;?&quot;

moveForward :: (Position, Direction, [Char]) -&gt; Int -&gt; (Position, Direction, [Char])
moveForward (pos, dir, hist) 0 = (pos, dir, hist)
moveForward (&apos;7&apos;, &apos;S&apos;, hist) n = moveForward (&apos;e&apos;, &apos;N&apos;, hist++[&apos;e&apos;]) (n-1)
moveForward (&apos;6&apos;, &apos;S&apos;, hist) n = moveForward (&apos;f&apos;, &apos;N&apos;, hist++[&apos;f&apos;]) (n-1)
moveForward (&apos;5&apos;, &apos;S&apos;, hist) n = moveForward (&apos;g&apos;, &apos;N&apos;, hist++[&apos;g&apos;]) (n-1)
moveForward (&apos;e&apos;, &apos;S&apos;, hist) n = moveForward (&apos;7&apos;, &apos;N&apos;, hist++[&apos;7&apos;]) (n-1)
moveForward (&apos;f&apos;, &apos;S&apos;, hist) n = moveForward (&apos;6&apos;, &apos;N&apos;, hist++[&apos;6&apos;]) (n-1)
moveForward (&apos;g&apos;, &apos;S&apos;, hist) n = moveForward (&apos;5&apos;, &apos;N&apos;, hist++[&apos;5&apos;]) (n-1)
moveForward (pos, dir, hist) n = moveForward nextState (n-1)
    where
          nextState :: (Char, Char, [Char])
          nextState = (nextPos, dir, hist++(nextPos:[]))
          nextPos :: Char
          nextPos = case dir of
                      &apos;N&apos; -&gt; nextPosOf pos nsData (subtract 1)
                      &apos;W&apos; -&gt; nextPosOf pos ewData (subtract 1)
                      &apos;S&apos; -&gt; nextPosOf pos nsData (+1)
                      &apos;E&apos; -&gt; nextPosOf pos ewData (+1)
          nextPosOf :: Char -&gt; String -&gt; (Int -&gt; Int) -&gt; Char
          nextPosOf c map f = let i=map `elemIndex` (ord c) in if (i/=0) then ((unpacked map) !! (f i)) else &apos;?&apos;

turnDir :: Direction -&gt; String -&gt; Position -&gt; [Char] -&gt; State (Position, Direction, [Char]) ()
turnDir dir dirs pos hist = State.put (pos, (let x=(dirs `elemIndex` (ord dir)) in ((unpacked dirs) !! (x+1))), hist)

oneStep :: Command -&gt; State (Position, Direction, [Char]) ()
oneStep ch = do
  (pos, dir, hist) &amp;#x3C;- State.get
  case ch of
    &apos;L&apos; -&gt; turnDir dir &quot;ENWSE&quot; pos hist
    &apos;R&apos; -&gt; turnDir dir &quot;ESWNE&quot; pos hist
    _
          | ch `elem` [&apos;1&apos;..&apos;9&apos;] -&gt; State.put (moveForward (pos, dir, hist) (ord ch-ord &apos;0&apos;))
          | ch `elem` [&apos;a&apos;..&apos;f&apos;] -&gt; State.put (moveForward (pos, dir, hist) ((ord ch-ord &apos;a&apos;)+10))

solve :: [Command] -&gt; [Position]
solve cmd = reduce hist
        where (_,_,hist) = (let (v,s) = State.run (mapM_ oneStep cmd) initialState in s)
              reduce [] = []
              reduce (xs:&apos;?&apos;:_) = xs:(unpacked &quot;?&quot;)
              reduce (x:xs) = x:(reduce xs)
              initialState = (&apos;A&apos;,&apos;E&apos;,(unpacked &quot;A&quot;))

test cmd expected = do
    let result = packed $ solve (unpacked cmd)
    println $ result == expected

main args = do
    test &quot;2RcL3LL22&quot; &quot;ABCNYjmpsvy147edcbcdef&quot;  {- 0 -}
    test &quot;L3R4L5RR5R3L5&quot; &quot;A?&quot;  {- 1 -}
    test &quot;2ReLLe&quot; &quot;ABCNYjmpsvy147eTITe741yvspmjYNC&quot;  {- 2 -}
    test &quot;1ReRRe&quot; &quot;ABMXilorux036fUJUf630xuroliXMB&quot;  {- 3 -}
    test &quot;ReRRe&quot; &quot;ALWhknqtwz25gVKVg52zwtqnkhWLA&quot;  {- 4 -}
    test &quot;f&quot; &quot;ABCDEFGHIJK?&quot;  {- 5 -}
    test &quot;Rf&quot; &quot;ALWhknqtwz25gVK?&quot;  {- 6 -}
    test &quot;1Rf&quot; &quot;ABMXilorux036fUJ?&quot;  {- 7 -}
    test &quot;2Rf&quot; &quot;ABCNYjmpsvy147eTI?&quot;  {- 8 -}
    test &quot;aR1RaL1LaR1R2L1L2&quot; &quot;ABCDEFGHIJKVUTSRQPONMLWXYZabcdefg567432&quot;  {- 9 -}
    test &quot;2R1R2L1L2R1R2L1L2R1R2L1L2R1R2L1L2&quot; &quot;ABCNMLWXYjihklmponqrsvutwxy&quot;  {- 10 -}
    test &quot;2R4R2L4L2R4R2L4L2R4R2L4L2&quot; &quot;ABCNYjmlknqtwxy147efgVK?&quot;  {- 11 -}
    test &quot;R1L2R4R2L4L2R4R2L4L2R4R2L4L2&quot; &quot;ALMNYjmponqtwz0147eTUVK?&quot;  {- 12 -}
    test &quot;R2L2R4R2L4L2R4R2L4L2R4R2L4L2&quot; &quot;ALWXYjmpsrqtwz2347eTIJK?&quot;  {- 13 -}
    test &quot;R3L2R4R2L4L2R4R2L4L2R4R2L4L2&quot; &quot;ALWhijmpsvutwz2567eTI?&quot;  {- 14 -}
    test &quot;R5L2L5L1LaR1L4L5&quot; &quot;ALWhknopmjYNCBMXilorux0325gVKJIHGF&quot;  {- 15 -}
    test &quot;1R2L4L2R4R2L4L2R4&quot; &quot;ABMXYZabQFGHIJUfg?&quot;  {- 16 -}
    test &quot;2R2L4L2R4R2L4L2R4&quot; &quot;ABCNYZabcRGHIJKVg?&quot;  {- 17 -}
    test &quot;3R2L4L2R4R2L4L2R4&quot; &quot;ABCDOZabcdSHIJK?&quot;  {- 18 -}
    test &quot;4R2L4L2R4R2L4L2R4&quot; &quot;ABCDEPabcdeTIJK?&quot;  {- 19 -}
    test &quot;5R2L4L2R4R2L4L2R4&quot; &quot;ABCDEFQbcdefUJK?&quot;  {- 20 -}
    test &quot;LLL1RRR1LLL1RRR2R1&quot; &quot;ALMXYZ?&quot;  {- 21 -}
    test &quot;R3RRR3&quot; &quot;ALWhij?&quot;  {- 22 -}
    test &quot;1LLL4RRR1LR1RL1&quot; &quot;ABMXilm?&quot;  {- 23 -}
    test &quot;R2L1R2L1R3R4&quot; &quot;ALWXilmpsvut?&quot;  {- 24 -}
    test &quot;7R4f47LLLc6R9L&quot; &quot;ABCDEFGHSd?&quot;  {- 25 -}
    test &quot;5RR868L8448LL4R6&quot; &quot;ABCDEFEDCBA?&quot;  {- 26 -}
    test &quot;42Rd1RLLa7L5&quot; &quot;ABCDEFGRc?&quot;  {- 27 -}
    test &quot;RRLL6RLR1L5d12LaLRRL529L&quot; &quot;ABCDEFGRSTUV?&quot;  {- 28 -}
    test &quot;RLR7L6LL1LRRRcRL52R&quot; &quot;ALWhknqtuv?&quot;  {- 29 -}
    test &quot;1RLR8RLR1R437L99636R&quot; &quot;ABMXiloruxwtqnkhWLA?&quot;  {- 30 -}
    test &quot;LLL2L3La9Le5LRR&quot; &quot;ALWXYZOD?&quot;  {- 31 -}
    test &quot;R1LcRR491&quot; &quot;ALMNOPQRSTUV?&quot;  {- 32 -}
    test &quot;R8L1R1R512L8RLLReRf&quot; &quot;ALWhknqtwx0z?&quot;  {- 33 -}
    test &quot;1RcL8f1L29a5&quot; &quot;ABMXilorux036fedcbaZYXW?&quot;  {- 34 -}
    test &quot;R822LeL46LL39LL&quot; &quot;ALWhknqtwz25gfedcbaZYXW?&quot;  {- 35 -}
    test &quot;9R3L5LRRLb5R3L7cLLLR4L&quot; &quot;ABCDEFGHIJUf65?&quot;  {- 36 -}
    test &quot;7LLRRR2R3R69Lf76eR2L&quot; &quot;ABCDEFGHSdcbaPE?&quot;  {- 37 -}
    test &quot;8RRRLL3Le&quot; &quot;ABCDEFGHITe765?&quot;  {- 38 -}
    test &quot;8R5RLL6LbL4LL5bL&quot; &quot;ABCDEFGHITe7410z?&quot;  {- 39 -}
    test &quot;6LR2R1LR5LRLRL484L63&quot; &quot;ABCDEFGHITe741yxw?&quot;         {- 40 -}

  
&lt;/code&gt;&lt;/pre&gt;</content:encoded></item><item><title><![CDATA[【React+TypeScript】Function Componentで省略可能propsの省略した場合の値を型安全に指定する]]></title><description><![CDATA[https://github.com/microsoft/TypeScript/issues/27425#issuecomment-478004521 こんな問題がありますが、結論としては、回避策として「名前のついた型を指定しない」のが楽です。 リンク先から引用。]]></description><link>https://ganevru.github.io/gatsby-starter-blog-grommet/blog/036e17f54cf623cee1a6/</link><guid isPermaLink="false">https://ganevru.github.io/gatsby-starter-blog-grommet/blog/036e17f54cf623cee1a6/</guid><pubDate>Thu, 20 Feb 2020 15:08:12 GMT</pubDate><content:encoded>&lt;p&gt;&lt;a href=&quot;https://github.com/microsoft/TypeScript/issues/27425#issuecomment-478004521&quot;&gt;https://github.com/microsoft/TypeScript/issues/27425#issuecomment-478004521&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;こんな問題がありますが、結論としては、回避策として「名前のついた型を指定しない」のが楽です。&lt;/p&gt;
&lt;p&gt;リンク先から引用。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;const MyComponent = (props: { name: string, telephone: string }) =&gt; {
  ...
}

MyComponent.defaultProps = { telephone: &quot;222-333-4444&quot; }

// Works - good
const test = &amp;#x3C;MyComponent name=&quot;Hulk Hogan&quot; /&gt;

// Doesn&apos;t work - missing name, good
const test = &amp;#x3C;MyComponent /&gt;
&lt;/code&gt;&lt;/pre&gt;</content:encoded></item><item><title><![CDATA[TAPLのML実装をRustでやってみるシリーズ「4章 算術式のML実装」]]></title><description><![CDATA[TAPL本(Types And Programming Language、型システム入門)の各章にある「ML実装」の例をRustにポーティングしてみます。 まずは4章の算術式です。書籍でのtype termが保持するinfo…]]></description><link>https://ganevru.github.io/gatsby-starter-blog-grommet/blog/1ac71855d05132d54eb8/</link><guid isPermaLink="false">https://ganevru.github.io/gatsby-starter-blog-grommet/blog/1ac71855d05132d54eb8/</guid><pubDate>Thu, 20 Feb 2020 15:08:12 GMT</pubDate><content:encoded>&lt;p&gt;&lt;a href=&quot;http://www.amazon.co.jp/exec/obidos/ASIN/4274069117/uehaj-22/ref=nosim/&quot;&gt;TAPL本(Types And Programming Language、型システム入門)&lt;/a&gt;の各章にある「ML実装」の例をRustにポーティングしてみます。&lt;/p&gt;
&lt;p&gt;まずは4章の算術式です。書籍でのtype termが保持するinfoは、ソースからパージングするわけではないので略します。いらなそうなletは省きました(OCamlでの必要性は不明)。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;#![feature(box_patterns)]
#![feature(box_syntax)]

#[derive(Debug,Clone)]
enum Term {
    True,
    False,
    If(Box&amp;#x3C;Term&gt;, Box&amp;#x3C;Term&gt;, Box&amp;#x3C;Term&gt;),
    Zero,
    Succ(Box&amp;#x3C;Term&gt;),
    Pred(Box&amp;#x3C;Term&gt;),
    IsZero(Box&amp;#x3C;Term&gt;)
}

use Term::*;

fn is_numerical(t: &amp;#x26;Term) -&gt; bool {
    match *t {
        Zero =&gt; true,
        Succ(box ref t1) =&gt; is_numerical(t1),
        _ =&gt; false
    }
}

fn is_val(t: &amp;#x26;Term) -&gt; bool {
    match *t {
        True =&gt; true,
        False =&gt; true,
        _ =&gt; is_numerical(t)
    }
}

fn eval1(t: Term) -&gt; Term {
    match t {
        Zero =&gt; Zero,
        If(box True, box t2, _) =&gt; t2,
        If(box False, _, box t3) =&gt; t3,
        If(box t1, t2, t3) =&gt; If(box eval1(t1), t2, t3),
        Succ(box t1) =&gt; Succ(box eval1(t1)),
        Pred(box Zero) =&gt; Zero,
        Pred(box Succ(box ref t1)) if is_numerical(t1) =&gt; t1.clone(),
        Pred(box t1) =&gt; Pred(box eval1(t1)),
        IsZero(box Zero) =&gt; True,
        IsZero(box Succ(box ref t1)) if is_numerical(t1) =&gt; False,
        IsZero(box t1) =&gt; IsZero(box eval1(t1)),
        _ =&gt; panic!()
    }
}

fn main() {
    assert_eq!(format!(&quot;{:?}&quot;, True), &quot;True&quot;);
    assert_eq!(is_numerical(&amp;#x26;True), false);
    assert_eq!(is_numerical(&amp;#x26;Zero), true);
    assert_eq!(is_val(&amp;#x26;True), true);
    assert_eq!(is_val(&amp;#x26;If(box True,box True,box False)), false);
    assert_eq!(format!(&quot;{:?}&quot;, eval1(If(box True,box True,box False))), &quot;True&quot;);
    assert_eq!(format!(&quot;{:?}&quot;, eval1(If(box False,box True,box False))), &quot;False&quot;);
    assert_eq!(format!(&quot;{:?}&quot;, eval1(If(box IsZero(box Zero), box True, box False))), &quot;If(True, True, False)&quot;);
    assert_eq!(format!(&quot;{:?}&quot;, eval1(Succ(box Succ(box Zero)))), &quot;Succ(Succ(Zero))&quot;);
    assert_eq!(format!(&quot;{:?}&quot;, eval1(Pred(box Zero))), &quot;Zero&quot;);
    assert_eq!(format!(&quot;{:?}&quot;, eval1(Pred(box Succ(box Zero)))), &quot;Zero&quot;);
    assert_eq!(format!(&quot;{:?}&quot;, eval1(Pred(box Succ(box Zero)))), &quot;Zero&quot;);
    assert_eq!(format!(&quot;{:?}&quot;, eval1(IsZero(box Zero))), &quot;True&quot;);
    assert_eq!(format!(&quot;{:?}&quot;, eval1(IsZero(box Succ(box Zero)))), &quot;False&quot;);
    assert_eq!(format!(&quot;{:?}&quot;, eval1(IsZero(box Pred(box Succ(box Zero))))), &quot;IsZero(Zero)&quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;boxを除けば、ほぼOCamlと同等。GCの無い言語としては、良い線に行っていると思う。&lt;/li&gt;
&lt;li&gt;実行メモリモデルがまさにC/C++なので、参照と値、cloneを完璧に適切に使いわける必要がある。OCaml版では全く意識する必要がない点である。この区別をてきとうにやっておけばうまく動く、ということはない。ここがGC言語との違い。&lt;/li&gt;
&lt;li&gt;もし完璧に適切に使いわけられないならば、それはコンパイルが通らないことを意味する。やりとげてみると、目から鱗の自然な形なのだが、最初わからないとつらい。根性しかない。&lt;/li&gt;
&lt;li&gt;今回の場合、match式の背後にある「暗黙の代入」、すなわちマッチ対象から各パターン、ガード、枝の本体に分配されるための代入が、それぞれムーブセマンティクスなのか、ownershipをとらない参照(&amp;#x26;mutではない&amp;#x26;)なのか、boxなのかrefなのかbox refなのか、そのすべてが正しく的確に指定されている必要がある。matchが展開された結果における暗黙の代入の様子を想像する力が問われる。どっかにドキュメントありますかね…。&lt;/li&gt;
&lt;li&gt;Rustにおけるデータ管理は、「値」が基本になる、というのはたぶん間違いない。しかし、リアルワールドでは「値だけ」でやっていくことはできない。borrwingとclone()を適宜組合せる必要がある。&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[Reactベース静的サイトジェネレータGatsbyの真の力をお見せします]]></title><description><![CDATA[NTTテクノクロスの上原です。
業務では、社内情報のReact製自前キュレーションサイトの構築を担当しています。過去に社外ブログにReactVRの記事を途中まで書いたりしましたが、ReactVR(今は改名されてReact 36…]]></description><link>https://ganevru.github.io/gatsby-starter-blog-grommet/blog/1b7f0a86596353587466/</link><guid isPermaLink="false">https://ganevru.github.io/gatsby-starter-blog-grommet/blog/1b7f0a86596353587466/</guid><pubDate>Thu, 20 Feb 2020 15:08:12 GMT</pubDate><content:encoded>&lt;p&gt;NTTテクノクロスの上原です。
業務では、社内情報のReact製自前キュレーションサイトの構築を担当しています。過去に&lt;a href=&quot;https://www.ntt-tx.co.jp/column/dojo_review_blog/20170511/?utm_source=qiita&amp;#x26;utm_medium=ac2018&amp;#x26;utm_campaign=24&quot;&gt;社外ブログにReactVRの記事&lt;/a&gt;を途中まで書いたりしましたが、ReactVR(今は改名されて&lt;a href=&quot;https://facebook.github.io/react-360/&quot;&gt;React 360&lt;/a&gt;)が思ったより流行らなくて放置してしまい、誠に申し訳ないです。&lt;/p&gt;
&lt;p&gt;この記事は&lt;a href=&quot;https://qiita.com/advent-calendar/2018/ntt-tx&quot;&gt;NTTテクノクロスAdvent Calendar24日目&lt;/a&gt;の記事であり、社内の勉強会で発表した内容をQiita記事として書きなおしたものです。タイトルは釣りです。
(&lt;a href=&quot;https://qiita.com/uehaj/items/1b7f0a86596353587466#20181228%E8%BF%BD%E8%A8%98&quot;&gt;2018/12/28追記&lt;/a&gt;あり)&lt;/p&gt;
&lt;h1&gt;導入&lt;/h1&gt;
&lt;h2&gt;記事を書いた理由&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://www.gatsbyjs.org/&quot;&gt;Gatsby.js&lt;/a&gt;(以降、Gatsbyと表記)は&lt;a href=&quot;https://www.gatsbyjs.org/docs/performance/&quot;&gt;さまざまな高速化テクニック&lt;/a&gt;を用いた「爆速サイト生成」で有名なツールですが、そのリッチな機能性は、たとえばイントラ内サイト、業務システム開発、ツール開発などでも十分に活用できるものだと思い、その可能性を紹介するために書きました。&lt;/p&gt;
&lt;h2&gt;「静的サイトジェネレータ」って何？&lt;/h2&gt;
&lt;p&gt;いわゆる「静的サイトジェネレータ(Static Site Generator, SSG)」は、CMS(コンテンツ管理システム)の一種です。代表的なものには以下があります。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://jekyllrb-ja.github.io/&quot;&gt;Jekyll&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://gohugo.io/&quot;&gt;Hugo&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://octopress.org/&quot;&gt;Octopress&lt;/a&gt; &lt;br/&gt;
　 :&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;他にも&lt;a href=&quot;https://www.staticgen.com/&quot;&gt;多くが実装・公開&lt;/a&gt;されています。&lt;/p&gt;
&lt;p&gt;Webサイトの公開・構築に良く使われるWordPressなどのCMSは、記事の「閲覧時」に動的にサイト内容を生成しますが、静的サイトジェネレータは、閲覧時ではなく「ビルド時」にHTMLやCSSなどをあらかじめ生成しておくことが特徴です。&lt;/p&gt;
&lt;h2&gt;一般的な利点&lt;/h2&gt;
&lt;p&gt;「静的サイトジェネレータ」の一般的な利点は以下のとおりです。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Webサイトのコンテンツを、サーバの設定や実行なしでAWS S3やGitHub pagesに置ける。これにより&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;アプリサーバやDBが落ちるといった事象によってサイト公開が停止することがない&lt;/li&gt;
&lt;li&gt;処理負荷に強い&lt;/li&gt;
&lt;li&gt;動的CMS(Wordpress等)やアプリサーバ処理、DB処理に起因する脆弱性は回避できる&lt;/li&gt;
&lt;li&gt;背景: Wordpress(及びそのプラグイン)の脆弱性は頻繁に発見されるので対応が大変&lt;/li&gt;
&lt;li&gt;サーバの利用・運用コストを削減できる&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;CDNと相性が良くスケールしやすい&lt;/li&gt;
&lt;li&gt;Gitでコンテンツ管理ができる&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Gatsbyとは&lt;/h2&gt;
&lt;p&gt;Gatsbyは、松田優作のCMでおなじみの…ではなく、ここではReactベースの静的サイトジェネレータです。最新のフロントエンド技術を駆使し、高速に閲覧できるサイトを生成できることで有名です。&lt;/p&gt;
&lt;p&gt;たとえば、Reactの&lt;a href=&quot;https://reactjs.org/&quot;&gt;公式サイト&lt;/a&gt;はGatsbyを使用したサイトですが、このサイトをDevToolsで観察しながら閲覧すると、ページをスクロールするのに応じてクリックしなくても通信が走ることがわかります。これは、Gatsbyのランタイムが、表示エリアにリンクがはいってきた時点でリンク先コンテンツをプリフェッチしメモリ中に読み込み、クリック時には瞬時に表示できるようにしているからです。このような&lt;a href=&quot;https://www.gatsbyjs.org/docs/performance/&quot;&gt;高速化のための高度な工夫&lt;/a&gt;が各種行われています。&lt;/p&gt;
&lt;h2&gt;わたしの疑問&lt;/h2&gt;
&lt;p&gt;自分が当初Gatsbyについて理解できていなかったのは、Reactとの関係です。&lt;/p&gt;
&lt;p&gt;静的サイトジェネレータというぐらいだから、GatsbyはReactコードをSSR(Server Side Rendering)のようにあらかじめレンダリングして、静的なHTMLを事前に生成するのかな、と思いました。だから、JSコードはビルド時のみに実行されて、閲覧時には実行されないのかな、と。&lt;/p&gt;
&lt;p&gt;このように思った理由は、他の静的サイトジェネレータの動作からの類推で、たとえばRubyベースのJekyllなどは、ビルド時にテンプレートをRubyインタプリタで評価してHTMLを生成し、閲覧時には一切Rubyコードは実行されません(されたら静的にならない)。ならば同じく、Gatsbyでも「JSコードはビルド時のみに実行されて、閲覧時には実行されない」のかなと思うじゃないですか。&lt;/p&gt;
&lt;p&gt;しかし、調べると、そうではありませんでした。&lt;/p&gt;
&lt;h1&gt;Gatsbyの特徴と動作&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;GatsbyはSSR的な静的HTML生成に加えて、それと連動する通常のReactアプリも生成します。&lt;/em&gt;&lt;/strong&gt;
Create React AppやNext.jsと同様に、Reactで開発する&lt;strong&gt;&lt;em&gt;SPAの自由度を完全に具備する&lt;/em&gt;&lt;/strong&gt;ものです。&lt;/p&gt;
&lt;p&gt;詳しく見てみましょう。&lt;/p&gt;
&lt;h2&gt;Create React App(CRA)の動作&lt;/h2&gt;
&lt;p&gt;まず、Gatsbyの説明をする前に、Create React Appを使ったときのReactアプリの生成と動作の様子を見てみます。下図のように、ビルド時に&lt;code&gt;create-react-app build&lt;/code&gt; コマンドを実行、bundle.jsを生成し、それを読み込むindex.htmlと合わせてデプロイします。Reactアプリは、ブラウザ中で初めて実行されます。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://qiita-image-store.s3.amazonaws.com/0/9979/7b9dbeed-d816-e382-74fa-79be90d036a3.png&quot; alt=&quot;output_751673bcbfe8ef280417264a4042c06d-0.png&quot;&gt;&lt;/p&gt;
&lt;h2&gt;一般的なSSR(Next.jsなど)の動作&lt;/h2&gt;
&lt;p&gt;次に、Next.jsなどを用いたSSR(Server Side Rendering)を見てみましょう。
ブラウザが初期ページを読み込むタイミングで、サーバ側のNode.jsでReactアプリが実行され、初期HTMLを生成(SSR)します。ブラウザがそれを読み込んで初期表示し、引き続きReactアプリを実行し、仮想DOMの更新や、SPAとしての実行にうまいこと繋げてくれます。必要があればReduxのステートの転送なども行なわれます。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://qiita-image-store.s3.amazonaws.com/0/9979/d845a654-5e27-b74f-683c-02d220d7129a.png&quot; alt=&quot;output_751673bcbfe8ef280417264a4042c06d-1.png&quot;&gt;&lt;/p&gt;
&lt;h2&gt;Gatsbyの動作&lt;/h2&gt;
&lt;p&gt;さて、Gatsbyです。Gatsbyは、Reactアプリをビルド時に1回実行し、HTMLを生成します。HTMLを生成する動作はSSRと同様なのですが、サーバ上ではなく、ビルドマシン上で実行することが異なります。このHTMLをJSと共にデプロイし、ブラウザはそれを初期ページとして読み込み、SSRと同様にReactアプリの実行が再度なされ、仮想DOM更新、SPAとしての実行、Reduxステートなどが引き継がれます。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://qiita-image-store.s3.amazonaws.com/0/9979/2da83462-0ab5-5827-4cb3-99239359b088.png&quot; alt=&quot;output_751673bcbfe8ef280417264a4042c06d-2.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;そして、ブラウザ内でのReactアプリとしての実行は通常と同じで、API呼び出しを実行しても良いし、redux-sagaの実行など、任意の動作が可能です&lt;sup id=&quot;fnref-3&quot;&gt;&lt;a href=&quot;#fn-3&quot; class=&quot;footnote-ref&quot;&gt;3&lt;/a&gt;&lt;/sup&gt;。ただし、プリフェッチやコード分割にも関わるので、ルーティングはGatsbyの仕組みに従った方が良いでしょう&lt;sup id=&quot;fnref-2&quot;&gt;&lt;a href=&quot;#fn-2&quot; class=&quot;footnote-ref&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;。Gatsbyでは、ルーティングは内部的にアクセシビリティ(a11y)向上のために&lt;a href=&quot;https://www.gatsbyjs.org/blog/2018-09-27-reach-router/&quot;&gt;@reach/routerが使用&lt;/a&gt;されています。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://material-ui.com/&quot;&gt;Material UI&lt;/a&gt;なども&lt;a href=&quot;https://www.gatsbyjs.org/packages/gatsby-plugin-material-ui/&quot;&gt;プラグインを使用して&lt;/a&gt;使用可能です(&lt;a href=&quot;https://github.com/gatsbyjs/gatsby/issues/9200#issuecomment-434604930&quot;&gt;コード例&lt;/a&gt;、&lt;a href=&quot;https://qiita.com/github0013@github/items/f268ca6609e47298d308&quot;&gt;参考になるページ&lt;/a&gt;)&lt;/p&gt;
&lt;h1&gt;Gatsby動作をもう少し詳しく&lt;/h1&gt;
&lt;h2&gt;ビルド時GraphQL&lt;/h2&gt;
&lt;p&gt;上記まででも、サイト作成には十分に便利だと思いますが、Gatsbyのもう一つの大きな特徴は、ビルド時のさまざまな処理(データ取得と変換、使用)を「&lt;a href=&quot;https://www.gatsbyjs.org/docs/graphql/&quot;&gt;ビルド時GraphQL&lt;/a&gt;」で統一的に行えることです。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://qiita-image-store.s3.amazonaws.com/0/9979/afdcbeda-545b-f556-b8cf-57b4c2169ba9.png&quot; alt=&quot;output_751673bcbfe8ef280417264a4042c06d-3.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;静的サイトジェネレータとしての典型的な処理は、Markdown形式のテキスト情報を、ファイルシステムから読み込んで、GraphQL経由で取得し、Reactコンポーネント内で表示することです。
しかし、Gatsbyではそれを上記のようにdata source, data transformerという枠組みで一般化することで、多様な処理を統一的にかつ簡潔に記述することができます。&lt;/p&gt;
&lt;h2&gt;こんなこともできる&lt;/h2&gt;
&lt;p&gt;ビルド時に形成されるGraphQL DBの内容は、ブラウザ内での実行時にはアクセスできません。これはビルド時だけのものです。
ちなみにたとえば、実行時にまったく別のGraphQLサーバにアクセスすることができます。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://qiita-image-store.s3.amazonaws.com/0/9979/ddb761b3-7192-4985-a9f5-36aae334829c.png&quot; alt=&quot;output_751673bcbfe8ef280417264a4042c06d-4.png&quot;&gt;&lt;/p&gt;
&lt;h2&gt;「ビルド時GraphQL」の結果をブラウザ内のReactコンポーネントにも渡す&lt;/h2&gt;
&lt;p&gt;さてここで一つの疑問が浮かぶかもしれません。
ビルド時に形成されるGraphQL DBの内容は、閲覧時のブラウザ内のReactアプリからはアクセスできないとしたら、ビルド時に得られたGraphQLのクエリ結果の情報は、ブラウザ内のReactコンポーネントではどのように入手できるのでしょうか? それが取得できないかぎり、SPAとしてHTMLと同じ画面を再現することはできません。
生成物を見ると、Gatsbyはこの問題を解決するために以下のような処理をしているようです。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;ビルド時&lt;/li&gt;
&lt;li&gt;GraphQLクエリをビルド時実行&lt;/li&gt;
&lt;li&gt;クエリ結果を使ってReactアプリを静的HTMLにレンダリング&lt;/li&gt;
&lt;li&gt;このとき得られたGraphQLのクエリ結果はJSONで保存しておく。&lt;/li&gt;
&lt;li&gt;デプロイ時&lt;/li&gt;
&lt;li&gt;上記で生成された静的HTMLをデプロイ&lt;/li&gt;
&lt;li&gt;同時に、上で保存していたJSONも静的コンテンツとしてデプロイ&lt;/li&gt;
&lt;li&gt;ブラウザでの閲覧時&lt;/li&gt;
&lt;li&gt;静的HTMLを初期表示&lt;/li&gt;
&lt;li&gt;裏でReactアプリ実行、仮想DOMを再構築(SSRと同じ)&lt;/li&gt;
&lt;li&gt;保存されたJSONを読み込み、同じ表示を再現する&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;まとめると、ビルド時に形成されたGarphQL DBの全体は必要ないので、「クエリの結果」のみをJSONとして合わせてデプロイし、ブラウザ内ではGraphQL DBクエリ結果取得の代りにJSON値を使うことで、同じ表示を再現するというわけです。&lt;/p&gt;
&lt;h2&gt;Gatsby Plugins&lt;/h2&gt;
&lt;p&gt;GraphQL DBを作成するために、種々の&lt;a href=&quot;https://www.gatsbyjs.org/plugins/?=tranformer&quot;&gt;data transformer&lt;/a&gt;,&lt;a href=&quot;https://www.gatsbyjs.org/plugins/?=source&quot;&gt;data source&lt;/a&gt;がプラグインとして利用可能です。&lt;/p&gt;
&lt;a href=&quot;https://www.gatsbyjs.org/plugins/&quot;&gt;
![output_751673bcbfe8ef280417264a4042c06d-5.png](https://qiita-image-store.s3.amazonaws.com/0/9979/812431ca-6ab0-f08c-6fa4-a81ec237ae36.png)
&lt;/a&gt;
&lt;h2&gt;コード例&lt;/h2&gt;
&lt;p&gt;以下に、GraphQLを使ったGatsbyコードの例を示します。
処理内容は、&lt;a href=&quot;https://www.gatsbyjs.org/packages/gatsby-source-wordpress/&quot;&gt;gatsby-source-wordpress&lt;/a&gt;を用いてWordPressからAPIでビルド時に記事をとって来て、アイキャッチ画像含めたリンクとして画面に嵌め込むというものです。&lt;/p&gt;
&lt;p&gt;Wordpress APIでビルド時に取得された情報から、以下のGraphQL クエリで一連の記事情報を取り出します。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;export default withRoot(withStyles(styles)(Top))

export const pageQuery = graphql`
  query {
    allWordpressPost {
      edges {
        node {
          id
          title
          link
          content
          featured_media {
            source_url
          }
        }
      }
    }
  }
`
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;以下ではクエリ結果としての記事情報を、Reactコンポーネントの内容に組み込んでいます。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;class BlogPosts extends React.Component&amp;#x3C;IProps&gt; {
  public render() {
    const { classes, allWordpressPost } = this.props

    return (
      &amp;#x3C;div
        className={classNames(classes.layout)}
        style={{ marginTop: &apos;1rem&apos;, marginBottom: &apos;1rem&apos; }}
      &gt;
        &amp;#x3C;Grid container={true} spacing={40}&gt;
          {allWordpressPost.edges.map(edge =&gt; {
            const content = edge.node.content ? edge.node.content : &apos;&apos;
            const strippedContent = content.replace(/&amp;#x3C;(?:.|\n)*?&gt;/gm, &apos;&apos;)

            return (
              &amp;#x3C;Grid key={edge.node.id} item={true} xs={12} sm={6} md={4} lg={3}&gt;
                &amp;#x3C;ContentCard
                  imageUrl={edge.node.featured_media.source_url}
                  heading={edge.node.title}
                  targetUrl={edge.node.link}
                &gt;
                  &amp;#x3C;Typography component=&quot;p&quot;&gt;{strippedContent}&amp;#x3C;/Typography&gt;
                &amp;#x3C;/ContentCard&gt;
              &amp;#x3C;/Grid&gt;
            )
          })}
        &amp;#x3C;/Grid&gt;
      &amp;#x3C;/div&gt;
    )
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Gatsbyビルドのようす&lt;/h2&gt;
&lt;p&gt;上記の準備の上、プラグインの設定もした上で、以下のようにGatsbyプロジェクトをビルドできます。ビルド中にWordpress APIにアクセスしていることがわかります。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;% npm run build
&gt; gatsby-starter-default@1.0.0 build /Users/uehaj/work/201812/techhub-gatsby
&gt; gatsby build

success open and validate gatsby-configs — 0.013 s
success load plugins — 0.270 s
success onPreInit — 4.173 s
success delete html and css files from previous builds — 0.063 s
success initialize cache — 0.006 s
success copy gatsby files — 0.710 s
success onPreBootstrap — 0.007 s
⠂ source and transform nodes -&gt; wordpress__POST fetched : 12
⢀ source and transform nodes -&gt; wordpress__PAGE fetched : 5
⠐ source and transform nodes -&gt; wordpress__wp_media fetched : 38
⠁ source and transform nodes -&gt; wordpress__wp_taxonomies fetched : 1
⠄ source and transform nodes -&gt; wordpress__CATEGORY fetched : 4
⢀ source and transform nodes -&gt; wordpress__TAG fetched : 13
⠈ source and transform nodes -&gt; wordpress__wp_users fetched : 4
success source and transform nodes — 2.745 s
success building schema — 0.798

  :
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;組込まれた表示例&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;http://demo.wp-api.org/&quot;&gt;http://demo.wp-api.org/&lt;/a&gt;サイトからWordPress API経由で記事を取得してReact画面に組み込んだ例は以下のとおり。アイキャッチ画像が設定されてないので寂しい…。&lt;/p&gt;
&lt;img width=&quot;996&quot; alt=&quot;&amp;#x30B9;&amp;#x30AF;&amp;#x30EA;&amp;#x30FC;&amp;#x30F3;&amp;#x30B7;&amp;#x30E7;&amp;#x30C3;&amp;#x30C8; 2018-12-30 20.40.43.png&quot; src=&quot;https://qiita-image-store.s3.amazonaws.com/0/9979/320da9c2-a7c8-7da8-832c-1e806ebce5f4.png&quot;&gt;
# &amp;#x307E;&amp;#x3068;&amp;#x3081;
&lt;h2&gt;「爆速サイト」が必要ない場合でも得られるGatsbyの利点&lt;/h2&gt;
&lt;p&gt;サイトの高速性や、CDNで大規模スケールさせることは、イントラ向けシステムやツール開発などでは必ずしも必要ではないかもしれません。しかし、仮にそれを除いたとしても、Gatsbyには以下の利点があります。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;通常ならDBで保持する/手書き修正のところ、ビルド時にUIに組込める&lt;/em&gt;&lt;/strong&gt;。たとえば、&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;入力フォームの「組織一覧」の選択肢を、ビルド時に他のWebサイトやAPI、CSVなどから取得し・最新化する&lt;/li&gt;
&lt;li&gt;インクリメンタルサーチの選択肢&lt;/li&gt;
&lt;li&gt;「運営からのお知らせ」情報&lt;/li&gt;
&lt;li&gt;なんらかの巡回収集&lt;/li&gt;
&lt;li&gt;運用環境からはセキュリティ上の理由でアクセス可能にさせたくない情報源から抽出した情報の組み込み&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;上記をGraphQLとプラグイン群を使って、&lt;strong&gt;&lt;em&gt;極めてシンプルに書ける&lt;/em&gt;&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;データの入力やオーサリングをWordPressなどCMSにまかせ、表示をカスタム化することでシステム開発を単純化できる&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;em&gt;しかもPHPを書かずに !!&lt;/em&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;この用途に特化した&lt;a href=&quot;https://www.google.co.jp/search?q=headless+cms&amp;#x26;rls=com.microsoft:ja:%7Breferrer:source?%7D&amp;#x26;ie=UTF-8&amp;#x26;oe=UTF-8&amp;#x26;sourceid=ie7&amp;#x26;rlz=1I7GFRE_ja&quot;&gt;Headless CMSというジャンルのプロダクト&lt;/a&gt;も出ている&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;CD(Continuous Delivery,継続的デリバリ)と組合せると、&lt;strong&gt;&lt;em&gt;有用性はさらにUP!&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;「記事をWordPressで公開したタイミングでwebhookを叩いてビルド、デプロイ」など&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;各種の便利なプラグインが使用できる &lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;JAMSatckアーキテクチャ1実装としてのGatsby&lt;/h2&gt;
&lt;p&gt;ちなみに、Gatsbyのような静的サイト生成を活用したWebシステムアーキテクチャを「&lt;a href=&quot;https://jamstack.org/&quot;&gt;JAMSatckアーキテクチャ&lt;/a&gt;」と呼ぶそうです。下図は&lt;a href=&quot;https://jamstack.org/&quot;&gt;https://jamstack.org/&lt;/a&gt;より引用。&lt;/p&gt;
&lt;img width=&quot;1133&quot; alt=&quot;&amp;#x30B9;&amp;#x30AF;&amp;#x30EA;&amp;#x30FC;&amp;#x30F3;&amp;#x30B7;&amp;#x30E7;&amp;#x30C3;&amp;#x30C8; 2018-12-21 18.46.57.png&quot; src=&quot;https://qiita-image-store.s3.amazonaws.com/0/9979/0f5ad0bf-5663-9209-91b4-089cedee1930.png&quot;&gt;
&lt;p&gt;以下が噛み砕いたJAMStackべからず集です。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Wordpressを使わない&lt;/li&gt;
&lt;li&gt;ブラウジング時のSSRを使わない&lt;/li&gt;
&lt;li&gt;モノリシックではない&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;利点としては、静的サイトジェネレータで得られるものすべてに加え、CDN、およびその付随機能を活用できるということです。サーバーレス時代にも向いたアーキテクチャと言えるでしょう。&lt;/p&gt;
&lt;h2&gt;おわりに&lt;/h2&gt;
&lt;p&gt;まとめますと、&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Gatsbyを「静的サイトジェネレータ」と呼んでしまうと、「動的サイト」は作れない、という印象をもってしまうかもしれないがそうではなく&lt;sup id=&quot;fnref-1&quot;&gt;&lt;a href=&quot;#fn-1&quot; class=&quot;footnote-ref&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;、React SPAとしてのすべての機能を発揮できる、CRAと同種の存在でもある。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CRAと同様に、babelやwebpackを呼び出す&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;もちろん、Wordpress代替として爆速、CDNを駆使しスケールする、といった優れた性質をもっており、Gatsbyにとって「静的サイトをジェネレートすること」は主要な用途である。&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;しかしながら、Gatsbyの有効性はそれに限られず、以下のような利点があり、着目したい。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;UI構築の一部をビルド時に移動&lt;/li&gt;
&lt;li&gt;ある種の「サーバレス」を推進&lt;/li&gt;
&lt;li&gt;強力なGraphQLを駆使して、UIコード構築処理を(ビルド時に前倒しした上で)簡素化する。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;と言うことで、いかがでしょうか、Gatsbyの魅力が少しでも伝われば幸いです。
では、みなさん良いお年を‼️(ムースをつけた両手で髪の毛をかきあげながら)&lt;/p&gt;
&lt;h1&gt;2018/12/28追記&lt;/h1&gt;
&lt;p&gt;記事を書いた後に、Gatsbyチームの方が&lt;a href=&quot;https://www.reactiflux.com/transcripts/gatsby-team/&quot;&gt;インタビューで以下のように発言&lt;/a&gt;されているのを見つけました。本稿「私の疑問」のところで抱いた疑問は、他にも感じる人もいたということですね。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Q: What is one thing that Gatsby is capable of doing that might surprise some people? — ctlee
A: Gatsby can be used to build fully dynamic sites, which surprises some people because of it’s label as a “static site generator”. It’s fully equipped to be a powerful alternative to create-react-app and other similar solutions with the addition of easy pre-rendering and perf baked in.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;(拙訳)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Q: Gatsbyができることで、他の人が驚くかもしれないことは何ですか?&lt;/li&gt;
&lt;li&gt;A: Gasbyはフルに動的なサイトを開発するのに使うことができるが、Gatbyを「静的サイトジェネレータ」とラベリングしている人を驚かすときもあるかもね。これはcreate-react-app(や同種のもの)の完全でパワフルな機能代替であり、加えてプリレンダリングと高性能があらかじめ組込まれているものなんだ。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;footnotes&quot;&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id=&quot;fn-2&quot;&gt;
&lt;p&gt;Next.jsでもルーティングはNext.jsのルータにまかせるのと同様に。&lt;/p&gt;
&lt;a href=&quot;#fnref-2&quot; class=&quot;footnote-backref&quot;&gt;↩&lt;/a&gt;
&lt;/li&gt;
&lt;li id=&quot;fn-3&quot;&gt;
&lt;p&gt;とはいえ、今ビルド中なのか、ブラウザ中なのか、や、ライフサイクルフックを通じて緻密な分岐処理が必要になることもある。&lt;/p&gt;
&lt;a href=&quot;#fnref-3&quot; class=&quot;footnote-backref&quot;&gt;↩&lt;/a&gt;
&lt;/li&gt;
&lt;li id=&quot;fn-1&quot;&gt;
&lt;p&gt;SPAのサイトを「静的サイト」と呼べるなら静的サイトジェネレータでも良いわけだが、あまり聞かないような気がする。&lt;/p&gt;
&lt;a href=&quot;#fnref-1&quot; class=&quot;footnote-backref&quot;&gt;↩&lt;/a&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</content:encoded></item><item><title><![CDATA[TaPLのML実装をRustでやってみるシリーズ「7章 ラムダ計算のML実装」]]></title><description><![CDATA[TAPL本(Types And Programming Language、型システム入門)の各章にある「ML実装」の例をRustにポーティングしてみるシリーズ、「7章のラムダ計算のML実装」です。…]]></description><link>https://ganevru.github.io/gatsby-starter-blog-grommet/blog/161f3c943faf35c6aefc/</link><guid isPermaLink="false">https://ganevru.github.io/gatsby-starter-blog-grommet/blog/161f3c943faf35c6aefc/</guid><pubDate>Thu, 20 Feb 2020 15:08:12 GMT</pubDate><content:encoded>&lt;p&gt;&lt;a href=&quot;http://www.amazon.co.jp/exec/obidos/ASIN/4274069117/uehaj-22/ref=nosim/&quot;&gt;TAPL本(Types And Programming Language、型システム入門)&lt;/a&gt;の各章にある「ML実装」の例をRustにポーティングしてみるシリーズ、「7章のラムダ計算のML実装」です。&lt;a href=&quot;http://qiita.com/uehaj/items/1ac71855d05132d54eb8&quot;&gt;4章の&lt;/a&gt;に比べるといきなり難易度が上がります。全体からしたら序の口でしょうが。&lt;/p&gt;
&lt;h1&gt;説明&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;unstableなゲート化された機能&lt;a href=&quot;https://doc.rust-lang.org/book/box-syntax-and-patterns.html&quot;&gt;box_patterns&lt;/a&gt;を1箇所で使用しているので、Rust 1.0 betaではコンパイルできず、unstable機能がerrorにならないnightly版でしかコンパイルできません。趣旨からして、おそらく1.0 release版でも実行できないでしょう。でもこれを使わずに実装することができなかったのでやむなく。(&lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/0469-feature-gate-box-patterns.md&quot;&gt;参考&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;以下でnamed.rsは、名無し項ではなく、通常の項を表現するものです。7章には指導がないが、名無し項への変換がないと余りに不便なので作りました。&lt;/li&gt;
&lt;li&gt;以下のようなλ計算が評価できます。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;     println!(&quot;{:?}&quot;,
             apply(abst(&quot;a&quot;, 
                         apply(abst(&quot;b&quot;,
                                    apply(var(&quot;b&quot;), abst(&quot;x&quot;, var(&quot;b&quot;)))),
                               apply(var(&quot;a&quot;), abst(&quot;z&quot;, var(&quot;a&quot;)))
                               )),
                    abst(&quot;w&quot;, var(&quot;w&quot;))
                    ).remove_names().eval());
// 結果は(lambda w. w)
&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt;気づいたことや工夫&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;Termのような再帰的データ構造を実現するために、enumでowned pointerを使用すると、Box::newが頻出したりして可読性が悪化するが、enumのデータ構築子をそのまま使うのではなく、以下のような、引数にTermを受けとってBox::newを実行した上でデータ構築を行うような、簡単なラッパーを作ると構築に関しては簡潔さを維持できる。ついでに&amp;#x26;str→String変換しておく。欲を出すと、そういう関数群を自動的deriveしてくれるようなTraitがあればいいのに。 &lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;fn abst(s:&amp;#x26;str, t:Term) -&gt; Term {
    Abst(s.to_string(), Box::new(t))
}

fn apply(t1:Term, t2:Term) -&gt; Term {
    Apply(Box::new(t1), Box::new(t2))
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;de Bruijn Indexは、数学的証明との対応がしやすい以外のメリットはたぶんなく、本当のコンパイラの実装では導入しない種類のものと思われる。まあ変数名集合の集合操作でやるよりはプログラムっぽいが。&lt;/li&gt;
&lt;li&gt;何度も言うがrustのパターンマッチは難しい気がする。&amp;#x26;,mut,ref,box,などがやっかいにしている。もっとドキュメントもしくは経験が必要だ。&lt;/li&gt;
&lt;li&gt;RustではHaskellやMLのように入れ子になった関数で親をアクセスするものは定義できないらしい(&lt;a href=&quot;http://stackoverflow.com/questions/26685666/a-local-function-in-rust&quot;&gt;参考&lt;/a&gt;)。Closure使えばいいのだろうが、再帰呼び出しするClosureはきれいには定義できない(&lt;a href=&quot;http://stackoverflow.com/questions/16946888/recursive-closure-in-rust&quot;&gt;参考&lt;/a&gt;)。&lt;/li&gt;
&lt;li&gt;環境変数RUST&lt;em&gt;BACKTRACEを1にするとpanic!時などにスタックトレースが表示される。`&lt;code&gt;&lt;/code&gt;env RUST&lt;/em&gt;BACKTRACE=1 cargo test`&lt;code&gt;&lt;/code&gt; みたいに使うとよろし。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust:nameless.rs&quot;&gt;// http://www.cis.upenn.edu/~bcpierce/tapl/checkers/untyped/
#![allow(dead_code)]
#![allow(unused_variables)]
#![allow(unused_imports)]

use std::fmt::Debug;
use std::fmt::Formatter;
use std::fmt::Error;

#[derive(Clone,PartialEq)]
pub enum Term {
    // Single Varialbe
    Var(isize, // de Bruijn Index.
        usize), // length of Context where this variable appealed.
    // Abstraction
    Abst(String, // lambda variable name
         Box&amp;#x3C;Term&gt;), // lambda body
    // Application
    Apply(Box&amp;#x3C;Term&gt;, // function
          Box&amp;#x3C;Term&gt;) // argument
}

#[derive(Debug,Clone)]
pub enum Binding {
    NameBind
}

pub type Context = Vec&amp;#x3C;(String, Binding)&gt;;

fn index2name(ctx: &amp;#x26;Context, idx: isize) -&gt; String {
    if idx &gt; ctx.len() as isize-1 {
        return format!(&quot;fv{}&quot;, idx)
    }
    ctx[(ctx.len() as isize-idx-1) as usize].0.to_string()
}

use nameless::Term::*;

pub fn add_name(ctx:&amp;#x26;Context, name:&amp;#x26;String) -&gt; Context {
    let mut new_ctx = ctx.clone();
    new_ctx.push((name.clone(), Binding::NameBind));
    new_ctx
}

fn pick_fresh_name(ctx:&amp;#x26;Context, x:&amp;#x26;String) -&gt; (Context, String) {
    if ctx.iter().any(|&amp;#x26;(ref var_name,_)|{*var_name==*x}) {
        //名前xがctxに存在(重複)していたら、新規名称に変更して再トライ
        pick_fresh_name(ctx, &amp;#x26;format!(&quot;{}&apos;&quot;, x))
    }
    else { // 重複しない名前を得たら
        // ctxにその名前を登録して、(ctx,その名前)を返す。
        (add_name(ctx, x), x.clone())
    }
}

fn print_term(ctx:&amp;#x26;Context, t:&amp;#x26;Term) -&gt; String {
    match *t {
        Abst(ref var_name, ref t1) =&gt; {
            // λ var_name . t1 は、var_nameを環境ctxでユニークであるx_にした上で、
            // x_をctxに登録しそのx_を登録したctx(ctx_)の元で、t1を表示する。
            let (ctx_, x_) = pick_fresh_name(ctx, var_name);
            format!(&quot;(lambda {}. {})&quot;, x_, print_term(&amp;#x26;ctx_, &amp;#x26;t1))
        },
        Apply(ref t1, ref t2) =&gt; {
            format!(&quot;({} {})&quot;, print_term(ctx, &amp;#x26;t1), print_term(ctx, &amp;#x26;t2))
        },
        Var(x, n) =&gt; {
            if ctx.len() == n {
                format!(&quot;{}&quot;, index2name(ctx, x))
            } else {
                format!(&quot;[bad index, ctx.len={}, n={}]&quot;, ctx.len(), n).to_string()
            }
        }
    }
}

impl Debug for Term {
    fn fmt(&amp;#x26;self, fmt:&amp;#x26;mut Formatter) -&gt; Result&amp;#x3C;(), Error&gt; {
        fmt.write_str(&amp;#x26;format!(&quot;{}&quot;, print_term(&amp;#x26;vec![], self)))
    }
}

fn term_shift(d:isize, t:&amp;#x26;Term) -&gt; Term {
    fn term_shift_helper(c:isize, d:isize, t:&amp;#x26;Term) -&gt; Term {
        match *t {
            Var(x, n) =&gt;
                if x &gt;= c { Var(x+d, (n as isize + d) as usize) }
                else { Var(x, (n as isize + d) as usize) },
            Abst(ref x, ref t1) =&gt;
                Abst(x.clone(), Box::new(term_shift_helper(c+1, d, &amp;#x26;t1))),
            Apply(ref t1, ref t2) =&gt;
                Apply(Box::new(term_shift_helper(c, d, t1)), Box::new(term_shift_helper(c, d, t2)))
        }
    }

    term_shift_helper(0, d, t)
}

fn term_subst(j:isize, s:&amp;#x26;Term, t:&amp;#x26;Term) -&gt; Term {
    fn term_subst_helper(j:isize, s:&amp;#x26;Term, c:isize, t:&amp;#x26;Term) -&gt; Term {
        match *t {
            Var(x, n) =&gt;
                if x == j+c { term_shift(c, s) } else { Var(x, n) },
            Abst(ref x, ref t1) =&gt;
                Abst(x.clone(), Box::new(term_subst_helper(j, s, c+1, t1))),
            Apply(ref t1, ref t2) =&gt;
                Apply(Box::new(term_subst_helper(j, s, c, t1)), Box::new(term_subst_helper(j, s, c, t2)))
        }
    }
    term_subst_helper(j, s, 0, t)
}

fn term_subst_top(s:&amp;#x26;Term, t:&amp;#x26;Term) -&gt; Term {
    // Apply(Abst(x, t12), v2@Abst(_,_))
    //
    //                        -1        1
    // (λ.t12) v2    →    ↑   ([0→↑  (v2)] t12)
    //
    // 「Apply(Abst(x, t12), v2@Abst(_,_))」の評価は、t12が使用して
    // いる変数x(de Bruijn index=0)をv2で置換するということである
    // (β簡約)。しかし、v2も(de Bruijn index 0)を参照している可能
    // 性があるので、単なる置換はできない。そのためには、v2の(de
    // Bruijn index 0)を(de Bruijn index 1)にする必要がある。さらに、
    // v2はもともと(de Bruijn index 1)を使用しているかもしれないの
    // で、0→1、1→2、2→3...というようにv2で使用している変数すべ
    // ての玉つきでの増加が必要。これが内側のシフト操作
    //      1
    // 0→↑  (v2) 
    // の意味である。
    // 上記より、無事v2から(de Bruijn index 0)を消去できたとして、
    // λの中にあったt12を、λ取ってその外側の中で通用する値として
    // 機能させるには、ネストレベルを一個浅くする必要がある。これが
    // 外側の
    //   -1
    // ↑
    // の操作である。これが意味するのは最内周の変数(de Bruijn
    // index 0)の削除であり、de Bruijn index 1以上の変数をそれぞれ
    // 1個インデックスが減るようにずらす。t12の(de Bruijn index 0)
    // をv2で置換した結果には、(de Bruijn index 0)は(置換されている
    // ので)もう存在していないので、これは安全に実行できる。
    term_shift(-1, &amp;#x26;term_subst(0, &amp;#x26;term_shift(1, s), t))
}

fn is_val(t: &amp;#x26;Term) -&gt; bool {
    match *t {
        Abst(_,_) =&gt; true,
        _ =&gt; false
    }
}

fn eval1(ctx:&amp;#x26;Context, t:&amp;#x26;Term) -&gt; Option&amp;#x3C;Term&gt; {
    match t {
        &amp;#x26;Apply(box Abst(ref x, box ref t12), ref v2) if is_val(v2) =&gt; {
            Some(term_subst_top(v2, &amp;#x26;t12))
        },
        // Apply(v1@Abst(_,_), t2)
        // (λ _._) t2
        &amp;#x26;Apply(ref v1, ref t2) if is_val(v1) =&gt; {
            match eval1(ctx, t2) {
                Some(t2_) =&gt; {
                    // (λ _._) t2_
                    Some(Apply(v1.clone(), Box::new(t2_)))
                },
                None =&gt; None
            }
        },
        // Apply(t1, t2)
        &amp;#x26;Apply(ref t1, ref t2) =&gt; {
            match eval1(ctx, &amp;#x26;t1) {
                Some(t1_) =&gt; Some(Apply(Box::new(t1_), t2.clone())),
                None =&gt; None
            }
        },
        _ =&gt; None
    }
}

fn eval(ctx:&amp;#x26;Context, t:&amp;#x26;Term) -&gt; Term {
    match eval1(ctx, &amp;#x26;t) {
        Some(x) =&gt; x.eval(),
        None =&gt; t.clone()
    }
}

impl Term {
    pub fn eval(&amp;#x26;self) -&gt; Term {
        eval(&amp;#x26;vec![], self)
    }
}

fn abst(s:&amp;#x26;str, t:Term) -&gt; Term {
    Abst(s.to_string(), Box::new(t))
}

fn apply(t1:Term, t2:Term) -&gt; Term {
    Apply(Box::new(t1), Box::new(t2))
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;テストコードを含めたものは&lt;a href=&quot;https://gist.github.com/uehaj/07a2f4856a2c51df4e1f&quot;&gt;こちらのgist&lt;/a&gt;にあります。&lt;/p&gt;</content:encoded></item><item><title><![CDATA[React-SpringのHooks APIでブラウザアニメーションを基本から極めよう!]]></title><description><![CDATA[🎄メリークリスマスイブ!🎄 この記事は、React-Springというアニメーションのライブラリを紹介する NTTテクノクロス Advent Calendar 2019 の24日目の記事です。23日目は@yuitomoさんの記事、明日25日最終日は@korodroid…]]></description><link>https://ganevru.github.io/gatsby-starter-blog-grommet/blog/260f188851045cc091ac/</link><guid isPermaLink="false">https://ganevru.github.io/gatsby-starter-blog-grommet/blog/260f188851045cc091ac/</guid><pubDate>Thu, 20 Feb 2020 15:08:12 GMT</pubDate><content:encoded>&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&quot;center&quot;&gt;&lt;/th&gt;
&lt;th align=&quot;center&quot;&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;&lt;img src=&quot;https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/9979/040fa6a5-ce1b-508a-4188-cbe338b1c1ef.gif&quot;&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;img src=&quot;https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/9979/e9ab5ed6-d800-c7f9-acd3-31c2afc2666e.gif&quot;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;&lt;img src=&quot;https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/9979/8a144326-7fb8-b8b9-07f7-a332add19764.gif&quot;&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;img src=&quot;https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/9979/c9d55e89-2034-97a6-21dd-c4308734cab4.gif&quot;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;&lt;img src=&quot;https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/9979/4558dd53-12af-3b37-ed10-13f06d5bca51.gif&quot;&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;🎄メリークリスマスイブ!🎄&lt;/em&gt;&lt;/strong&gt; この記事は、&lt;a href=&quot;https://www.react-spring.io/&quot;&gt;React-Spring&lt;/a&gt;&lt;sup id=&quot;fnref-1&quot;&gt;&lt;a href=&quot;#fn-1&quot; class=&quot;footnote-ref&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;というアニメーションのライブラリを紹介する &lt;a href=&quot;https://qiita.com/advent-calendar/2019/ntt-tx&quot;&gt;NTTテクノクロス Advent Calendar 2019&lt;/a&gt; の24日目の記事です。23日目は&lt;a href=&quot;https://qiita.com/yuitomo/items/390cced1122a1b01f37f&quot;&gt;@yuitomo&lt;/a&gt;さんの記事、明日25日最終日は@korodroidさんの記事です。&lt;/p&gt;
&lt;img src=&quot;https://user-images.githubusercontent.com/619186/51572411-7e04a880-1e8c-11e9-802c-251f150a1e69.gif&quot; width=&quot;80%&quot;&gt; 
[^1]: &amp;#x30ED;&amp;#x30B4;&amp;#x753B;&amp;#x50CF;&amp;#x306F;https://user-images.githubusercontent.com/619186/51572411-7e04a880-1e8c-11e9-802c-251f150a1e69.gif &amp;#x3088;&amp;#x308A;&amp;#x5F15;&amp;#x7528;
&lt;p&gt;2019年、令和初の年末も押しせまってまいりましたが、みなさん如何おすごしでしょうか? NTTテクノクロスの上原と申します。React/Gatsbyを用いた社内キュレーションサイトの構築や運用などを担当しています。当社では上記含め、SPAの開発にReactが採用されるケースも比較的多く、&lt;a href=&quot;https://www.ntt-tx.co.jp/column/dojo_review_blog/20170511/?utm_source=qiita&amp;#x26;utm_medium=ac2019&amp;#x26;utm_campaign=24&quot;&gt;社外ブログにReactVRの記事&lt;/a&gt;を書いたり、去年のアドベントカレンダーイベントではGatsbyの記事「&lt;a href=&quot;https://qiita.com/uehaj/items/1b7f0a86596353587466&quot;&gt;Reactベース静的サイトジェネレータGatsbyの真の力をお見せします&lt;/a&gt;」を書いたりしております。&lt;/p&gt;
&lt;h1&gt;はじめに&lt;/h1&gt;
&lt;p&gt;Webサイトの要所にあるアニメーションって、効果的に使えばかっこいいですよね。&lt;/p&gt;
&lt;p&gt;でも、アニメーションって作るのは結構難しいです。私もですが、今まで修得を試みたものの挫折した経験がある方もいらっしゃるのではないかと思います。まあ出来合いの画面ライブラリでなんとかなっちゃう時も少なくないわけですが、シュッとした動きが思い通りにつけられたらなあ、とも常々おもっておりました。&lt;/p&gt;
&lt;p&gt;そんな昨今、&lt;a href=&quot;https://www.react-spring.io/&quot;&gt;React-Spring&lt;/a&gt;というモダンなReact用の人気の高いアニメーショライブラリ&lt;sup id=&quot;fnref-2&quot;&gt;&lt;a href=&quot;#fn-2&quot; class=&quot;footnote-ref&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;を見つけて、&lt;strong&gt;&lt;em&gt;Reactであれば! Hooksであれば!&lt;/em&gt;&lt;/strong&gt;理解できそうなので(理解したとは言っていない)、解説記事を書いてみました。
&lt;sup id=&quot;fnref-2&quot;&gt;&lt;a href=&quot;#fn-2&quot; class=&quot;footnote-ref&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;: GitHubスター数15.4k(2019年12月現在)となかなかの人気なのではないかと思います。&lt;/p&gt;
&lt;h2&gt;対象読者&lt;/h2&gt;
&lt;p&gt;React経験者の方。Hooksの経験があるとなおよい。CSS Transitionとかの経験は不要である。&lt;/p&gt;
&lt;h2&gt;この文章の位置付け&lt;/h2&gt;
&lt;p&gt;本文書は&lt;a href=&quot;https://www.react-spring.io/docs/&quot;&gt;react-spring公式ドキュメント&lt;/a&gt;の代替を目指してはいません。ただ、公式ドキュメントはおそらく要点を絞りこみすぎていて、他のアニメーションライブラリやイージングライブラリの使用経験がないと、いきなり読みくだし理解することは難しいと感じました。本書では基本に立ちかえった説明をし、また公式に抜けている「概念の説明」に重点をおいて、導入時に併読することで有用であることを目指しています。&lt;/p&gt;
&lt;p&gt;本文書は筆者が調査したり類推した内容を含んでおり、間違いを含む可能性があります。問題がありましたら、ご連絡いただけますと幸いです。&lt;/p&gt;
&lt;h1&gt;アニメーションとは何か&lt;/h1&gt;
&lt;blockquote&gt;
最初にアニメーションの基本について説明します。不要であれば「&lt;a href=&quot;https://qiita.com/uehaj/items/260f188851045cc091ac#react-spring%E3%81%AE%E7%B4%B9%E4%BB%8B&quot;&gt;react-springの紹介&lt;/a&gt;」まで読み飛ばしてください。
&lt;/blockquote&gt;
&lt;p&gt;「アニメーション」とは、広義には絵を初めとする本来動かないものを動くように見せる映像表現のことです。ブラウザで表示しているページがスクロールしたり、ブラウザウィンドウをドラッグして移動させる、なども大きな意味では立派なアニメーションです。アニメーションGIFだってアニメーションです。&lt;/p&gt;
&lt;p&gt;その部分集合として、react-springが扱う「アニメーション」とは、「DOMで表示されている画面上のオブジェクトの&lt;strong&gt;色や属性などが連続的に変化する&lt;/strong&gt;」というものです。DOMアニメーションとCSSアニメーションの両方を含むものと考えてください。動画やGIFアニメの再生は対象外です。&lt;/p&gt;
&lt;h2&gt;「連続的に変化する」とはどういうことか&lt;/h2&gt;
&lt;p&gt;一般に、CSSやDOMをJavaScriptから更新すると、その設定内容は「瞬時に」「離散的に」変化します。途中経過がないのです。こんな感じです。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;●            →           ◯

     一瞬で変化する
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;厳密には一瞬ではないでしょうが、ブラウザはさまざまな再計算やレンダリングを行い「最終結果」を表示するための処理を一目散に行います。&lt;/p&gt;
&lt;p&gt;これに対してreact-springの意味で「アニメーション」として表示することは、以下のように表示するということです。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;● → ● → ● → ..◯ → ◯ →◯ → ◯

   細かい単位(1/60秒ごとに)で変化する
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;1/60秒ごと(60Hz)というのは一般的なPCやMacでのリフレッシュレート、すなわち画面変化が物理的に視認できる最短の時間間隔です。この間隔でフレームバッファからディスプレイに情報が転送されるので、この単位よりも細かく画面を変化させることはできません。ちなみに、Oculus RiftやHTC ViveなどのVRヘッドマウントディスプレイでは、リフレッシュレートは90Hzであり、どんなディスプレイでも60Hzであるわけではありません。&lt;/p&gt;
&lt;h2&gt;連続的変化を表現するための方法&lt;/h2&gt;
&lt;p&gt;表示する画像をパラパラ漫画のように、たとえば60枚の画像を用意して1秒間に切り替えれば1杪分のアニメーションを表現できます。しかし容量は大きくなるでしょうし、前述のようにリフレッシュレートが異なるケースがあることも考えれば望ましくありません。&lt;/p&gt;
&lt;p&gt;なので、一般にブラウザのUIのアニメーションでは以下のようにします。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;ブラウザ内の表示要素の「動き」の元になるものとして、DOM要素の&lt;strong&gt;&lt;em&gt;位置&lt;/em&gt;&lt;/strong&gt;、&lt;strong&gt;&lt;em&gt;大きさ&lt;/em&gt;&lt;/strong&gt;、&lt;strong&gt;&lt;em&gt;透明度&lt;/em&gt;&lt;/strong&gt;などに使用する&lt;strong&gt;&lt;em&gt;実数値&lt;/em&gt;&lt;/strong&gt;をピックアップします。&lt;/li&gt;
&lt;li&gt;その値を、時刻を引数とする関数値と考えます&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;なんらかの方法でその関数を実装します。たとえば、&lt;br /&gt;&lt;ul&gt;&lt;/p&gt;
&lt;li&gt; 現在の値と最終値を与え、その間を補完する値を返す関数を生成する
&lt;li&gt; その値変化に対応する、JavaScriptの関数を定義する&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;1/60秒間隔で以下の処理を実行する&lt;br /&gt;&lt;ul&gt;&lt;/p&gt;
&lt;li&gt; 上記関数のその時点での値を決定し、&lt;/li&gt;
&lt;li&gt; DOMの属性をその値で更新する &lt;/li&gt;&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;このように関数もしくは計算式で定義すれば、間隔が60Hzであろうが120Hzであろうが一般的に定義できます。あるいはCPUが重くて処理が表示においつかなかった場合でも、更新を間引いて間隔を長くすることでなめらかさは劣るとしても動きとしては正しいアニメーションを表示することができます。&lt;/p&gt;
&lt;p&gt;と、言葉では簡単そうですが、問題はこの関数を定義するのが難しいことです。単純な一次関数では自然な動きになりません。その問題を解決する適切な関数を生成する機能をもっているのがアニメーションライブラリであり、イージングライブラリ&lt;sup id=&quot;fnref-3&quot;&gt;&lt;a href=&quot;#fn-3&quot; class=&quot;footnote-ref&quot;&gt;3&lt;/a&gt;&lt;/sup&gt;です。&lt;/p&gt;
&lt;h1&gt;react-springの紹介&lt;/h1&gt;
&lt;p&gt;ということでここからが本題です。react-springは、DOMアニメーションやCSSアニメーションを行うためのReactライブラリです。以下の特徴をもっています。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;h3&gt;💐宣言的アニメーション&lt;/h3&gt;
* 「最終的にはこうなる」や「この時はこうする」といったルールを設定で指定するだけでアニメーションを表現します。「なにかのメソッドを呼び出したら、ここに位置を移動する」とかはありません。「アニメーションのタイムラインのx杪目を実行中」みたいな概念もありません。Reactが「宣言的UI」であるのと同様に、宣言的にアニメーションを指定します。
&lt;/li&gt;
&lt;li&gt;
&lt;h3&gt;💐物性ベースのタイミング指定&lt;/h3&gt;
* 従来のアニメーションライブラリだと、アニメーションのタイミングや移動速度などは、継続時間とベジエ曲線(イージング関数)で指定するのが普通でした。これに対してreact-springでは***慣性、摩擦力、張力をもった物理的な性質(物性)***でタイミングを指定します。[こちら](https://www.react-spring.io/docs/hooks/api#configs)で各パラメータをいじって試せます。&lt;br/&gt;
どういうことか？&lt;br/&gt;
    * 張力が強いバネなら、シュと戻り、摩擦力が高いと、ジワーっと移動します。慣性が大きいと、ふんぬっ、ぬお〜、と一拍おく感じで物体が動きはじめます。張力が高いと、ビッビッと力強い動きをします。そういう感じに、コンピュータ上の図形の変化でも、物理的なモノがあるかのような動きをさせるのです。
    * 移動時間を2.5杪にするか、1.5杪にするかなどは、天才アニメーターじゃないんだから常人には考えても答えなんかわかりません。バネのようにビョーンなのか、ハチミツのようにニチャーっと動くのか、という風に直感的に指定します。
    * Appleの元UI-Kit開発者、Andy Matuschakは以下のように言っているそうです&lt;br /&gt;
     &lt;blockquote&gt;[継続時間とイージング曲線を引数とするアニメーションAPIは、継続的でなめらからなインタラクティブ性に根本的に反するものである。](https://twitter.com/andy_matuschak/status/566736015188963328)&lt;/bloclquote&gt;
    * easing関数を指定する選択肢も[ある](https://www.react-spring.io/docs/hooks/api#Configs)。
&lt;/li&gt;
&lt;li&gt;
&lt;h3&gt;💐React Hooksベース/TypeScript対応&lt;/h3&gt;
* HooksベースのAPIが使用できます[^4]。当然TypeScirpt対応です。
&lt;/li&gt;
&lt;li&gt;
&lt;h3&gt;💐React Native対応。&lt;/h3&gt;
* Webだけではなく、react-native, react-native-webの開発をサポートします。
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;やってみようReact-Spring&lt;/h1&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&quot;left&quot;&gt;　　　　　　　　　　　　⚠注意!⚠&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;react-springのバージョンは、原稿執筆時の最新stableのv8ではなく、次期版であるv9ベースのものを使用してください。v8には特にTypeScriptの型定義に致命的な問題があります。「yarn add react-spring@next」 でインストールできます。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;react-springのアニメーションプリミティブ一覧&lt;/h2&gt;
&lt;p&gt;react-springのHooksベースAPIの基本的なプリミティブには以下があります。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;(1) useSpring Hooks&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1つのプロパティ設定のもとで、1つもしくは複数のアニメーション値キー(アニメーション的に変化する数値)を束ねるSpringオブジェクトを生成する。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;(2) useSprings Hooks&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;それぞれ固有のプロパティ設定を持つ複数のSpringオブジェクトを生成する。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;(3) useTrail Hooks&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;後続のものが先行するものに追随するような、複数のアニメーション値を定義する(Trail)。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;(4) useTransition Hooks&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;表示コンポーネントを別のコンポーネントに「切り替える」ときのアニメーション効果(Transtiion)を定義する。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;(5) useChain Hooks&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Spring,Trails,Transitionなどによる効果を連鎖的に実行する。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;これらが、react-springにおけるアニメーション表現のための基本的な枠組みになります。それぞれの詳細については後述します。&lt;/p&gt;
&lt;h2&gt;アニメーションのAPIの概観&lt;/h2&gt;
&lt;p&gt;APIの個別の説明に入るまえに、useSpringを例にとって、react-springにおけるHooks APIのおおまかなイメージをまず説明します。
ureSpringはreact-springのプリミティブの中でもっとも基本的なものです。
useSpringのAPIは以下のようなHook関数です。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-TypeScript&quot;&gt;// (A)
useSpring: ({
              ...アニメーション値のキー:目標値, 
              ...アニメーションプリミティブのプロパティ設定,
            }) =&gt; アニメーション値

// (B)
useSpring: (() =&gt; {
              ...アニメーション値のキー:目標値,
              ...アニメーションプリミティブのプロパティ設定,
           }) =&gt;  [アニメーション値, トリガ関数]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;つまり2つのオーバーロードされた関数があって、引数がオブジェクトか関数かによってそれぞれ&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;(A) アニメーション値&lt;/li&gt;
&lt;li&gt;(B) アニメーション値とそのトリガ関数&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;をそれぞれ返します。この二種類は、コントロールの方法が違います。
以降、ここでいくつか出てきている用語を説明します。&lt;/p&gt;
&lt;h3&gt;【用語説明】アニメーション値(AnimatedValue)&lt;/h3&gt;
&lt;p&gt;react-springによるアニメーション処理における最も基本的で重要なプリミティブが特別な「アニメーション値」です。これは時間経過によって変化する値です。「キーとその値」というオブジェクトの形をしていて、useSpringなどのHook関数の返り値として得ることができます。
アニメーション値は以下の特徴を持っています。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;アニメーション値の現在値は、後述の「アニメーション化されたコンポーネント」と、あと&lt;a href=&quot;https://www.react-spring.io/docs/hooks/api#Interpolations&quot;&gt;interporateの計算&lt;/a&gt;でのみ間接的に使用できる(文脈の外に取り出せない。取り出すと意味がない)。&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;useStateが提供するような状態値を保持する。違いとしては&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;useStateが返却するセッター関数で可能であるような「前の値から次の値を設定」などはできない。&lt;/li&gt;
&lt;li&gt;現在値が設定で指定した物理特性と時刻経過によって、requestAnimationFrameのタイミングで自動的に再計算、設定される。その更新を意識する必要がない。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;アニメーション値は文字列や配列であってもよい。変化を計算する以上、本質的には一つ一つのnumberに対応するが、その表現として”18pt”とか単位がついてもいいし、“scale(3.0)“や”translate3d(0px,0,0)“みたいに文字列に埋め込まれていてもいい。“red”,“green”などの色名、rgb/hsvの指定、角度など、DOMの修飾に使用できる&lt;a href=&quot;https://www.react-spring.io/docs/hooks/basics#up-front-interpolation&quot;&gt;多様な値を扱える&lt;/a&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;【用語説明】 アニメーションのトリガ&lt;/h3&gt;
&lt;p&gt;アニメーション値によるアニメーションをトリガし開始するには、主に3つの方法があります。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;(A)の引数の目標値を前回render呼び出し時から変化させる(propsやuseStateによって)。変化させると、その値に向かってアニメーションの変化が再度開始される。&lt;/li&gt;
&lt;li&gt;(B)の呼び出し結果に含まれる「トリガ関数」をイベントハンドラで呼び出し、新しい目標値を設定する。たとえば、&lt;br/&gt;
&lt;code&gt;setAnimValue({key: value});&lt;/code&gt;&lt;br/&gt;
のように、アニメーション値のキーと目標値を選択的に指定できる。&lt;/li&gt;
&lt;li&gt;(A),(B)いずれの場合でも可能な方法として、後述アニメーションプリミティブのfromプロパティを設定する。immidiate: falseでなければ、from値とto目標値に差があれば、マウントされた時点で目標値へのアニメーションのトリガがかかる。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;【用語説明】アニメーション化されたコンポーネント(Animated Component)&lt;/h3&gt;
&lt;p&gt;「アニメーション値」の実体は、react-springライブラリが生成する、&lt;strong&gt;状態をもったオブジェクト&lt;/strong&gt;なのですが、これをそのままコンポーネントのスタイル指定に与えることはできません。仮想DOMが理解する通常の数値や文字列に変換する必要があるのですが、アニメーション値の方を変換することはしません。その代りに、それを受け取って使用する側のコンポーネントの方をwrapperに変換します。何を言ってるかというと、たとえば、&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-TypeScript&quot;&gt;const MyComponent = ({fontSize}) =&gt; (
  &amp;#x3C;div style={{fontSize: fontSize}} &gt;Hello World&amp;#x3C;/div&gt;
);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;こんなコンポーネントのstyle属性としてのfontSizeプロパティにアニメーション値を与えたいなら、&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-TypeScript&quot;&gt;import { useString, animated } from &apos;react-spring&apos;;

const aprops = useSpring({fontSize: &apos;150%&apos;})
const AnimatedMyComponent = animated(MyComponent);  // ★
  ...
&amp;#x3C;AnimatedMyComponent style={{fontSize: aprops.fontSize}} /&gt;
&amp;#x3C;!-- もしくは &amp;#x3C;AnimatedMyComponent style={aprops} /&gt; --&gt;
 --&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上記の★のところで、関数animatedにコンポーネントを渡して変換をかけます。ここで得られる「AnimatedMyComponent」は、プロパティにアニメーション値が来たときに、明示的にrequestAnimationFrameを呼んだりしなくても、そのアニメーション値に従ったアニメーション表示を自律的に行うコンポーネントになります。これを本文書では「アニメーション化されたコンポーネント」と呼びます&lt;sup id=&quot;fnref-1&quot;&gt;&lt;a href=&quot;#fn-1&quot; class=&quot;footnote-ref&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;
&lt;p&gt;div,span,imgなどについては、あらかじめアニメーション化されたコンポーネントが用意されています。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&quot;left&quot;&gt;コンポーネント&lt;/th&gt;
&lt;th align=&quot;left&quot;&gt;意味&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;animated.div&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;アニメーション化されたdivコンポーネント&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;animated.span&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;アニメーション化されたspanコンポーネント&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;animated.img&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;アニメーション化されたimgコンポーネント&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;animated.svg&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;アニメーション化されたsvgコンポーネント&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;animated.h1,h2..&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;アニメーション化されたh1,h2,..コンポーネント&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;【用語説明】&lt;a href=&quot;https://www.react-spring.io/docs/hooks/api#properties&quot;&gt;アニメーションプリミティブのプロパティ設定&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Hooksに与える共通する設定用オブジェクトです。例として、useSpringの第一引数にあたえる場合以下のようになります&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;= useSpring({ここにキー:バリューで指定}) // 前述の(A)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;あるいは&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;= useSpring(() =&gt; {ここにキー:バリューで指定}) // 前述の(B)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;主なキーには以下があります。他すべてについては&lt;a href=&quot;https://www.react-spring.io/docs/hooks/api#properties&quot;&gt;こちら&lt;/a&gt;。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&quot;left&quot;&gt;プロパティ名&lt;/th&gt;
&lt;th align=&quot;left&quot;&gt;型&lt;/th&gt;
&lt;th align=&quot;left&quot;&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;任意&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;num/string&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;キーがアニメーションプロパティ設定のキーに被らなければ、toで指定する目標値として扱われる。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;from&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;obj&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;アニメーション値の初期値。オプション。トリガされる前に使用される値。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;to&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;obj/fn/array(obj)&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;アニメーション値が収束する目標値。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;delay&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;number/fn&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;開始時の遅延(ms)。オプション。引数にkeyをとる関数を与えると、複数のアニメーション値を設定することができる(fnについては以下同様)。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;config&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;obj/fn&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;慣性、摩擦力、張力などの物性を指定。既定義の&lt;a href=&quot;https://www.react-spring.io/docs/hooks/api#Presets&quot;&gt;プリセット物性&lt;/a&gt;もある(config.{default,gentle,wobbly,stiff,slow,molasses})。オプション。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;ref&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;Reactのref&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;後述のuseChainで連鎖的に実行するアニメーションの一環として動作させる。オプション。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h1&gt;API説明&lt;/h1&gt;
&lt;h2&gt;(1) &lt;a href=&quot;https://www.react-spring.io/docs/hooks/use-spring&quot;&gt;useSpring Hook&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;ureSpringはreact-springのプリミティブの中でもっとも基本的なものです。
1つのプロパティ設定のもとで、1つもしくは複数のアニメーション値キー(アニメーション的に変化する数値)を束ねるSpringオブジェクトを生成します。&lt;/p&gt;
&lt;h3&gt;useSpring によるアニメーションの例(SampleA, SampleB)&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/9979/040fa6a5-ce1b-508a-4188-cbe338b1c1ef.gif&quot; alt=&quot;spring.gif&quot;&gt;
(以降含め、デモは&lt;a href=&quot;https://codesandbox.io/s/lively-cookies-6nc3u&quot;&gt;こちらで&lt;/a&gt;試せます。ソースコードは&lt;a href=&quot;https://github.com/uehaj/ReactSpringSamples/&quot;&gt;こちら&lt;/a&gt;です。)&lt;/p&gt;
&lt;p&gt;上記は、1行目がSampleSpringAというコンポーネント、2行目がSampleSpringBというコンポーネントで実装しています。見た目も動作も同じですが、処理がことなります。
SampleSpringAは、前述「&lt;a href=&quot;https://qiita.com/drafts/260f188851045cc091ac/edit#%E3%82%A2%E3%83%8B%E3%83%A1%E3%83%BC%E3%82%B7%E3%83%A7%E3%83%B3%E3%81%AEapi%E3%81%AE%E6%A6%82%E8%A6%B3&quot;&gt;アニメーションのAPIの概観&lt;/a&gt;」における(A)のパターンでuseSpringにアニメーションプリミティブのプロパティを与え、Springを得ています。
SampleSpringBは、同様に(B)のパターンでseSpringにアニメーションプリミティブのプロパティを返す関数を与え、Springとトリガ関数を得ています。&lt;/p&gt;
&lt;h3&gt;useSpringコード例(SampleSpringA.tsx)&lt;/h3&gt;
&lt;p&gt;以下SampleSpringAのソースコードです。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-typescript:SampleSpringA.tsx&quot;&gt;import React, { useState } from &quot;react&quot;;
import { useSpring, animated } from &quot;react-spring&quot;;

const SampleSpringA = () =&gt; {
  // (A)
  const [enter, setEnter] = useState(false);
  const spring = useSpring({
    fontSize: enter ? &quot;48pt&quot; : &quot;24pt&quot;,
    color: enter ? &quot;red&quot; : &quot;green&quot;
  });
  return (
    &amp;#x3C;animated.div
      style={spring}
      onMouseEnter={e =&gt; setEnter(true)}
      onMouseLeave={e =&gt; setEnter(false)}
    &gt;
      Hello React Spring
    &amp;#x3C;/animated.div&gt;
  );
};

export default SampleSpringA;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;enterというstateを間接的にSpringに参照させ、そのstateを変化させることで、目標値が変化します。すなわち、stateの更新と引き続くrenderの呼び出しのタイミングで、アニメーションのトリガがかかり、アニメーションが進行します。&lt;/p&gt;
&lt;h3&gt;useSpringコード例(SampleSpringB.tsx)&lt;/h3&gt;
&lt;p&gt;以下はSampleSpringBのソースコードです。&lt;/p&gt;
&lt;p&gt;こちらではstateを介在させる必要がなく、useSsringに関数をわたすことで、トリガ関数が返ってくるので、トリガ関数を任意のイベントハンドラ等から呼び出すことでアニメーションの進行がはじまります。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-typescript:SampleSpringB.tsx&quot;&gt;import React from &quot;react&quot;;
import { useSpring, animated } from &quot;react-spring&quot;;

const SampleSpringB = () =&gt; {
  // (B)
  const [spring, set] = useSpring(() =&gt; ({
    fontSize: &quot;24pt&quot;,
    color: &quot;green&quot;
  }));
  return (
    &amp;#x3C;animated.div
      style={spring}
      onMouseEnter={e =&gt; set({ fontSize: &quot;48pt&quot;, color: &quot;red&quot; })}
      onMouseLeave={e =&gt; set({ fontSize: &quot;24pt&quot;, color: &quot;green&quot; })}
    &gt;
      Hello React Spring
    &amp;#x3C;/animated.div&gt;
  );
};

export default SampleSpringB;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;(2) &lt;a href=&quot;https://www.react-spring.io/docs/hooks/use-springs&quot;&gt;useSprings Hook&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;それぞれ固有のプロパティ設定を持つ複数のSpringオブジェクト(ここではSpring列と呼ぶ)を生成します。
似たようなアニメーションを行う一連のアニメーション化されたコンポーネントを生成することができます。&lt;/p&gt;
&lt;h3&gt;useSpringsによるアニメーションの例&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/9979/e9ab5ed6-d800-c7f9-acd3-31c2afc2666e.gif&quot; alt=&quot;springs.gif&quot;&gt;&lt;/p&gt;
&lt;h3&gt;useSpringsコード例(SampleSprings.tsx)&lt;/h3&gt;
&lt;p&gt;Spring列のインデックスを引数とするコールバック関数で、個々のSpringで異なる設定をします。
トリガ関数もSpring列のインデックスを引数とする関数で指定します。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-typescript:SampleSprings.tsx&quot;&gt;import React, { useState } from &quot;react&quot;;
import { useSprings, animated, config } from &quot;react-spring&quot;;

const SampleSprings = () =&gt; {
  const msg = &quot;Hello React Spring&quot;;
  const [springs, set] = useSprings(msg.length, (idx) =&gt; ({
    // idxによって異なる設定をしてもよい。
    config: config.wobbly,
    fontSize: &quot;24pt&quot;
  }));
  return (
    &amp;#x3C;div style={{ fontSize: &quot;24pt&quot; }}&gt;
      {springs.map((item, idx) =&gt; (
        &amp;#x3C;animated.span
          onMouseEnter={e =&gt; set(i =&gt; (i === idx ? { fontSize: &quot;48pt&quot; } : {}))}
          onMouseLeave={e =&gt; set(i =&gt; (i === idx ? { fontSize: &quot;24pt&quot; } : {}))}
          style={{ verticalAlign: &quot;top&quot;, ...item }}
        &gt;
          {msg[idx]}
        &amp;#x3C;/animated.span&gt;
      ))}
    &amp;#x3C;/div&gt;
  );
};

export default SampleSprings;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;(3) &lt;a href=&quot;https://www.react-spring.io/docs/hooks/use-trail&quot;&gt;useTrail Hook&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;後続のものが先行するものの変化に追随するような、複数のアニメーション値のリストを定義する(Trail)。
マウストラッキングアニメーションのようなものが簡単に定義できます。&lt;/p&gt;
&lt;h3&gt;useTrailによるアニメーションの例&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/9979/c9d55e89-2034-97a6-21dd-c4308734cab4.gif&quot; alt=&quot;trail.gif&quot;&gt;&lt;/p&gt;
&lt;h3&gt;useTrailコード例(SampleTrail.tsx)&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&quot;language-typescript:SampleTrail.tsx&quot;&gt;import React, { useState } from &quot;react&quot;;
import { useTrail, animated, config } from &quot;react-spring&quot;;

const SampleTrail = () =&gt; {
  const msg = &quot;Hello React Spring&quot;;
  const [{ x, y }, setXY] = useState({ x: 0, y: 0 });
  const trails = useTrail(msg.length, {
    config: config.gentle,
    left: `${x}px`,
    top: `${y}px`,
    position: &quot;absolute&quot;
  });
  return (
    &amp;#x3C;div
      style={{ width: &quot;100%&quot;, height: 1000, fontSize: &quot;24pt&quot; }}
      onMouseMove={e =&gt; {
        e.persist();
        setXY({ x: e.clientX, y: e.clientY });
      }}
    &gt;
      {trails.map((trail, idx) =&gt; (
        &amp;#x3C;animated.span style={{ ...trail, paddingLeft: idx * 23 }}&gt;
          {msg[idx]}
        &amp;#x3C;/animated.span&gt;
      ))}
    &amp;#x3C;/div&gt;
  );
};

export default SampleTrail;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;(4) &lt;a href=&quot;https://www.react-spring.io/docs/hooks/use-transition&quot;&gt;useTransition Hook&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;表示コンポーネントを別のコンポーネントに「切り替える」ときのアニメーション効果を定義する。
以下のようなマウント・アンマウントおよびアニメーションの処理を一手に手際良くやることができます。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;これから表示しようとするコンポーネントをDOMに新たにマウントとする処理&lt;/li&gt;
&lt;li&gt;新しくマウントしたコンポーネントに対するアニメーションの実行&lt;/li&gt;
&lt;li&gt;新しくマウントしたコンポーネントによって、置き換えられてしまうコンポーネントをDOMからアンマウントする処理&lt;/li&gt;
&lt;li&gt;置き換えられてしまうコンポーネントのアンマウント時のアニメーションの実行&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一般に、コンポーネントを「切り替える」操作として、「古い方のアンマウントと、新しい方のマウント」を同時に行うのが自然なのですが、アニメーションとしては、アンマウントされる方が消えていくアニメーションと新しい方が表われてくるアニメーションは、時間的重なりをもって動かないとそれらしくありません。なので、useTransionの返り値はアニメーション進行中のコンポーネントを表わす配列であり、これに基づいて消えていくコンポーネントを並行してアニメーションさせつつ、時間差をもってアンマウントできます。&lt;/p&gt;
&lt;h3&gt;useTransitionによるアニメーションの例&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/9979/8a144326-7fb8-b8b9-07f7-a332add19764.gif&quot; alt=&quot;transition.gif&quot;&gt;&lt;/p&gt;
&lt;h3&gt;useTransitionコード例(SampleTransition.tsx)&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&quot;language-typescript:SampleTransion.tsx&quot;&gt;import React, { useState } from &quot;react&quot;;
import { useTransition, animated, config } from &quot;react-spring&quot;;

const SampleTransition = () =&gt; {
  const [idx, setIdx] = useState(0);

  const comps = [
    ({ style }) =&gt; (
      &amp;#x3C;animated.div
        style={{ position: &quot;absolute&quot;, backgroundColor: &quot;lightblue&quot;, ...style }}
      &gt;
        Hello React Spring 1
      &amp;#x3C;/animated.div&gt;
    ),
    ({ style }) =&gt; (
      &amp;#x3C;animated.div
        style={{
          position: &quot;absolute&quot;,
          backgroundColor: &quot;lightgreen&quot;,
          ...style
        }}
      &gt;
        Hello React Spring 2
      &amp;#x3C;/animated.div&gt;
    ),
    ({ style }) =&gt; (
      &amp;#x3C;animated.div
        style={{ position: &quot;absolute&quot;, backgroundColor: &quot;pink&quot;, ...style }}
      &gt;
        Hello React Spring 3
      &amp;#x3C;/animated.div&gt;
    )
  ];

  const transitions = useTransition(idx, item =&gt; item, { // ★
    unique: true,
    from: { opacity: 0 },
    enter: {
      opacity: 1,
      transform: &quot;translateY(0px) rotate(0turn)&quot;
    },
    leave: {
      opacity: 0,
      transform: &quot;translateY(100px) rotate(0.3turn)&quot;
    }
  });

  return (
    &amp;#x3C;div
      style={{ width: &quot;100%&quot;, height: 1000, fontSize: &quot;24pt&quot; }}
      onClick={e =&gt; {
        e.persist();
        setIdx(x =&gt; (x + 1) % comps.length);
      }}
    &gt;
      {transitions.map(({ item, props, key }) =&gt; { // ★★
        const Comp = comps[item];
        return &amp;#x3C;Comp key={key} style={props} /&gt;;
      })}
    &amp;#x3C;/div&gt;
  );
};

export default SampleTransition;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上記で、compsは切り替えをおこなう候補としてのコンポーネントの一覧です。
★で、切り替える現在のインデックスをuseTrainsionの第一引数に与えていきます。&lt;/p&gt;
&lt;p&gt;useTraisitionの返り値は、このインデックス値に加えて、前回のトランジションアニメーションが終了していないもののインデックス値がかえってきます。これらはアンマウントしてはいけません。
一般には、useTraisitionが返す、「インデックス値をキーに含む配列要素」すべてに対して、インデックス値対応するコンポーネントをmapで無条件にマウントしてやればよいわけです(★★)。&lt;/p&gt;
&lt;h2&gt;(5) &lt;a href=&quot;https://www.react-spring.io/docs/hooks/use-chain&quot;&gt;useChain Hook&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Spring,Trails,Transisionなどによる効果を連鎖的に実行する。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Springなどのアニメーション値を作成する際のアニメーションプリミティブのrefプロパティを指定し、useRefの結果を組込むすることで、useChainがrefを使ってトリガ関数の役割りを果してくれるようになります。逆に言えば、ref属性を組込むとトリガ関数経由ではコントロールできなくなります。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;このせいか、useSpringの(B)「アニメーション値とそのトリガ関数」のパターンのものに対してはuseChainは機能しません。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;useChainによるアニメーションの例&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/9979/4558dd53-12af-3b37-ed10-13f06d5bca51.gif&quot; alt=&quot;chain.gif&quot;&gt;&lt;/p&gt;
&lt;h3&gt;useChainコード例(SampleChain.tsx)&lt;/h3&gt;
&lt;p&gt;refを準備し、制御下におく部品に組み込み、chainで繋げます&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-typescript:SampleChain.tsx&quot;&gt;import React, { useState, useRef } from &quot;react&quot;;
import { useSpring, useChain, animated, config } from &quot;react-spring&quot;;

const SampleSpring = ({ ref }) =&gt; {
  const [enter, setEnter] = useState(false);
  const ref1 = useRef();
  const ref2 = useRef();

  const spring1 = useSpring({
    fontSize: enter ? &quot;48pt&quot; : &quot;18pt&quot;,
    ref: ref1
  });
  const spring2 = useSpring({
    fontSize: enter ? &quot;48pt&quot; : &quot;18pt&quot;,
    ref: ref2
  });
  useChain([ref1, ref2]);
  return (
    &amp;#x3C;div
      style={{ textAlign: &quot;center&quot; }}
      onMouseEnter={e =&gt; setEnter(p =&gt; !p)}
      onMouseLeave={e =&gt; setEnter(p =&gt; !p)}
    &gt;
      &amp;#x3C;animated.div style={spring1}&gt;Hello React Spring&amp;#x3C;/animated.div&gt;
      &amp;#x3C;animated.div style={spring2}&gt;Hello React Spring&amp;#x3C;/animated.div&gt;
    &amp;#x3C;/div&gt;
  );
};

export default SampleSpring;
&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt;これはFRP(Functional Reactive Programming)か?&lt;/h1&gt;
&lt;p&gt;I think so.&lt;/p&gt;
&lt;h1&gt;おわりに&lt;/h1&gt;
&lt;p&gt;ということで、react-springによる最先端Webアニメーション技術のサワリを紹介しました。
今回、紹介したのは、react-springの機能の一部ですが、主要なところはカバーしたつもりです。
本書のデモでは主に、fontSizeという地味な属性を変化させましたが、transform: scale, rotateなどのプロパティを変化させたり、SVGを使用すると複雑で派手なアニメーションを行うことができ、基本は同じです。
公式サイトには他に多数のデモが掲載されていますので参考ください。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.react-spring.io/docs/hooks/examples&quot;&gt;https://www.react-spring.io/docs/hooks/examples&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;もうアニメーションも怖くない! かも!&lt;/p&gt;
&lt;h1&gt;参考リンク&lt;/h1&gt;
&lt;p&gt;本文書のサンプルコードは&lt;a href=&quot;https://github.com/uehaj/ReactSpringSamples/&quot;&gt;こちら&lt;/a&gt;もしくは&lt;a href=&quot;https://codesandbox.io/s/lively-cookies-6nc3u&quot;&gt;こちら&lt;/a&gt;にあります。&lt;/p&gt;
&lt;div class=&quot;footnotes&quot;&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id=&quot;fn-3&quot;&gt;
&lt;p&gt;「&lt;a href=&quot;https://note.com/ritar/n/n5e8ed0e07917&quot;&gt;世界一わかりやすい「イージング」と、その応用&lt;/a&gt;」などが参考になります:  &lt;/p&gt;
&lt;a href=&quot;#fnref-3&quot; class=&quot;footnote-backref&quot;&gt;↩&lt;/a&gt;
&lt;/li&gt;
&lt;li id=&quot;fn-4&quot;&gt;
&lt;p&gt;HoCやRender PropsベースのAPIもあります。&lt;br/&gt;&lt;/p&gt;
&lt;a href=&quot;#fnref-4&quot; class=&quot;footnote-backref&quot;&gt;↩&lt;/a&gt;
&lt;/li&gt;
&lt;li id=&quot;fn-1&quot;&gt;
&lt;p&gt;一般的な呼称ではないかもしれない。&lt;/p&gt;
&lt;a href=&quot;#fnref-1&quot; class=&quot;footnote-backref&quot;&gt;↩&lt;/a&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</content:encoded></item><item><title><![CDATA[スタンドアローンGORMをGroovyスクリプトからシュっと利用する]]></title><description><![CDATA[G* Advent Calendar 2017 20日目の記事です。 GrailsのO/Rマッピングライブラリである「GORM」は、Grailsから切りはなして単体で使用することもできます。これをスタンドアローンGORMと呼びます。 非WebアプリやGrails…]]></description><link>https://ganevru.github.io/gatsby-starter-blog-grommet/blog/3a65b9c7dcbcc800fbf4/</link><guid isPermaLink="false">https://ganevru.github.io/gatsby-starter-blog-grommet/blog/3a65b9c7dcbcc800fbf4/</guid><pubDate>Thu, 20 Feb 2020 15:08:12 GMT</pubDate><content:encoded>&lt;p&gt;G* Advent Calendar 2017 20日目の記事です。&lt;/p&gt;
&lt;p&gt;Grailsの&lt;a href=&quot;http://gorm.grails.org/latest/&quot;&gt;O/Rマッピングライブラリである「GORM」&lt;/a&gt;は、Grailsから切りはなして単体で使用することもできます。これをスタンドアローンGORMと呼びます。&lt;/p&gt;
&lt;p&gt;非WebアプリやGrails以外の他のフレームワークから高機能なORMとして使うことも可能ですし、Grailsでのシステム開発の一部として、バッチやシェルスクリプトやsshでキックしたいとか、シェルアカウントの管理者権限者だけがデータベースにアクセスしたいときには、スタンドアローンGORMが有用なケースがあります。&lt;/p&gt;
&lt;p&gt;というのも、そういうケースでは以下のような選択肢があるにはあるのですが、いずれも固有の課題を抱えているからです。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;http://docs.grails.org/latest/guide/commandLine.html#creatingCustomScripts&quot;&gt;grails scripts&lt;/a&gt;としてGrailsサービスやGrailsドメインクラスを呼び出す処理などを記述し、Grailsのプロジェクトフォルダ(GRAILS_PROJ/scriptsを含む)に格納して、grailsコマンドで起動。
問題は、プロジェクトソースコードを運用環境に展開しておく必要があること。&lt;/li&gt;
&lt;li&gt;DB処理をWeb APIとして公開して、それを叩くクライアントを開発する。
転送速度がネックになったり、ポートを公開することでセキュリティの問題になるかもしれない。&lt;/li&gt;
&lt;li&gt;Service層をGrailsの&lt;a href=&quot;https://grails.org/plugin/remoting&quot;&gt;Remoting Plugin&lt;/a&gt;を使って公開する。
問題は同上。&lt;/li&gt;
&lt;li&gt;SQLを叩く別プログラムを開発する(Groovy SQL, ..)。
この場合の問題は、GrailsのドメインクラスからDDL生成されたデータベースに対して、生SQLを書くのはかったるいだけではなく、ドメインクラスの制約(constraint)の処理を別途しなければならないということ。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;それぞれのケースで示した問題が許容できないとき、スタンドアローンGORMが有用です。&lt;/p&gt;
&lt;p&gt;さて、具体的な使用方法としては、Spring Bootのアプリケーションから呼び出すこともできるでしょう。
本記事では、もっとストレートに素のGroovyスクリプトからGORMを呼び出す例を紹介します。&lt;/p&gt;
&lt;h1&gt;方法&lt;/h1&gt;
&lt;p&gt;たとえば、こんな感じでGroovyスクリプトを書いて、&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-groovy&quot;&gt;@Grab(&apos;org.grails:grails-datastore-gorm-hibernate5:6.1.0.RELEASE&apos;)
@GrabExclude(&apos;javax.transaction:jta&apos;)
@Grab(&apos;com.h2database:h2:1.4.192&apos;)
@Grab(&apos;org.apache.tomcat:tomcat-jdbc:8.5.0&apos;)
@Grab(&apos;org.slf4j:slf4j-log4j12&apos;)
import java.lang.String
import org.grails.orm.hibernate.HibernateDatastore
import grails.gorm.annotation.Entity

@Entity
class Book {
    String title
    static hasMany = [authors: Author]
    String toString() {&quot;$id: $title&quot;}
}

@Entity
class Author {
    String name
    static hasMany = [books: Book]
    static belongsTo = Book
    String toString() {&quot;$id: $name&quot;}
}

def hibernateDatastore = new HibernateDatastore([
        &apos;hibernate.hbm2ddl.auto&apos;: &apos;create-drop&apos;,
        &apos;dataSource.driverClassName&apos;: &apos;org.h2.Driver&apos;,
        &apos;dataSource.url&apos;: &apos;jdbc:h2:mem:devDb;MVCC=TRUE;LOCK_TIMEOUT=10000;DB_CLOSE_ON_EXIT=FALSE&apos;,
        &apos;dataSource.username&apos;: &apos;sa&apos;,
        &apos;dataSource.password&apos;: &apos;&apos;,
    ],
    Author)

Author.withTransaction {
    Author a = new Author(name:&apos;上原 潤二&apos;);
    Book b1 = new Book(title: &apos;プログラミングGROOVY&apos;).addToAuthors(a).save()
    Book b2 = new Book(title: &apos;Grails徹底入門&apos;).addToAuthors(a).save()
    println Book.findByTitleLike(&apos;G%&apos;)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;GroovyおよびJDKがインストールされていれば、以下で実行できます。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&gt; groovy groovyスクリプトファイル名
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;GroovyやJDK以外の何かを事前ダウンロードしたりインストールしたりフォルダ構成を考えたりコンパイルしたりビルドしたりビルドスクリプトを書いたりデプロイしたりパッケージングしたりが一切不要なのが利点です✌。&lt;/p&gt;
&lt;p&gt;なお、上記では@Entityでドメインクラスを定義していますが、データベースがGrailsアプリケーションの一部であるなら、Grailsアプリケーション本体のwar(やjar)に含まれるドメインクラスのクラスファイルのjarをクラスパスに含めれば別に書かなくても利用可能です(多分)。&lt;/p&gt;</content:encoded></item><item><title><![CDATA[第27回 オフラインリアルタイムどう書くの問題「分岐と行き止まり」をRustで解く]]></title><description><![CDATA[オフラインリアルタイムどう書くの過去問題「分岐と行き止まり」を、Rust(rustc 1.0.0-nightly (2fc8b1e7c 2015-03-07) (built 2015-03-07))で解きました。(他の言語での回答はこちら) Rustの感想 Rust…]]></description><link>https://ganevru.github.io/gatsby-starter-blog-grommet/blog/25caa06ce666fc175d99/</link><guid isPermaLink="false">https://ganevru.github.io/gatsby-starter-blog-grommet/blog/25caa06ce666fc175d99/</guid><pubDate>Thu, 20 Feb 2020 15:08:12 GMT</pubDate><content:encoded>&lt;p&gt;&lt;a href=&quot;https://yhpg.doorkeeper.jp/&quot;&gt;オフラインリアルタイムどう書く&lt;/a&gt;の&lt;a href=&quot;http://nabetani.sakura.ne.jp/hena/ord27raswi/&quot;&gt;過去問題「分岐と行き止まり」&lt;/a&gt;を、Rust(rustc 1.0.0-nightly (2fc8b1e7c 2015-03-07) (built 2015-03-07))で解きました。(他の言語での回答は&lt;a href=&quot;http://qiita.com/Nabetani/items/23ebddb44f0234e7fb15&quot;&gt;こちら&lt;/a&gt;)&lt;/p&gt;
&lt;h1&gt;Rustの感想&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;Rustは関数型プログラミングには向いてない、と思ったが、勘違いだった。&lt;strong&gt;やればできる&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;やればできるのだが(後述)、iter(),into_iter()とcollect::&amp;#x3C;&gt;()だらけのこれが関数型と呼べるのか、関数型プログラミングの成立条件には、簡潔さというものは必須条件なのではないか? あるいはiter()とcollect()は慣れると見えなくなるのか。&lt;/li&gt;
&lt;li&gt;ただ、ライブラリの作りとしては関数型プログラミングの道具立はそろえられている。&lt;a href=&quot;http://doc.rust-lang.org/std/iter/trait.IteratorExt.html&quot;&gt;flat_mapしかり、zip, fold, fuse, ..&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;ちなみに、iter(),into_iter()はコレクション(Vec,..)をイテレータに変換、collect()はその逆。&lt;/li&gt;
&lt;li&gt;mapやfilterなどの処理は、イテレータ上で行う(Java8のstreamみたいなもんですね)。&lt;/li&gt;
&lt;li&gt;iter()は繰り返し要素がborrowing(&amp;#x26;, ポインタ参照)でわたってくる。&lt;/li&gt;
&lt;li&gt;into_iterは値渡しで、(Copy traitをderiveしてなければ)ムーブセマンティクス。&lt;/li&gt;
&lt;li&gt;rustcの&lt;strong&gt;エラーメッセージは丁寧ですばらしい&lt;/strong&gt;、賞賛すべきレベル。学習者にとっては、このエラーメッセージが死活的に重要。エラーメッセージがこれほど丁寧でなれば、このレベルのプログラムでも絶対書けなかった(断言)。&lt;/li&gt;
&lt;li&gt;今でもRustは&lt;strong&gt;どんどん変更されている&lt;/strong&gt;。さすがにbreaking changeの頻度は少なくなっていると思うが、この程度のプログラムでも影響のある変更は結構ある。エラーメッセージがわかりやすくなってたりもするので、できるかぎりnightlyを追うべし。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;Rustが関数型プログラミングに向いてないと思った理由と、乗り越えるための対策&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;コレクションライブラリが破壊的操作ベース(sort,dedup) &lt;/li&gt;
&lt;li&gt;(対策) → BTreeSetを使う&lt;/li&gt;
&lt;li&gt;文字列操作も同じく破壊的操作ベース。結合するのにpush_str()とか。破壊的以前に煩雑で死ぬ。&lt;/li&gt;
&lt;li&gt;(対策) → format!()マクロを多用。&lt;/li&gt;
&lt;li&gt;式中の関数返り値はその場だけのテンポラリなライフタイムなので、直接・間接に後でも使う場合、ローカル変数に保存してライフタイムで延長することで回避するしかないかと思った。&lt;/li&gt;
&lt;li&gt;(対策) → into_iter()でムーブセマンティクスにすることで回避。&lt;strong&gt;値渡しがRustの基本&lt;/strong&gt;であると心に刻む。&lt;/li&gt;
&lt;li&gt;(クロージャにmove接頭辞を付ける(move |a| ..)のも関係がありそうだが、どういうときに使うのだろうか謎)&lt;/li&gt;
&lt;li&gt;collectは多相だが、どんな型を返したいのかを示せる型情報が引数やselfでは与えられないため、多相性の解決を代入先の変数の型で指定するしかないのでは。&lt;/li&gt;
&lt;li&gt;(対策)→collect::&amp;#x3C;Vec&amp;#x3C;String&gt;&gt;()みたいに型アノテーションを使用できる。このとき、「collect::&amp;#x3C;Vec&amp;#x3C;_&gt;&gt;()」のように要素の型は指定しなくても推論されるようだ。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;コード&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;/*
http://nabetani.sakura.ne.jp/hena/ord27raswi/
*/
#![feature(collections)]
#![feature(core)]

extern crate core;
use std::string::String;
use std::collections::BTreeSet;
use core::iter::FromIterator;

static PATHS:[(char, char);21]
    = [(&apos;1&apos;,&apos;a&apos;),(&apos;1&apos;,&apos;g&apos;),(&apos;2&apos;,&apos;d&apos;),(&apos;2&apos;,&apos;h&apos;),
       (&apos;3&apos;,&apos;b&apos;),(&apos;3&apos;,&apos;f&apos;),(&apos;a&apos;,&apos;b&apos;),(&apos;b&apos;,&apos;5&apos;),
       (&apos;b&apos;,&apos;c&apos;),(&apos;c&apos;,&apos;4&apos;),(&apos;c&apos;,&apos;6&apos;),(&apos;d&apos;,&apos;c&apos;),
       (&apos;d&apos;,&apos;e&apos;),(&apos;e&apos;,&apos;5&apos;),(&apos;f&apos;,&apos;g&apos;),(&apos;g&apos;,&apos;c&apos;),
       (&apos;g&apos;,&apos;e&apos;),(&apos;g&apos;,&apos;h&apos;),(&apos;h&apos;,&apos;4&apos;),(&apos;h&apos;,&apos;i&apos;),
       (&apos;i&apos;,&apos;6&apos;)];
 
fn traverse(node:char, stopper:&amp;#x26;str) -&gt; Vec&amp;#x3C;String&gt; {
    if stopper.contains(node) {
        vec![]
    }
    else if node == &apos;4&apos; || node == &apos;5&apos; || node == &apos;6&apos; {
        vec![format!(&quot;{}&quot;, node)]
    }
    else {
        PATHS
            .iter()
            .filter(|&amp;#x26;&amp;#x26;(beg,_)|{beg==node})
            .flat_map(|&amp;#x26;(_,end)|traverse(end, stopper).into_iter())
            .collect()
    }
}

fn solve(stopper:&amp;#x26;str) -&gt; Vec&amp;#x3C;String&gt; {
    BTreeSet::from_iter(
        [&apos;1&apos;,&apos;2&apos;,&apos;3&apos;]
            .iter()
            .flat_map(|start_point|
                      traverse(*start_point, stopper)
                      .iter()
                      .map(|end_point| format!(&quot;{}{}&quot;, *start_point, end_point))
                      .collect::&amp;#x3C;Vec&amp;#x3C;String&gt;&gt;()
                      .into_iter()
                      )).into_iter().collect::&amp;#x3C;Vec&amp;#x3C;String&gt;&gt;()
}

fn test(stopper: &amp;#x26;str, expected: &amp;#x26;str) {
    let mut answer = solve(stopper)
        .iter()
        .map(|s| s.as_slice())
        .collect::&amp;#x3C;Vec&amp;#x3C;&amp;#x26;str&gt;&gt;().connect(&quot;,&quot;);
    if answer == &quot;&quot; {
        answer = String::from_str(&quot;-&quot;);
    }
    assert_eq!(answer, expected);
}

fn main() {
/*0*/ test( &quot;befi&quot;, &quot;14,16,24,26&quot; );    
/*1*/ test( &quot;abc&quot;, &quot;14,15,16,24,25,26,34,35,36&quot; );    
/*2*/ test( &quot;de&quot;, &quot;14,15,16,24,26,34,35,36&quot; );    
/*3*/ test( &quot;fghi&quot;, &quot;14,15,16,24,25,26,34,35,36&quot; );    
/*4*/ test( &quot;abcdefghi&quot;, &quot;-&quot; );    
/*5*/ test( &quot;ag&quot;, &quot;24,25,26,34,35,36&quot; );    
/*6*/ test( &quot;dh&quot;, &quot;14,15,16,34,35,36&quot; );    
/*7*/ test( &quot;bf&quot;, &quot;14,15,16,24,25,26&quot; );    
/*8*/ test( &quot;ch&quot;, &quot;15,25,35&quot; );    
/*9*/ test( &quot;be&quot;, &quot;14,16,24,26,34,36&quot; );    
/*10*/ test( &quot;ci&quot;, &quot;14,15,24,25,34,35&quot; );    
/*11*/ test( &quot;cgi&quot;, &quot;15,24,25,35&quot; );    
/*12*/ test( &quot;acgi&quot;, &quot;24,25,35&quot; );    
/*13*/ test( &quot;cdefghi&quot;, &quot;15,35&quot; );    
/*14*/ test( &quot;acdefghi&quot;, &quot;35&quot; );    
/*15*/ test( &quot;cdegi&quot;, &quot;15,24,35&quot; );    
/*16*/ test( &quot;bcdegi&quot;, &quot;24&quot; );    
/*17*/ test( &quot;afh&quot;, &quot;14,15,16,24,25,26,34,35,36&quot; );    
/*18*/ test( &quot;abfh&quot;, &quot;14,15,16,24,25,26&quot; );    
/*19*/ test( &quot;dfh&quot;, &quot;14,15,16,34,35,36&quot; );    
/*20*/ test( &quot;cdfh&quot;, &quot;15,35&quot; );    
/*21*/ test( &quot;deh&quot;, &quot;14,15,16,34,35,36&quot; );    
/*22*/ test( &quot;cdeh&quot;, &quot;15,35&quot; );    
/*23*/ test( &quot;abefgh&quot;, &quot;24,26&quot; );    
/*24*/ test( &quot;abdefgh&quot;, &quot;-&quot; );    
/*25*/ test( &quot;acfghi&quot;, &quot;25,35&quot; );    
/*26*/ test( &quot;acdfghi&quot;, &quot;35&quot; );    
/*27*/ test( &quot;cegi&quot;, &quot;15,24,35&quot; );    
/*28*/ test( &quot;abcfhi&quot;, &quot;15,25&quot; );    
/*29*/ test( &quot;abcefhi&quot;, &quot;-&quot; );    
/*30*/ test( &quot;abdi&quot;, &quot;14,15,16,24,34,35,36&quot; );    
/*31*/ test( &quot;abdfi&quot;, &quot;14,15,16,24&quot; );    
/*32*/ test( &quot;bdi&quot;, &quot;14,15,16,24,34,35,36&quot; );    
/*33*/ test( &quot;bdfi&quot;, &quot;14,15,16,24&quot; );    
/*34*/ test( &quot;adfh&quot;, &quot;14,15,16,34,35,36&quot; );    
/*35*/ test( &quot;adfgh&quot;, &quot;34,35,36&quot; );    
/*36*/ test( &quot;acdfhi&quot;, &quot;15,35&quot; );    
/*37*/ test( &quot;bcdfgi&quot;, &quot;24&quot; );    
/*38*/ test( &quot;bcdfghi&quot;, &quot;-&quot; );    
/*39*/ test( &quot;defi&quot;, &quot;14,15,16,24,34,35,36&quot; );    
/*40*/ test( &quot;defhi&quot;, &quot;14,15,16,34,35,36&quot; );    
/*41*/ test( &quot;cdefg&quot;, &quot;15,24,26,35&quot; );    
/*42*/ test( &quot;cdefgi&quot;, &quot;15,24,35&quot; );    
/*43*/ test( &quot;bdefg&quot;, &quot;24,26&quot; );    
/*44*/ test( &quot;bdefgi&quot;, &quot;24&quot; );    
}
&lt;/code&gt;&lt;/pre&gt;</content:encoded></item><item><title><![CDATA[npmのモジュールバージョン指定におけるチルダ(~)とキャレット(^)の違いについての直感的な理解]]></title><description><![CDATA[package.jsonのdependencies/devDependenciesにおいて、左端が0ではない、z.y.zという3桁のバージョンを指定する場合、以下のとおり。 記法 種別 意味 問題点など ^x.y.z…]]></description><link>https://ganevru.github.io/gatsby-starter-blog-grommet/blog/443580da712d2ccee159/</link><guid isPermaLink="false">https://ganevru.github.io/gatsby-starter-blog-grommet/blog/443580da712d2ccee159/</guid><pubDate>Thu, 20 Feb 2020 15:08:12 GMT</pubDate><content:encoded>&lt;p&gt;package.jsonのdependencies/devDependenciesにおいて、左端が0ではない、z.y.zという3桁のバージョンを指定する場合、以下のとおり。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&quot;left&quot;&gt;記法&lt;/th&gt;
&lt;th align=&quot;left&quot;&gt;種別&lt;/th&gt;
&lt;th align=&quot;left&quot;&gt;意味&lt;/th&gt;
&lt;th align=&quot;left&quot;&gt;問題点など&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;^x.y.z&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;キャレット表記&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;&lt;a href=&quot;http://semver.org/lang/ja/&quot;&gt;セマンティックバージョニング&lt;/a&gt;に従う。つまり、メジャーバージョンxを指定し、マイナーバージョンyの上昇、パッチバージョンzの上昇は互換性があるはずだと信じて、「x.{y以上}.{yが同じならz以上、yが上昇していれば任意} 」にあてはまる最新のものを使う。&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;開発時点と、ソース共有を経ての再ビルド(npm install)時の間で、NPMリポジトリ上の対象パッケージのバージョンが上がっている場合、より新しいものが使われることになる可能性があるが、セマンティックバージョニングの仕様に厳密に従わないパッケージは世の中に結構あるのではまり易い。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;~x.y.z&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;チルダ表記&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;セマンティックバージョニングにおける「マイナーバージョンが上がっても互換性が保たれるはずだ」という建前を信じないが、パッチバージョン上昇だったら互換性があるだろうとは信じて、「x.y.{z以上}」にあてはまるものを使う。&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;キャレット表記に比べて、上記の可能性がパッチバージョンのみなので少ない。とはいえ、はまるときははまるだろう。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;x.y.z&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;固定&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;指定したバージョン「x.y.z」に厳密にあてはまるものを使う。&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;開発時と異なるバージョンが使用される問題は回避できるが、たとえばセキュリテイ問題があってそのバージョンのNPMがリポジトリから削除された場合に(互換性のある後継バージョンがあるのに)ビルド不可能になったり、許容できるバージョン上昇を指定できないなど、セマンティックバージョンのメリットを全く享受できない。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;いずれも問題があるので、^なり~で指定した上で、&lt;a href=&quot;https://docs.npmjs.com/files/package-lock.json&quot;&gt;package-lock.json&lt;/a&gt;なり&lt;a href=&quot;https://yarnpkg.com/lang/en/docs/yarn-lock/&quot;&gt;yarn.lock&lt;/a&gt;を併用するのが正しい(それぞれNPM5、yarnのデフォルト動作)。&lt;/p&gt;
&lt;p&gt;これらのロックファイルを使うのは、セマンティックバージョニングの建前と本音を使いわけることである。つまり、^~をつかって「このバージョンの範囲なら、互換性に問題ないはずだ」という希望と理想をpackage.jsonに記す。それはその上で、「実際にはこのバージョン使ってビルドしましたよ、動作保証するのはこっちなんで、こちらをお使い下さいね、げっひっひ」とlockファイルを裏で提供する。&lt;/p&gt;
&lt;p&gt;左端の桁が0であったり、3桁以外の場合を含めては&lt;a href=&quot;http://qiita.com/sotarok/items/4ebd4cfedab186355867&quot;&gt;こちら&lt;/a&gt;の記事などを参照のこと。&lt;/p&gt;</content:encoded></item><item><title><![CDATA[第14回オフラインリアルタイムどう書くの参考問題をHaskellで解く]]></title><description><![CDATA[第14回 オフラインリアルタイムどう書くの参考問題「眠れるモンスターを狩る」を、Haskellで解きました。Stateモナドを使ってみたけど苦労のわりには…。]]></description><link>https://ganevru.github.io/gatsby-starter-blog-grommet/blog/48cb682cc3441f1066a3/</link><guid isPermaLink="false">https://ganevru.github.io/gatsby-starter-blog-grommet/blog/48cb682cc3441f1066a3/</guid><pubDate>Thu, 20 Feb 2020 15:08:12 GMT</pubDate><content:encoded>&lt;p&gt;&lt;a href=&quot;http://qiita.com/Nabetani/items/0597bd3af481e5834ae1&quot;&gt;第14回 オフラインリアルタイムどう書く&lt;/a&gt;の参考問題「&lt;a href=&quot;http://nabetani.sakura.ne.jp/hena/ord14linedung/&quot;&gt;眠れるモンスターを狩る&lt;/a&gt;」を、Haskellで解きました。Stateモナドを使ってみたけど苦労のわりには…。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-haskell:monster.hs&quot;&gt;-- http://nabetani.sakura.ne.jp/hena/ord14linedung/
import Control.Monad
import Control.Monad.State
    
data Monster = B|D|F|H|J|L deriving (Eq, Show)
data Arm = A|C|E|G|I|K deriving (Eq, Show)

removeOne e xs
    | after == [] = before
    | otherwise = before ++ tail(after)
    where
      before = takeWhile (\t-&gt; t /= e) xs
      after = dropWhile (\t-&gt; t /= e) xs

step (ms, as, n)
    | A `elem` as &amp;#x26;&amp;#x26; B `elem` ms = (True, (removeOne B ms, C:as, n+1))
    | C `elem` as &amp;#x26;&amp;#x26; D `elem` ms = (True, (removeOne D ms, E:as, n+1))
    | E `elem` as &amp;#x26;&amp;#x26; F `elem` ms = (True, (removeOne F ms, G:as, n+1))
    | G `elem` as &amp;#x26;&amp;#x26; H `elem` ms = (True, (removeOne H ms, I:as, n+1))
    | I `elem` as &amp;#x26;&amp;#x26; J `elem` ms = (True, (removeOne J ms, K:as, n+1))
    | K `elem` as &amp;#x26;&amp;#x26; L `elem` ms = (True, (removeOne L ms, A:as, n+1))
    | otherwise = (False, (ms, as, n))

next :: State ([Monster],[Arm],Int) Bool
next = state $ \(ms, as, n) -&gt; step (ms, as, n)

toMonster :: [Monster] -&gt; Char -&gt; [Monster]
toMonster xs ch = case ch of
                    &apos;B&apos; -&gt; B:xs
                    &apos;D&apos; -&gt; D:xs
                    &apos;F&apos; -&gt; F:xs
                    &apos;H&apos; -&gt; H:xs
                    &apos;J&apos; -&gt; J:xs
                    &apos;L&apos; -&gt; L:xs
                    _ -&gt; xs

toArm :: [Arm] -&gt; Char -&gt; [Arm]
toArm xs ch = case ch of
                &apos;a&apos; -&gt; A:xs
                &apos;c&apos; -&gt; C:xs
                &apos;e&apos; -&gt; E:xs
                &apos;g&apos; -&gt; G:xs
                &apos;i&apos; -&gt; I:xs
                &apos;k&apos; -&gt; K:xs
                _ -&gt; xs

toState :: [Char] -&gt; ([Monster], [Arm], Int)
toState str = (foldl (toMonster) [] str, foldl (toArm) [] str, 0)

solve :: State ([Monster], [Arm], Int) ()
solve = do
  result &amp;#x3C;- next
  if (result == False) then return () else solve

solve&apos; :: [Char] -&gt; ([Monster], [Arm], Int)
solve&apos; str = do
  execState solve (toState str)
   
test :: [Char] -&gt; String -&gt; Bool
test str expected = do
  let (_, _, n) = solve&apos; str
  n == read expected

main :: IO ()
main = do
  print $ test &quot;gLDLBgBgHDaD&quot; &quot;6&quot; {-0-}
  print $ test &quot;DBcDLaLgDBH&quot; &quot;6&quot; {-1-}
  print $ test &quot;JJca&quot; &quot;0&quot; {-2-}
  print $ test &quot;FJDLBH&quot; &quot;0&quot; {-3-}
  print $ test &quot;HJBLFDg&quot; &quot;6&quot; {-4-}
  print $ test &quot;HBaDLFJ&quot; &quot;6&quot; {-5-}
  print $ test &quot;DJaHLB&quot; &quot;2&quot; {-6-}
  print $ test &quot;gDLHJF&quot; &quot;3&quot; {-7-}
  print $ test &quot;cJFgLHD&quot; &quot;5&quot; {-8-}
  print $ test &quot;FFBJaJJ&quot; &quot;1&quot; {-9-}
  print $ test &quot;FJeJFBJ&quot; &quot;2&quot; {-10-}
  print $ test &quot;iJFFJJB&quot; &quot;3&quot; {-11-}
  print $ test &quot;JBJiLFJF&quot; &quot;5&quot; {-12-}
  print $ test &quot;JDiFLFBJJ&quot; &quot;8&quot; {-13-}
  print $ test &quot;BDFDFFDFFLLFFJFDBFDFFFFDDFaDBFFB&quot; &quot;28&quot; {-14-}
  print $ test &quot;DDFBFcBDFFFFFFLBFDFFBFLFDFDJDFDF&quot; &quot;24&quot; {-15-}
  print $ test &quot;FDLBFDDBFFFeFFFFFDFBLDDFDDFBFFJF&quot; &quot;16&quot; {-16-}
  print $ test &quot;FDBFFLFDFFDBBDFFBJDLFgDFFFDFFDFF&quot; &quot;0&quot; {-17-}
  print $ test &quot;FDiFLDFFFFBDDJDDBFBFDFFFBFFDFLFF&quot; &quot;31&quot; {-18-}
  print $ test &quot;FDFDJBLBLBFFDDFFFDFFFFFDDFBkFDFF&quot; &quot;30&quot; {-19-}
  print $ test &quot;HBkFFFFHBLH&quot; &quot;3&quot; {-20-}
  print $ test &quot;FBHHFFFHLaB&quot; &quot;2&quot; {-21-}
  print $ test &quot;LFHFBBcHFHF&quot; &quot;0&quot; {-22-}
  print $ test &quot;LFBHFFeFHBH&quot; &quot;7&quot; {-23-}
  print $ test &quot;LgFHHHBFBFF&quot; &quot;3&quot; {-24-}
  print $ test &quot;FFiFHBHLBFH&quot; &quot;0&quot; {-25-}
  print $ test &quot;BFHHFFHBeFLk&quot; &quot;10&quot; {-26-}
  print $ test &quot;FHFaBBHFHLFg&quot; &quot;5&quot; {-27-}
  print $ test &quot;FFgacaFg&quot; &quot;0&quot; {-28-}
  print $ test &quot;JHDaDcBJiiHccBHDBDH&quot; &quot;9&quot; {-29-}
  print $ test &quot;FHJJLckFckFJHDFF&quot; &quot;12&quot; {-30-}
  print $ test &quot;DeDHJHDFHJBLHDLLDHJLBDD&quot; &quot;22&quot; {-31-}
  print $ test &quot;gJLLLJgJgJLJL&quot; &quot;0&quot; {-32-}
  print $ test &quot;DaaaDDD&quot; &quot;0&quot; {-33-}
  print $ test &quot;HFeJFHiBiiBJeJBBFFB&quot; &quot;9&quot; {-34-}
  print $ test &quot;FJFFJDBHBHaLJBHJHDLHkLLLFFFgJgHJLHkJkB&quot; &quot;32&quot; {-35-}
  print $ test &quot;giFLBiBJLLJgHBFJigJJJBLHFLDLL&quot; &quot;23&quot; {-36-}
  print $ test &quot;cgkLJcLJJJJgJc&quot; &quot;2&quot; {-37-}
  print $ test &quot;LDFHJHcFBDBLJBLFLcFJcDFBL&quot; &quot;22&quot; {-38-}
  print $ test &quot;JJHHHkHJkHLJk&quot; &quot;1&quot; {-39-}
  print $ test &quot;kHHBBaBgHagHgaHBBB&quot; &quot;11&quot; {-40-}
  print $ test &quot;HDBFFDHHHDFLDcHHLFDcJD&quot; &quot;20&quot; {-41-}
  print $ test &quot;HFFFHeFFee&quot; &quot;7&quot; {-42-}
  print $ test &quot;gLLDHgDLgFL&quot; &quot;1&quot; {-43-}
  print $ test &quot;JJJBBaBBHBBHaLBHJ&quot; &quot;7&quot; {-44-}
  print $ test &quot;FBFBgJBDBDgF&quot; &quot;0&quot; {-45-}
  print $ test &quot;LLLLakakLakLL&quot; &quot;7&quot; {-46-}
  print $ test &quot;HeJHeJe&quot; &quot;0&quot; {-47-}
  print $ test &quot;LDFLBLLeBLDBBFFBLFBB&quot; &quot;4&quot; {-48-}
&lt;/code&gt;&lt;/pre&gt;</content:encoded></item><item><title><![CDATA[WebAssemblyへのコンパイラ言語を簡単に実装]]></title><description><![CDATA[後入りですみませんが、WebAssemblyアドベントカレンダー未投稿のところ埋めさせて頂きます。 本記事では、WebAssemblyをターゲットとするコンパイラ処理系を実装します。 方針 WebAssembly…]]></description><link>https://ganevru.github.io/gatsby-starter-blog-grommet/blog/5276bd3425d1000e48ba/</link><guid isPermaLink="false">https://ganevru.github.io/gatsby-starter-blog-grommet/blog/5276bd3425d1000e48ba/</guid><pubDate>Thu, 20 Feb 2020 15:08:12 GMT</pubDate><content:encoded>&lt;p&gt;後入りですみませんが、WebAssemblyアドベントカレンダー未投稿のところ埋めさせて頂きます。&lt;/p&gt;
&lt;p&gt;本記事では、WebAssemblyをターゲットとするコンパイラ処理系を実装します。&lt;/p&gt;
&lt;h1&gt;方針&lt;/h1&gt;
&lt;p&gt;WebAssemblyへのコンパイル言語処理系を&lt;strong&gt;&lt;em&gt;最も簡単に&lt;/em&gt;&lt;/strong&gt; &lt;sup id=&quot;fnref-1&quot;&gt;&lt;a href=&quot;#fn-1&quot; class=&quot;footnote-ref&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;実装するための方針は以下のとおり。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;言語は「&lt;a href=&quot;https://ja.wikipedia.org/wiki/Brainfuck&quot;&gt;コンパイラがなるべく小さくなる言語として考案&lt;/a&gt;」されたBrainf*ckを採用&lt;/li&gt;
&lt;li&gt;文法は&lt;a href=&quot;https://ja.wikipedia.org/wiki/Parsing_Expression_Grammar&quot;&gt;PEG(Parsing Expression Grammar)&lt;/a&gt;で記述し、生成系&lt;a href=&quot;https://pegjs.org/&quot;&gt;PEG.js&lt;/a&gt;でパーサを実行時に生成する&lt;/li&gt;
&lt;li&gt;WebAssemblyコード生成では文字列でWAST形式を生成し、&lt;a href=&quot;https://github.com/ewasm/wast2wasm&quot;&gt;wast2wasm&lt;/a&gt;&lt;sup id=&quot;fnref-3&quot;&gt;&lt;a href=&quot;#fn-3&quot; class=&quot;footnote-ref&quot;&gt;3&lt;/a&gt;&lt;/sup&gt;で変換する(直接WASMを生成しない)。またEmscriptenやbinaryenは使用しない&lt;/li&gt;
&lt;li&gt;WASTの表現ではflat形式ではなくs-expression形式を使用する&lt;/li&gt;
&lt;li&gt;ブラウザ上ではなくNode上で実行する。なのでWebAssemblyを実行できるバージョンのNode.jsが必要。Node8以降では普通に実行できる&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;コードは&lt;a href=&quot;https://github.com/uehaj/bf-compiler-webassembly&quot;&gt;こちら&lt;/a&gt;に。
NPMに登録されているので以下で実行できます。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;% cat hello.bf
+++++++++[&gt;++++++++&gt;+++++++++++&gt;+++++&amp;#x3C;&amp;#x3C;&amp;#x3C;-]&gt;.&gt;++.+++++++..+++.&gt;-.------------.&amp;#x3C;++++++++.--------.+++.------.--------.&gt;+.

% npx bf-compiler-webassembly hello.bf
npx: 5個のパッケージを1.592秒でインストールしました。
Hello, world!

% npx bf-compiler-webassembly -e &apos;+++++++++[&gt;++++++++&gt;+++++++++++&gt;+++++&amp;#x3C;&amp;#x3C;&amp;#x3C;-]&gt;.&gt;++.+++++++..+++.&gt;-.------------.&amp;#x3C;++++++++.--------.+++.------.--------.&gt;+.&apos;
npx: 5個のパッケージを2.06秒でインストールしました。
Hello, world!

% npx bf-compiler-webassembly --help
npx: 5個のパッケージを1.506秒でインストールしました。

  Usage: bf-compiler-webassembly [options] [file...]


  Options:

    -V, --version         output the version number
    -e,--script [script]  run script from command line
    -v,--verbose          verbose output
    -h, --help            output usage information


  Examples:

    $ npx bf-compiler-webassembly -e &quot;+++&quot;
    $ npx bf-compiler-webassembly hello.bf
&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt;実行例&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;https://qiita-image-store.s3.amazonaws.com/0/9979/d79db6b1-f1ba-f816-b6ea-7f5481a650b3.gif&quot; alt=&quot;bf2.mov.gif&quot;&gt;&lt;/p&gt;
&lt;p&gt;以降、コードの説明をしていきます。&lt;/p&gt;
&lt;h1&gt;全体の流れ&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&quot;language-js:driver.js&quot;&gt;// compile from string
async function compileAndRunString(bfSource, opts) {
  const bfAst = bfParser.parse(bfSource, opts);
  const wast = bfCompiler.compile(bfAst, opts);
  const wasm = await wast2wasm.convert(wast, opts);
  return await wasmRuner.run(wasm, opts);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/uehaj/bf-compiler-webassembly/blob/master/lib/driver.js&quot;&gt;driver.js&lt;/a&gt;でコンパイル・実行の全体の流れを制御しています。以下の順で処理が実行されます。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Brainf*ckコードの構文解析(パース)、ASTの生成。(&lt;a href=&quot;https://github.com/uehaj/bf-compiler-webassembly/blob/master/lib/bfParser.js&quot;&gt;bfParser.parse()&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;ASTをwastに変換する(コード生成)。(&lt;a href=&quot;https://github.com/uehaj/bf-compiler-webassembly/blob/master/lib/bfCompiler.js&quot;&gt;bfCompiler.compile()&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;wast形式をwasmに変換し、WASMのバイト列表現に変換。(&lt;a href=&quot;https://github.com/uehaj/bf-compiler-webassembly/blob/master/lib/wast2wasm.js&quot;&gt;wast2wasm.convert()&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;WASMバイト列をWebAssemblyの内部形式(機械語?)に変換・コンパイルし、wasmコードを呼び出して実行する。(&lt;a href=&quot;https://github.com/uehaj/bf-compiler-webassembly/blob/master/lib/wasmRunner.js&quot;&gt;wasmRunner.run()&lt;/a&gt;)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;それぞれ以下のように処理ごとにモジュール化しています。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-js:driver.js&quot;&gt;const bfParser = require(&apos;./bfParser&apos;);
const bfCompiler = require(&apos;./bfCompiler&apos;);
const wast2wasm = require(&apos;./wast2wasm&apos;);
const wasmRuner = require(&apos;./wasmRunner&apos;);
&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt;パーサ&lt;/h1&gt;
&lt;p&gt;rainf*ckを構文解析してASTを生成するパーサをPEG.jsで作成します。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-js:bfParser.js&quot;&gt;const peg = require(&apos;pegjs&apos;);

const syntax = `
code = (normal_insn / block_insn / otherchar) *

normal_insn = ch:[&gt;&amp;#x3C;+-.,] { return ch }
block_insn = &apos;[&apos; brk:block &apos;]&apos; { return brk  }

block = cod:code {
  return cod;
}

otherchar = [^&gt;&amp;#x3C;+-.,\\[\\]] {
  return undefined
}
`;

const parser = peg.generate(syntax);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;syntaxという文字列変数にPEG文法を与えてpeg.generate()でパーサを生成しています。
PEGでBNFのように構文を表現します。PEGでは構文解析と字句解析を分ける必要がありません。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-js:bfParser.js&quot;&gt;function parse(bfSource, opts) {
  const bfAst = parser.parse(bfSource);
  return bfAst;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;生成したパーサにBrainf*ckのコードを与えて抽象構文木を返します。
PEGのJS実装であるPEG.jsが生成するパーサは、JSONで抽象構文木を返してくれます。
抽象構文木(という程のものでもありませんが)では、[と]で表現されるブロックは配列、それ以外はその文字の配列が返ります。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-brainfuck&quot;&gt;,[-&gt;+&amp;#x3C;]&gt;+.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;であれば、以下のようなJSONが返ります。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-json&quot;&gt;[ &apos;,&apos;, [ &apos;-&apos;, &apos;&gt;&apos;, &apos;+&apos;, &apos;&amp;#x3C;&apos; ], &apos;&gt;&apos;, &apos;+&apos;, &apos;.&apos; ]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;[と]の対応は静的にコンパイル時チェックされることになります。&lt;/p&gt;
&lt;h1&gt;コード生成&lt;/h1&gt;
&lt;p&gt;抽象構文木を再帰的に辿って&lt;a href=&quot;https://ukyo.github.io/wasm-usui-book/webroot/text-format.html&quot;&gt;WAST形式テキスト&lt;/a&gt;を生成します。
先のBFコードは以下を生成します。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-lisp&quot;&gt;(module
  (func $getchar (import &quot;imports&quot; &quot;getchar&quot;) (result i32))
  (func $putchar (import &quot;imports&quot; &quot;putchar&quot;) (param i32))
  (memory $0 (export &quot;memory&quot;) 1 1)

  (func (export &quot;main&quot;) (local $ptr i32)
    (i32.store8 (get_local $ptr) (call $getchar)) ;; ,
    (block ;; [
      (loop
        (br_if 1 (i32.eqz (i32.load8_s (get_local $ptr))))
        (i32.store8 (get_local $ptr) (i32.sub (i32.load8_s (get_local $ptr)) (i32.const 1))) ;; -
        (set_local $ptr (i32.add (get_local $ptr) (i32.const 1))) ;; &gt;
        (i32.store8 (get_local $ptr) (i32.add (i32.load8_s (get_local $ptr)) (i32.const 1))) ;; +
        (set_local $ptr (i32.sub (get_local $ptr) (i32.const 1))) ;; &amp;#x3C;
        (br 0)
      )
    ) ;; ]
    (set_local $ptr (i32.add (get_local $ptr) (i32.const 1))) ;; &gt;
    (i32.store8 (get_local $ptr) (i32.add (i32.load8_s (get_local $ptr)) (i32.const 1))) ;; +
    (i32.load8_s (get_local $ptr)) (call $putchar) ;; .
  )
)
&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt;生成コードの説明&lt;/h1&gt;
&lt;h2&gt;冒頭のいくつかの宣言&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;  (func $getchar (import &quot;imports&quot; &quot;getchar&quot;) (result i32))
  (func $putchar (import &quot;imports&quot; &quot;putchar&quot;) (param i32))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;BFでの入出力を行うためのgetchar、putcharを外部JS関数として供給します。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  (memory $0 (export &quot;memory&quot;) 1 1)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;memoryでWebAssemby側でメモリ領域を&lt;a href=&quot;https://github.com/sunfishcode/wasm-reference-manual/blob/master/WebAssembly.md#linear-memories&quot;&gt;リニアメモリ&lt;/a&gt;として確保。サイズと最大サイズをブロックサイズで指定。ここではいずれも1ブロック(64 KiB)を指定。&lt;/p&gt;
&lt;h2&gt;コード本体の定義&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;  (func (export &quot;main&quot;) (local $ptr i32)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;JSから呼べる関数としてWebAssembly関数をmainという名前でexport。&lt;/p&gt;
&lt;p&gt;以降、関数本体となる実行命令の説明をしていきます。&lt;/p&gt;
&lt;h2&gt;’[‘と’]‘に対応するコード&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;    (block ;; [
      (loop
        (br_if 1 (i32.eqz (i32.load8_s (get_local $ptr))))
:
        (br 0)
      )
    ) ;; ]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;whileループに相当する[〜]のブロックがコンパイルされたコード。ptrの内容がゼロならループを抜け&lt;code&gt;(br_if 1)&lt;/code&gt;、loop末尾でloopの先頭にジャンプ&lt;code&gt;(br 0)&lt;/code&gt;しています。brはbranchの略で、分岐もしくは条件付き分岐命令です。
wast2wasmではなぜかbrの飛び先をラベルで指定できなかったので、ネストレベルの相対指定&lt;sup id=&quot;fnref-2&quot;&gt;&lt;a href=&quot;#fn-2&quot; class=&quot;footnote-ref&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;で飛び先を指定しています。「0」は最内周のloopもしくはblock、「1」は1段外側のレベルのloopもしくはblockを意味します。ラベルを管理する必要がないので、ここでは好都合です。&lt;/p&gt;
&lt;p&gt;brやbr_ifのジャンプの動作は、指定したネストレベルに対応するものがloopであればloop冒頭にジャンプ(ここではwhileループ内でのcontinue文の動作)、blockであればblockの末尾にジャンプ(ここではwhileループのbreak)をします。&lt;/p&gt;
&lt;h2&gt;’+‘と’-‘に対応するコード&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;(i32.store8 (get_local $ptr) (i32.add (i32.load8_s (get_local $ptr)) (i32.const 1))) ;; +
(i32.store8 (get_local $ptr) (i32.sub (i32.load8_s (get_local $ptr)) (i32.const 1))) ;; -
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;$ptrで間接参照したリニアメモリの指す先の内容を1バイトloadして加減算してリニアメモリにstoreし戻します。i32.load8は拡幅になるので符号付きと無しがあり、この場合は符号付きで処理するように注意します。&lt;/p&gt;
&lt;h2&gt;’&gt;‘と’&amp;#x3C;‘に対応するコード&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;(set_local $ptr (i32.add (get_local $ptr) (i32.const 1))) ;; &gt;
(set_local $ptr (i32.sub (get_local $ptr) (i32.const 1))) ;; &amp;#x3C;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;$ptrを増減させます。&lt;/p&gt;
&lt;h2&gt;’.‘と’,‘に対応するコード&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;(i32.load8_s (get_local $ptr)) (call $putchar) ;; .
(i32.store8 (get_local $ptr) (call $getchar)) ;; ,
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;importsで宣言されているJS関数を指定して呼び出します。ここで用意したのはいずれも同期的な関数です。非同期関数を呼ぶ際にはコールバック関数を指定する必要がありますが、ここでは簡単さを優先するために同期関数で以下のように実装しておいたものを呼び出しています。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-js:wasmRunner.js&quot;&gt;const readlineSync = require(&apos;readline-sync&apos;);
 :
function putchar(ch) {
  process.stdout.write(String.fromCharCode(ch));
}

let buf = &apos;&apos;;
function getchar() {
  if (buf === &apos;&apos;) {
    buf = buf + readlineSync.question() + &apos;\n&apos;;
  }
  const result = buf.charCodeAt(0);
  buf = buf.substring(1);
  return result;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt;WAST→WASM変換&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&quot;language-wast2wasm.js&quot;&gt;const wast2wasm = require(&apos;wast2wasm&apos;);

async function convert(wasmTextCode, opts) {
  const wasm = await wast2wasm(wasmTextCode, true);
  if (opts.verbose || process.env.NODE_ENV === &apos;debug&apos;) {
    console.log(wasm.log);
  }
  return wasm.buffer;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;wastをwasmのバイト列表現に変換します。&lt;/p&gt;
&lt;h1&gt;実行&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&quot;language-js:wastRunner.js&quot;&gt;async function run(uint8array, opts) {
  const wasm = await WebAssembly.instantiate(uint8array, {
    imports: {
      getchar,
      putchar,
    },
  });

  const result = wasm.instance.exports.main();
  if (opts.verbose || process.env.NODE_ENV === &apos;debug&apos;) {
    const memory = new Uint8Array(wasm.instance.exports.memory.buffer);
    console.log(memory);
  }
  return result;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;受け取ったwasmのバイト列表現をWebAssembly.instantiate()で実際のコンパイルを行い、WebAssemblyインスタンスを生成します。通常のWebAssembly実行であれば、wasm生成までは事前コンパイルでできていて、wasmのロードから始まるところ。
そして、exportされた関数(ここではmainで固定)を実行します。&lt;/p&gt;
&lt;h1&gt;コマンドラインの処理&lt;/h1&gt;
&lt;p&gt;&lt;a href=&quot;https://www.npmjs.com/package/commander&quot;&gt;commander&lt;/a&gt;を使用して簡潔に。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-js:index.js&quot;&gt;const program = require(&apos;commander&apos;);
const driver = require(&apos;../lib/driver&apos;);

function main(argv) {
  program
    .version(&apos;0.1.0&apos;)
    .option(&apos;-e,--script [script]&apos;, &apos;run script from command line&apos;)
    .option(&apos;-v,--verbose&apos;, &apos;verbose output&apos;)
    .arguments(&apos;[file...]&apos;, &apos;Brainf*ck file&apos;)
    .action(function(files, opts) {
      for (const file of files) {
        driver
          .compileAndRunFile(file, { verbose: opts.verbose })
          .catch(e =&gt; console.log(&apos;error:&apos; + e));
      }
    })
    .on(&apos;--help&apos;, function() {
      console.log(`
      
  Examples:

    $ npx bf-compiler-webassembly -e &quot;+++&quot;
    $ npx bf-compiler-webassembly hello.bf

`);
    })
    .parse(argv);

  // for -e,--script option
  if (program.script) {
    driver
      .compileAndRunString(program.script, { verbose: program.verbose })
      .catch(e =&gt; console.log(&apos;error:&apos; + e));
  } else {
    program.args.length !== 0 || program.help();
  }
}

main(process.argv);
&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt;WASM所感&lt;/h1&gt;
&lt;p&gt;スタックマシンで変数も使え命令の対称性も高くわかりやすい。JVMのようにクラスベースではなく関数ベースであることが様々な効果を発揮しすっきりしている。
呼び出しスタックを(引数やローカル変数を通じないで)直接見ることも書くこともできないのでスタック上をバッファオーバーフローで書き壊したり、リターンアドレス書き換えてコード呼び出される攻撃について安全。ヒープは別問題だが、間接参照呼び出しはtableという構造のインデックスのみで実現されるので列挙される関数の範囲に限定されるので比較的安全。引数や返り値の型や個数を指定する必要があり、軽くバイトコードベリファイがなされスタックズレなどは防止される。&lt;/p&gt;
&lt;h1&gt;WAST形式所感&lt;/h1&gt;
&lt;p&gt;WAST形式のS-expressionはLispっぽいですが、バイナリフォーマットとしてのWASMでの実際のバイト配置としてはFORTHのような逆ポーランド記法であり、これに対応するflat形式という記法もあるそうです(併用もできる?)。引数の評価順が決まっているのでS-Expressionとflat形式は1対1対応です。&lt;/p&gt;
&lt;h1&gt;最適化&lt;/h1&gt;
&lt;p&gt;していませんが、本来なら種々の最適化を実行することができるでしょう。たとえば複数連続する+や-、&gt;や&amp;#x3C;をまとめて計算するなどは効果的だろうし、BFの個々の命令をテーブルジャンプとか間接参照にすることも考えられます。&lt;/p&gt;
&lt;h1&gt;まとめ&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;WebAssemblyはコンパイラの勉強のターゲットとしてモチベーションが高まるし、しきいも低いのでぜひどうぞ。&lt;/li&gt;
&lt;li&gt;ただし現時点ではドキュメント不足、今後仕様が変化していくだろう、という予測もできます。&lt;/li&gt;
&lt;li&gt;PEG.jsは便利。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;footnotes&quot;&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id=&quot;fn-1&quot;&gt;
&lt;p&gt;主観です。&lt;/p&gt;
&lt;a href=&quot;#fnref-1&quot; class=&quot;footnote-backref&quot;&gt;↩&lt;/a&gt;
&lt;/li&gt;
&lt;li id=&quot;fn-3&quot;&gt;
&lt;p&gt;wast2wabtはたぶん&lt;a href=&quot;https://github.com/WebAssembly/wabt&quot;&gt;WABT(The WebAssembly Binary Toolkit)&lt;/a&gt;からEmscriptenか何かでJSに変換されている。&lt;/p&gt;
&lt;a href=&quot;#fnref-3&quot; class=&quot;footnote-backref&quot;&gt;↩&lt;/a&gt;
&lt;/li&gt;
&lt;li id=&quot;fn-2&quot;&gt;
&lt;p&gt;ネストレベルの外側向きの相対指定であることがドキュメント上読み取れず、ものすごく苦労した。&lt;/p&gt;
&lt;a href=&quot;#fnref-2&quot; class=&quot;footnote-backref&quot;&gt;↩&lt;/a&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</content:encoded></item><item><title><![CDATA[第19回 オフラインリアルタイムどう書くの問題「不良セクタの隣」を、Haskellで解く]]></title><description><![CDATA[第19回 オフラインリアルタイムどう書くの問題「不良セクタの隣」を、Haskellで解きました。]]></description><link>https://ganevru.github.io/gatsby-starter-blog-grommet/blog/53460a9772f2bfbaa3c1/</link><guid isPermaLink="false">https://ganevru.github.io/gatsby-starter-blog-grommet/blog/53460a9772f2bfbaa3c1/</guid><pubDate>Thu, 20 Feb 2020 15:08:12 GMT</pubDate><content:encoded>&lt;p&gt;&lt;a href=&quot;http://qiita.com/Nabetani/items/9810b301648099028bf0&quot;&gt;第19回 オフラインリアルタイムどう書くの問題「不良セクタの隣」&lt;/a&gt;を、Haskellで解きました。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-haskell:sectors.hs&quot;&gt;import Data.Ratio
import Data.List

hasIntersect :: (Ratio Int, Ratio Int, Int) -&gt; (Ratio Int, Ratio Int, Int) -&gt; Bool
hasIntersect (fst_a,snd_a,_) (fst_b,snd_b,_) = (fst_a&amp;#x3C;=snd_b &amp;#x26;&amp;#x26; fst_b &amp;#x3C;=snd_a) || (fst_b &amp;#x3C;=snd_a &amp;#x26;&amp;#x26; snd_a&amp;#x3C;=snd_b)

ranges n = take (8*n+2) $ [(low,up,n*100+(m `mod` (8*n))) | m&amp;#x3C;-[-1..], let w=(1%(8*n)), let low=(-w/2+(w*(m%1))), let up=low+w]

inRange n m = filter $ hasIntersect (ranges n !! (m+1))

neighbor&apos; n m = (ranges n !! (m+1-1)) : (ranges n !! (m+1+1)) : neighbor&apos;&apos; n m
 where
   neighbor&apos;&apos; n m
     | n &amp;#x3C;= 1 = nub $ (inRange n m (ranges $ n+1))
     | n == 4 = nub $ (inRange n m (ranges $ n-1))
     | otherwise = nub ((inRange n m (ranges $ n-1)) ++
                        (inRange n m (ranges $ n+1)))

neighbor n = neighbor&apos; (n `div` 100) (n `mod` 100)

reserved xs = map (!!0) $ filter (\ x -&gt; length x &gt; 1) $ group $ sort $ filter (\x-&gt;not (x `elem` xs)) $ map (\(_,_,n)-&gt;n) $ concatMap neighbor xs

test :: [Int] -&gt; [Int] -&gt; IO()
test s1 s2 = do
   putStrLn $ show $ reserved s1 == s2

main = do
   test [400,401,302] [300,301,402] {- 0 -}
   test [105,100,306,414] [] {- 1 -}
   test [100] [] {- 2 -}
   test [211] [] {- 3 -}
   test [317] [] {- 4 -}
   test [414] [] {- 5 -}
   test [100,106] [107] {- 6 -}
   test [205,203] [102,204] {- 7 -}
   test [303,305] [304] {- 8 -}
   test [407,409] [306,408] {- 9  -}
   test [104,103] [207] {- 10  -}
   test [204,203] [102,305]     {- 11  -}
   test [313,314] [209,418]     {- 12  -}
   test [419,418] [314]     {- 13  -}
   test [100,102,101] [201,203]     {- 14  -}
   test [103,206,309] [205,207,308,310]     {- 15  -}
   test [414,310,309] [206,311,413]     {- 16  -}
   test [104,102,206,307,102,202] [101,103,203,204,205,207,308]     {- 17  -}
   test [104,206,308,409,407] [103,205,207,306,307,309,408,410]     {- 18  -}
   test [313,406,213,301,409,422,412,102,428] []     {- 19  -}
   test [101,300,210,308,423,321,403,408,415] []     {- 20  -}
   test [304,316,307,207,427,402,107,431,412,418,424] []     {- 21  -}
   test [205,408,210,215,425,302,311,400,428,412] []     {- 22  -}
   test [200,311,306,412,403,318,427,105,420] []     {- 23  -}
   test [105,305,407,408,309,208,427] [104,209,306,406]     {- 24  -}
   test [311,304,322,404,429,305,316] [203,303,321,405,406,430]     {- 25  -}
   test [210,401,316,425,101] [211,315]     {- 26  -}
   test [414,403,404,416,428,421] [303,415]     {- 27  -}
   test [207,300,103,211,428] [104,206]     {- 28  -}
   test [322,314,310] []     {- 29  -}
   test [427,200,215] [100,323]     {- 30  -}
   test [311,402,424,307,318,430,323,305,201] [200,204,301,302,306,322,423,425,431]     {- 31  -}
   test [425,430,408] []     {- 32  -}
   test [202,320,209,426] [319,427]     {- 33  -}
   test [430,209,302,310,304,431,320] [202,303,323]     {- 34  -}
   test [208,206,406,424,213,312] [207,311,313]     {- 35  -}
   test [420,302,313,413,317,402] [301,403]     {- 36  -}
   test [319,306,309,418,204,411] [305,307,308,412]     {- 37  -}
   test [400,308,105,430,203,428,209] [104,210,429,431]     {- 38  -}
   test [200,305,214] [215]     {- 39  -}
   test [214,408,410,407,317,422] [306,316,409,423] {- 40  -}
&lt;/code&gt;&lt;/pre&gt;</content:encoded></item><item><title><![CDATA[Grails3で、Grails2と同様に設定ファイルを外部化する]]></title><description><![CDATA[Grails 2ではGrails自身が実装していた設定ファイルの外部化は、Grails 3ではSpring Bootにまかされることになりました。 本記事では、Grails 2までの設定ファイル外部化となるべく似たような動作をするようにGrails…]]></description><link>https://ganevru.github.io/gatsby-starter-blog-grommet/blog/5cd1e9a1ea3d451e784e/</link><guid isPermaLink="false">https://ganevru.github.io/gatsby-starter-blog-grommet/blog/5cd1e9a1ea3d451e784e/</guid><pubDate>Thu, 20 Feb 2020 15:08:12 GMT</pubDate><content:encoded>&lt;p&gt;Grails 2ではGrails自身が実装していた設定ファイルの外部化は、Grails 3ではSpring Bootにまかされることになりました。&lt;/p&gt;
&lt;p&gt;本記事では、Grails 2までの設定ファイル外部化となるべく似たような動作をするようにGrails 3設定してみます。&lt;/p&gt;
&lt;p&gt;やることは、Applicationクラス(grails-app/init/hoge/Application.groovy)に以下のようにアノテーションを付与することだけです。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-groovy&quot;&gt;import org.springframework.context.annotation.*

@PropertySources([
  @PropertySource(value=&quot;classpath:hoge.properties&quot;),
  @PropertySource(value=&quot;file:///opt/hoge/conf/hoge.properties&quot;, ignoreResourceNotFound = true),
  @PropertySource(value=&apos;file:///${hoge.conf.file}&apos;, ignoreResourceNotFound = true)
])
class Application extends GrailsAutoConfiguration {
    static void main(String[] args) {
  :
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上記によって以下のように動作します。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;(1) warファイルやクラスパス中のhoge.properties(ソースコードとしてはsrc/main/resouces/hoge.propertiesに置く)を読み込む。このファイル中には設定のデフォルト値を記入しておく。&lt;/li&gt;
&lt;li&gt;(2) もしファイル「file:///opt/hoge/conf/hoge.properties」があれば設定ファイルとしてそれを読み込む。(1)で設定されたプロパティで同名のものは上書きされる。なければ何もしない。&lt;/li&gt;
&lt;li&gt;(3) もし、システムプロパティ「hoge.conf.file」もしくは環境変数「HOGE&lt;em&gt;CONF&lt;/em&gt;FILE」で指定されたファイル名のファイルががあればそれを読み込む。(1)(2)で設定されたプロパティで同名のものは上書きされる。なければ何もしない。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;run-app時、およびwar化してtomcatにデプロイしても同様に動作します。
ちなみに上記はSpring Bootの機能というだけです。(&lt;a href=&quot;https://www.jayway.com/2014/02/16/spring-propertysource/&quot;&gt;→参考&lt;/a&gt;)&lt;/p&gt;
&lt;h1&gt;余談&lt;/h1&gt;
&lt;p&gt;Spring Boot標準の設定ファイルの外部化の説明は&lt;a href=&quot;http://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-external-config.html&quot;&gt;こちら&lt;/a&gt;にありますが、非常に高機能かつ汎用的です。Spring Bootの主たる設定ファイルapplication.yaml(application.properties)は、特に何も設定しなくてもシステムプロパティspring.config.location(もしくは環境変数SPRING&lt;em&gt;CONFIG&lt;/em&gt;LOCATION、etc)で切り替えることができます。その場合、&lt;a href=&quot;http://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-external-config.html#boot-features-external-config-profile-specific-properties&quot;&gt;Profile-specific application properties&lt;/a&gt;というものに応じてファイル名を選択する、なども可能です。(Seasar2の&lt;a href=&quot;http://s2container.seasar.org/2.4/ja/DIContainer.html#ConditionalInclude&quot;&gt;「暗黙的な条件インクルード」&lt;/a&gt;と似た機能)&lt;/p&gt;
&lt;p&gt;ただ、spring.config.location方式だと、ベース名(デフォルトでappliction.yamlの「application」)を変更したい場合については、別のシステムプロパティ(spring.config.name)などの設定が必要になり、その設定は設定ファイルに書けない以上、環境変数やシステムプロパティで指定するしかなく、「環境変数やシステムプロパティを指定しない」ときにapplicationから読み込もうとしてしまう、という問題があり、Grails 2までの動作と上手く整合する方法をみつけられませんでした。&lt;/p&gt;
&lt;p&gt;もし、外部化する設定ファイルのファイル名がapplication.yaml(.properties)のままで良いのであれば、あるいはシステムプロパティや環境変数の設定が必須であるような運用ルールとするならば、spring.config.locationを使う方式でも良いかもしれません。その場合、特に設定はいりません。&lt;/p&gt;</content:encoded></item><item><title><![CDATA[Node.jsでgetchar]]></title><description><![CDATA[Node.jsでC言語のgetchar()マクロ(getc()関数)に相当するような、標準入力から1文字文字を読みとる処理を書くやりかた。NPMを使わずに手軽に直接できる方法を見つけられなかったため作成。仕様は以下のとおり。 Promise…]]></description><link>https://ganevru.github.io/gatsby-starter-blog-grommet/blog/5d9fec1ba6cc4c76e378/</link><guid isPermaLink="false">https://ganevru.github.io/gatsby-starter-blog-grommet/blog/5d9fec1ba6cc4c76e378/</guid><pubDate>Thu, 20 Feb 2020 15:08:12 GMT</pubDate><content:encoded>&lt;p&gt;Node.jsでC言語のgetchar()マクロ(getc()関数)に相当するような、標準入力から1文字文字を読みとる処理を書くやりかた。NPMを使わずに手軽に直接できる方法を見つけられなかったため作成。仕様は以下のとおり。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Promiseベース。以下で「〜を返す」は、「〜をPromiseのresolve値とするPromiseを返す」と読みかえてほしい。&lt;/li&gt;
&lt;li&gt;呼ぶごとに標準入力から1文字ずつ取得したUnicodeのコードポイント値を返す。readlineから得たstringからcharCodeAtしているのでサロゲートペアは別に対処が必要。&lt;/li&gt;
&lt;li&gt;バッファにデータがなければブロッキングして入力を待つ(stdinがTTYの場合)。&lt;/li&gt;
&lt;li&gt;行単位のバッファリングは行う。改行キーを押さない限りブロックは解除されない。&lt;/li&gt;
&lt;li&gt;バッファにデータが存在する限り、バッファから1文字を取り出し文字コードを返す。&lt;/li&gt;
&lt;li&gt;EOFでnullを返す。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;const readline = require(&apos;readline&apos;);
const rl  = readline.createInterface(process.stdin);
let buf = &quot;&quot;;

function getchar() {
  if (buf.length == 0) {
    if (process.stdin.AtEndOfStream) {
      return Promise.resolve(null); // EOF
    }
    return new Promise((resolve, reject) =&gt; {
      rl.once(&apos;line&apos;, (line) =&gt; {
        buf = buf + line + &quot;\n&quot;;
        resolve(getchar());
      });
    });
  } else {
    const result = buf.charCodeAt(0);
    buf = buf.substring(1);
    return Promise.resolve(result);
  }
}

async function test() {
  let ch
  while ((ch = await getchar()) !== null) {
    console.log(ch);
  }
}

test();
&lt;/code&gt;&lt;/pre&gt;</content:encoded></item><item><title><![CDATA[第12回オフラインリアルタイムどう書くの問題「サイコロを転がす」をHaskellで解く]]></title><description><![CDATA[第12回 オフラインリアルタイムどう書くの問題「サイコロを転がす」を、Haskellで解きました。
Stateモナド厨。]]></description><link>https://ganevru.github.io/gatsby-starter-blog-grommet/blog/5f46b012f13e1d3cee55/</link><guid isPermaLink="false">https://ganevru.github.io/gatsby-starter-blog-grommet/blog/5f46b012f13e1d3cee55/</guid><pubDate>Thu, 20 Feb 2020 15:08:12 GMT</pubDate><content:encoded>&lt;p&gt;&lt;a href=&quot;http://qiita.com/Nabetani/items/f3cca410428f90333e28&quot;&gt;第12回 オフラインリアルタイムどう書く&lt;/a&gt;の問題「&lt;a href=&quot;http://nabetani.sakura.ne.jp/hena/ord12rotdice/&quot;&gt;サイコロを転がす&lt;/a&gt;」を、Haskellで解きました。
Stateモナド厨。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-diceState.hs&quot;&gt;-- http://nabetani.sakura.ne.jp/hena/ord12rotdice/
import Data.List
import Control.Monad.State

-- 1と2の向きで表わしたサイコロの方向の状態。NEは「1の目が北(N)、2の目が東(E)」を表わす。Uは上、Dは下を表わす。
data DiceState = NE|ES|SW|WN|EN|SE|WS|NW|UN|ND|DS|SU|NU|DN|SD|US|UE|ED|DW|WU|EU|DE|WD|UW deriving (Show, Eq)

-- それぞれのサイコロの状態で上面の数字(目)を表わす連想リスト。
deuce :: [(DiceState, Char)]
deuce = [(NE,&apos;4&apos;),(ES,&apos;4&apos;),(SW,&apos;4&apos;),(WN,&apos;4&apos;),(EN,&apos;3&apos;),(SE,&apos;3&apos;),
         (WS,&apos;3&apos;),(NW,&apos;3&apos;),(UN,&apos;1&apos;),(ND,&apos;5&apos;),(DS,&apos;6&apos;),(SU,&apos;2&apos;),
         (NU,&apos;2&apos;),(DN,&apos;6&apos;),(SD,&apos;5&apos;),(US,&apos;1&apos;),(UE,&apos;1&apos;),(ED,&apos;5&apos;),
         (DW,&apos;6&apos;),(WU,&apos;2&apos;),(EU,&apos;2&apos;),(DE,&apos;6&apos;),(WD,&apos;5&apos;),(UW,&apos;1&apos;)]

-- ころがし操作。&apos;N&apos;:北へころがす, &apos;W&apos;:西へころがす, &apos;S&apos;:南へころがす, &apos;E&apos;:東へころがす
type Roll = Char

-- サイコロの状態における目(上を向いている面の数値)を返す
getDeuce :: DiceState -&gt; Char
getDeuce state = let (Just n) = lookup state deuce in n

mkpair :: (t, t, t, t) -&gt; [(t, t)]
mkpair (a,b,c,d) = [(a,b),(b,c),(c,d),(d,a)]

-- 東にころがす回転(&apos;E&apos;)におけるサイコロ状態の変化
-- [(回転前の状態,回転後の状態), ...]の連想リスト
moveDataToEast :: [(DiceState, DiceState)]
moveDataToEast = concat [mkpair (UN,EN,DN,WN),
                         mkpair (ND,NW,NU,NE),
                         mkpair (DS,WS,US,ES),
                         mkpair (SU,SE,SD,SW),
                         mkpair (ED,DW,WU,UE),
                         mkpair (EU,DE,WD,UW)]
-- 北にころがす回転(&apos;N&apos;)におけるサイコロ状態の変化
-- [(回転前の状態,回転後の状態), ...]の連想リスト
moveDataToNorth :: [(DiceState, DiceState)]
moveDataToNorth = concat [mkpair (UN,ND,DS,SU),
                          mkpair (EN,ED,ES,EU),
                          mkpair (DN,SD,US,NU),
                          mkpair (WN,WD,WS,WU),
                          mkpair (NW,DW,SW,UW),
                          mkpair (SE,UE,NE,DE)]

-- 指定した状態に対して、ころがし操作を与えたとき、次状態を得る
step :: Roll -&gt; DiceState -&gt; DiceState
step r direc = case r of
                 &apos;N&apos; -&gt; moveN direc
                 &apos;W&apos; -&gt; moveW direc
                 &apos;S&apos; -&gt; moveS direc
                 &apos;E&apos; -&gt; moveE direc
               where
                 -- 北にころがしたときの次状態を返す
                 moveN :: DiceState -&gt; DiceState
                 moveN s = let (Just d) = lookup s moveDataToNorth in d
                 -- 西にころがしたときの次状態を返す
                 moveW :: DiceState -&gt; DiceState
                 moveW s = moveE $ moveE $ moveE s
                 -- 南にころがしたときの次状態を返す
                 moveS :: DiceState -&gt; DiceState
                 moveS s = moveN $ moveN $ moveN s
                 -- 東にころがしたときの次状態を返す
                 moveE :: DiceState -&gt; DiceState
                 moveE s = let (Just d) = lookup s moveDataToEast in d

-- ころがし操作を与えると次の状態モナドを返すモナディック関数
-- 状態は、(サイコロ上面の数値(目)の履歴, サイコロの状態)というタプルで表現。
stepSt :: Roll -&gt; State (String, DiceState) ()
stepSt ch = do
  (xs, direc) &amp;#x3C;- get
  let nextDirec = step ch direc
  state $ const ((), (getDeuce nextDirec:xs, nextDirec))

-- ころがし操作の列と、結果(目の履歴)の期待値を与え、一致しているかどうかを返す
test :: String -&gt; String -&gt; Bool
test opr expected = let (xs, _) = execState (mapM stepSt opr) ([&apos;1&apos;], UN)
                    in (reverse xs == expected)

main :: IO ()
main = do
    print $ test &quot;NNESWWS&quot; &quot;15635624&quot;  {-- 0 --}
    print $ test &quot;EEEE&quot; &quot;13641&quot;  {-- 1 --}
    print $ test &quot;WWWW&quot; &quot;14631&quot;  {-- 2 --}
    print $ test &quot;SSSS&quot; &quot;12651&quot;  {-- 3 --}
    print $ test &quot;NNNN&quot; &quot;15621&quot;  {-- 4 --}
    print $ test &quot;EENN&quot; &quot;13651&quot;  {-- 5 --}
    print $ test &quot;WWNN&quot; &quot;14651&quot;  {-- 6 --}
    print $ test &quot;SSNN&quot; &quot;12621&quot;  {-- 7 --}
    print $ test &quot;NENNN&quot; &quot;153641&quot;  {-- 8 --}
    print $ test &quot;NWNNN&quot; &quot;154631&quot;  {-- 9 --}
    print $ test &quot;SWWWSNEEEN&quot; &quot;12453635421&quot;  {-- 10 --}
    print $ test &quot;SENWSWSNSWE&quot; &quot;123123656545&quot;  {-- 11 --}
    print $ test &quot;SSSWNNNE&quot; &quot;126546315&quot;  {-- 12 --}
    print $ test &quot;SWNWSSSWWE&quot; &quot;12415423646&quot;  {-- 13 --}
    print $ test &quot;ENNWWS&quot; &quot;1354135&quot;  {-- 14 --}
    print $ test &quot;ESWNNW&quot; &quot;1321365&quot;  {-- 15 --}
    print $ test &quot;NWSSE&quot; &quot;154135&quot;  {-- 16 --}
    print $ test &quot;SWNWEWSEEN&quot; &quot;12415154135&quot;  {-- 17 --}
    print $ test &quot;EWNWEEEEWN&quot; &quot;13154532426&quot;  {-- 18 --}
    print $ test &quot;WNEWEWWWSNW&quot; &quot;145151562421&quot;  {-- 19 --}
    print $ test &quot;NNEE&quot; &quot;15631&quot;  {-- 20 --}
    print $ test &quot;EEEEWNWSW&quot; &quot;1364145642&quot;  {-- 21 --}
    print $ test &quot;SENNWWES&quot; &quot;123142321&quot;  {-- 22 --}
    print $ test &quot;SWWWSNSNESWW&quot; &quot;1245363635631&quot;  {-- 23 --}
    print $ test &quot;WESSENSE&quot; &quot;141263231&quot;  {-- 24 --}
    print $ test &quot;SWNSSESESSS&quot; &quot;124146231562&quot;  {-- 25 --}
    print $ test &quot;ENS&quot; &quot;1353&quot;  {-- 26 --}
    print $ test &quot;WNN&quot; &quot;1453&quot;  {-- 27 --}
    print $ test &quot;SSEENEEEN&quot; &quot;1263124536&quot;  {-- 28 --}
    print $ test &quot;NWSNNNW&quot; &quot;15414632&quot;  {-- 29 --}
    print $ test &quot;ESSSSSWW&quot; &quot;132453215&quot;  {-- 30 --}
    print $ test &quot;ESE&quot; &quot;1326&quot;  {-- 31 --}
    print $ test &quot;SNWNWWNSSSS&quot; &quot;121456232453&quot;  {-- 32 --}
    print $ test &quot;SWEESEN&quot; &quot;12423653&quot;  {-- 33 --}
    print $ test &quot;NEEWNSSWWW&quot; &quot;15323631562&quot;  {-- 34 --}
    print $ test &quot;WSEW&quot; &quot;14212&quot;  {-- 35 --}
    print $ test &quot;SWSNNNSNWE&quot; &quot;12464131353&quot;  {-- 36 --}
    print $ test &quot;ENWEWSEEW&quot; &quot;1351513545&quot;  {-- 37 --}
    print $ test &quot;WSEWN&quot; &quot;142124&quot;  {-- 38 --}
    print $ test &quot;EWNEESEWE&quot; &quot;1315321414&quot;  {-- 39 --}
    print $ test &quot;NESEEN&quot; &quot;1531263&quot;  {-- 40 --}
    print $ test &quot;WSW&quot; &quot;1426&quot;  {-- 41 --}
    print $ test &quot;ENEWE&quot; &quot;135656&quot;  {-- 42 --}
&lt;/code&gt;&lt;/pre&gt;</content:encoded></item><item><title><![CDATA[第13回オフラインリアルタイムどう書くの問題をFregeで解く]]></title><description><![CDATA[第13回 オフラインリアルタイムどう書くの問題「積み木の水槽」を、JVM上で動作するHaskellライクな言語Frege(フレーゲ)で解きました。]]></description><link>https://ganevru.github.io/gatsby-starter-blog-grommet/blog/60abb9be0dfac0755dcf/</link><guid isPermaLink="false">https://ganevru.github.io/gatsby-starter-blog-grommet/blog/60abb9be0dfac0755dcf/</guid><pubDate>Thu, 20 Feb 2020 15:08:12 GMT</pubDate><content:encoded>&lt;p&gt;&lt;a href=&quot;http://atnd.org/events/41603&quot;&gt;第13回 オフラインリアルタイムどう書く&lt;/a&gt;の問題「&lt;a href=&quot;http://nabetani.sakura.ne.jp/hena/ord13blocktup/&quot;&gt;積み木の水槽&lt;/a&gt;」を、JVM上で動作するHaskellライクな言語&lt;a href=&quot;https://github.com/Frege/frege/wiki/_pages&quot;&gt;Frege&lt;/a&gt;(フレーゲ)で解きました。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-frege:shortest.fr&quot;&gt;-- http://nabetani.sakura.ne.jp/hena/ord13blocktup/
     
data Cell = Wall | Empty | Water
derive Eq Cell -- Haskellのdata Cell = ... deriving(Eq)

-- セルを表示する
instance Show Cell where
    show Wall = &quot;*&quot;
    show Empty = &quot; &quot;
    show Water = &quot;+&quot;

-- 盤面を表示する
data Matrix = Matrix [ [ Cell ] ] Int Int
derive Eq Matrix
instance Show Matrix where
    show (Matrix xs w h) = &quot;w=&quot;++show w++&quot;,h=&quot;++show h++&quot;\n&quot;++ unlines (map showLine xs)
        where
          showLine :: [Cell] -&gt; String
          showLine line = &quot;[&quot; ++ foldl (++) &quot;&quot; (map show line) ++ &quot;]&quot;

-- 盤面を生成する
toMatrix :: String -&gt; Matrix
toMatrix str =
    let maxx = length str
        maxy = maximum $ map (\ch -&gt; ord ch - ord &apos;0&apos;) (unpacked str)
        makeLine n maxn = replicate n Wall ++ replicate (maxn-n) Empty
    in Matrix (map (\ch -&gt; makeLine (ord ch - ord &apos;0&apos;) maxy) (unpacked str)) maxx maxy

-- 指定した座標(xPos,yPos)のセル内容を取得する
getCell :: Matrix -&gt; Int -&gt; Int -&gt; Cell
getCell (Matrix mat w h) xPos yPos
      | (0 &amp;#x3C;= xPos) &amp;#x26;&amp;#x26; ( xPos &amp;#x3C; w ) &amp;#x26;&amp;#x26; (0 &amp;#x3C;= yPos) &amp;#x26;&amp;#x26; (yPos &amp;#x3C; h) = mat !! xPos !! yPos
      | otherwise = Empty

-- Matrix型の盤面の指定した座標(xPos,yPos)にセル内容cを設定する
setCell:: Matrix -&gt; Int -&gt; Int -&gt; Cell -&gt; Matrix
setCell (Matrix mat w h) xPos yPos c
      | ( xPos &amp;#x3C; w ) &amp;#x26;&amp;#x26; (yPos &amp;#x3C; h) = Matrix (setCell&apos; mat xPos yPos c) w h

-- [[Cell]]型の盤面の指定した座標(xPos,yPos)にセル内容cを設定する
setCell&apos; :: [[Cell]] -&gt; Int -&gt; Int -&gt; Cell -&gt; [[Cell]]
setCell&apos; (x:xs) xPos yPos c
    | xPos == 0 = setCellY x yPos c : xs
    | otherwise = x:setCell&apos; xs (xPos-1) yPos c

-- Cellの列の指定した座標(yPos)にセル内容cを設定する
setCellY :: [Cell] -&gt; Int -&gt; Cell -&gt; [Cell]
setCellY (x:xs) yPos c
    | yPos == 0 = c:xs
    | otherwise = x:setCellY xs (yPos-1) c

-- 以下のtmpは、以下が通らなかったための苦肉の策。fregeのバグ?
-- fillWater m0 = foldl (\mat (x,y)-&gt; fillWaterCell mat x y) m0 (cells m0)
tmp:: Matrix -&gt; (Int, Int) -&gt; Matrix
tmp mat (x,y) = fillWaterCell mat x y

-- 盤面に水を満たす
fillWater :: Matrix -&gt; Matrix
fillWater m0 = foldl tmp m0 (cells m0)
  where
    cells (Matrix _ width height) = do
        y &amp;#x3C;- [0.. height-1]
        x &amp;#x3C;- [0.. width-1]
        return (x, y)

fillWaterCell mat x y
    | isKeepWater mat x y &amp;#x26;&amp;#x26; getCell mat x y == Empty = setCell mat x y Water
    | otherwise = mat

-- 指定した座標x,yは水を保持できるか？
isKeepWater :: Matrix -&gt; Int -&gt; Int -&gt; Bool
isKeepWater mat x y
    | hereOK mat x y = true
    | leftOK mat x y &amp;#x26;&amp;#x26; bottomOK mat x y &amp;#x26;&amp;#x26; rightThroughOK mat x y = true
    | otherwise = false
    where
        ok x = (x == Wall) || (x == Water)
        hereOK mat x y = ok $ getCell mat x y
        leftOK mat x y = ok $ getCell mat (x-1) y
        bottomOK mat x y = ok $ getCell mat x (y-1)
        rightOK mat x y = ok $ getCell mat (x+1) y
        rightThroughOK mat x y
            | bottomOK mat x y &amp;#x26;&amp;#x26; rightOK mat x y = true
            | bottomOK mat x y &amp;#x26;&amp;#x26; rightThroughOK mat (x+1) y = true
            | otherwise = false
           
-- 水の個数を返す
countAllWater :: Matrix -&gt; Int
countAllWater (Matrix m _ _) = foldr ((+) . countAllWaterY) 0 m
    where
        countAllWaterY [] = 0
        countAllWaterY (Water:xs) = 1 + countAllWaterY xs
        countAllWaterY (x:xs) = 0 + countAllWaterY xs

-- x.atoiはHaskellのread xと等価(xがintとして解釈可能である文字列の場合)。
test :: String -&gt; String -&gt; Bool
test dat expected = expected.atoi == (countAllWater $ fillWater (toMatrix dat))

main :: [String] -&gt; IO ()
main _ = do
   println $ test &quot;83141310145169154671122&quot; &quot;24&quot; {-0-}
   println $ test &quot;923111128&quot; &quot;45&quot; {-1-}
   println $ test &quot;923101128&quot; &quot;1&quot; {-2-}
   println $ test &quot;903111128&quot; &quot;9&quot; {-3-}
   println $ test &quot;3&quot; &quot;0&quot; {-4-}
   println $ test &quot;31&quot; &quot;0&quot; {-5-}
   println $ test &quot;412&quot; &quot;1&quot; {-6-}
   println $ test &quot;3124&quot; &quot;3&quot; {-7-}
   println $ test &quot;11111&quot; &quot;0&quot; {-8-}
   println $ test &quot;222111&quot; &quot;0&quot; {-9-}
   println $ test &quot;335544&quot; &quot;0&quot; {-10-}
   println $ test &quot;1223455321&quot; &quot;0&quot; {-11-}
   println $ test &quot;000&quot; &quot;0&quot; {-12-}
   println $ test &quot;000100020003121&quot; &quot;1&quot; {-13-}
   println $ test &quot;1213141516171819181716151413121&quot; &quot;56&quot; {-14-}
   println $ test &quot;712131415161718191817161514131216&quot; &quot;117&quot; {-15-}
   println $ test &quot;712131405161718191817161514031216&quot; &quot;64&quot; {-16-}
   println $ test &quot;03205301204342100&quot; &quot;1&quot; {-17-}
   println $ test &quot;0912830485711120342&quot; &quot;18&quot; {-18-}
   println $ test &quot;1113241120998943327631001&quot; &quot;20&quot; {-19-}
   println $ test &quot;7688167781598943035023813337019904732&quot; &quot;41&quot; {-20-}
   println $ test &quot;2032075902729233234129146823006063388&quot; &quot;79&quot; {-21-}
   println $ test &quot;8323636570846582397534533&quot; &quot;44&quot; {-22-}
   println $ test &quot;2142555257761672319599209190604843&quot; &quot;41&quot; {-23-}
   println $ test &quot;06424633785085474133925235&quot; &quot;51&quot; {-24-}
   println $ test &quot;503144400846933212134&quot; &quot;21&quot; {-25-}
   println $ test &quot;1204706243676306476295999864&quot; &quot;21&quot; {-26-}
   println $ test &quot;050527640248767717738306306596466224&quot; &quot;29&quot; {-27-}
   println $ test &quot;5926294098216193922825&quot; &quot;65&quot; {-28-}
   println $ test &quot;655589141599534035&quot; &quot;29&quot; {-29-}
   println $ test &quot;7411279689677738&quot; &quot;34&quot; {-30-}
   println $ test &quot;268131111165754619136819109839402&quot; &quot;102&quot; {-31-}
&lt;/code&gt;&lt;/pre&gt;</content:encoded></item><item><title><![CDATA[Node.jsでPEG.jsでBrainf*ck]]></title><description><![CDATA[Node.jsでのBrainf*ckインタプリタ実装。PEG.js使用。
PEG.jsの勉強に作ってみました。PEG.js便利です。JSに馴染むぞぉ〜。 BF…]]></description><link>https://ganevru.github.io/gatsby-starter-blog-grommet/blog/68fa097e03d0572aefe4/</link><guid isPermaLink="false">https://ganevru.github.io/gatsby-starter-blog-grommet/blog/68fa097e03d0572aefe4/</guid><pubDate>Thu, 20 Feb 2020 15:08:12 GMT</pubDate><content:encoded>&lt;p&gt;Node.jsでのBrainf*ckインタプリタ実装。&lt;a href=&quot;https://pegjs.org/&quot;&gt;PEG.js&lt;/a&gt;使用。
PEG.jsの勉強に作ってみました。PEG.js便利です。JSに馴染むぞぉ〜。&lt;/p&gt;
&lt;p&gt;BF処理系として、工夫といえば工夫なのは、ループブロック構文[と]の対応を、実行時に命令列からスキャンするのではなく、パース/AST構築の段階でシンタックスの問題として解決するところ。まあ、普通に考えればそうなるべきな話ではあるのですが。&lt;/p&gt;
&lt;p&gt;苦労したのは、1文字入力で、標準ライブラリを呼べばいいのかなと思ったら、見付けられなかったので作りました(&lt;a href=&quot;https://qiita.com/uehaj/items/5d9fec1ba6cc4c76e378&quot;&gt;別記事&lt;/a&gt;)。&lt;/p&gt;
&lt;p&gt;require(‘./parser’)しているところは、&lt;a href=&quot;https://pegjs.org/online&quot;&gt;PEG.js online&lt;/a&gt;で以下から生成させたパーサをparser.jsというファイル名でダウンロードし、同じディレクトリに保存してください。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;code = (normal_insn / block_insn / otherchar) *

normal_insn = ch:[&gt;&amp;#x3C;+-.,] { return ch }
block_insn = &apos;[&apos; brk:block &apos;]&apos; { return brk  }

block = cod:code {
  return cod;
}

otherchar = [^&gt;&amp;#x3C;+-.,\[\]] {
  return undefined
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;実行例:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://qiita-image-store.s3.amazonaws.com/0/9979/a2428b6b-bb1e-2ff6-7ed0-c25ba2286b2a.gif&quot; alt=&quot;bfjs.mov.gif&quot;&gt;&lt;/p&gt;
&lt;p&gt;以下、main.js&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;const readline = require(&apos;readline&apos;);
const rl = readline.createInterface({input:process.stdin});
let buf = &quot;&quot;;

function getchar() {
  if (buf.length == 0) {
    if (process.stdin.AtEndOfStream) {
      return Promise.resolve(null); // EOF
    }
    return new Promise((resolve, reject) =&gt; {
      rl.once(&apos;line&apos;, (line) =&gt; {
        buf = buf + line + &quot;\n&quot;;
        resolve(getchar());
      });
    });
  } else {
    const result = buf.charCodeAt(0);
    buf = buf.substring(1);
    return Promise.resolve(result);
  }
}

/*
  code = (normal_insn / block_insn / otherchar) *

  normal_insn = ch:[&gt;&amp;#x3C;+-.,] { return ch }
  block_insn = &apos;[&apos; brk:block &apos;]&apos; { return brk  }

  block = cod:code {
  return cod;
  }

  otherchar = [^&gt;&amp;#x3C;+-.,\[\]] {
  return undefined
  }
*/
// generated with PEG.js from above peg syntax.
const parser = require(&quot;./parser.js&quot;); 


const source = `
&gt;&gt;++++++++[-&gt;++++++++&amp;#x3C;]&gt;&gt;&gt;&gt;+++++++++[-&gt;++++++++++&amp;#x3C;]&gt;[&amp;#x3C;&amp;#x3C;,[-&gt;+&amp;#x3C;&amp;#x3C;+&amp;#x3C;&amp;#x3C;+&gt;&gt;&gt;]&amp;#x3C;&amp;#x3C;&amp;#x3C;[
-&gt;&gt;&gt;+&amp;#x3C;&amp;#x3C;&amp;#x3C;]&gt;&gt;&gt;&gt;&gt;[-&gt;+&gt;&gt;+&amp;#x3C;&amp;#x3C;&amp;#x3C;]&gt;[&amp;#x3C;&amp;#x3C;[-&gt;+&gt;&gt;+&amp;#x3C;&amp;#x3C;&amp;#x3C;]&gt;&gt;&gt;[-&amp;#x3C;&amp;#x3C;&amp;#x3C;+&gt;&gt;&gt;]&amp;#x3C;&amp;#x3C;[[-]&amp;#x3C;-&gt;]&gt;-]&gt;&gt;[-&amp;#x3C;&amp;#x3C;&amp;#x3C;+
&gt;&gt;&gt;]&amp;#x3C;&amp;#x3C;&amp;#x3C;&amp;#x3C;&amp;#x3C;&amp;#x3C;&amp;#x3C;[-&amp;#x3C;+&amp;#x3C;&amp;#x3C;+&gt;&gt;&gt;]&amp;#x3C;[&gt;&gt;[-&amp;#x3C;+&amp;#x3C;&amp;#x3C;+&gt;&gt;&gt;]&amp;#x3C;&amp;#x3C;&amp;#x3C;[-&gt;&gt;&gt;+&amp;#x3C;&amp;#x3C;&amp;#x3C;]&gt;&gt;[[-]&gt;-&amp;#x3C;]&amp;#x3C;-]&amp;#x3C;&amp;#x3C;[-&gt;&gt;&gt;+&amp;#x3C;&amp;#x3C;&amp;#x3C;
]&gt;&gt;&gt;&gt;&gt;&amp;#x3C;[[-]&gt;++++++++++++++++++++++++++++++++&gt;[[-]&amp;#x3C;------------------------
--------&gt;]&amp;#x3C;&amp;#x3C;]&gt;&gt;[-]&amp;#x3C;.&gt;&gt;]`;

const ast = parser.parse(source);

const memSize = 20;
let ptr = 0;
const memory = Array(memSize).fill(0);

async function run(code, prefix) {
  // console.log(&quot;run code=&quot;,code,&apos;mem=&apos;,memory,&apos;ptr=&apos;,ptr);
  for (const i of code) {
    // console.log(&quot;  ins=&quot;,i);
    if (Array.isArray(i)) {
      while (memory[ptr] !== 0) {
        await run(i, prefix+&quot; &quot;);
      }
    }
    else if (i === &apos;&gt;&apos;){
      ptr += 1;
    }
    else if (i === &apos;&amp;#x3C;&apos;){
      ptr -= 1;
    }
    else if (i === &apos;+&apos;){
      memory[ptr] += 1;
    }
    else if (i === &apos;-&apos;){
      memory[ptr] -= 1;
    }
    else if (i === &apos;.&apos;){
      process.stdout.write(String.fromCharCode(memory[ptr]));
    }
    else if (i === &apos;,&apos;){
      memory[ptr] = await getchar();
    }
  }
}

run(ast, &quot;&quot;).then(()=&gt;{
  console.log(memory);
  process.exit()
});
&lt;/code&gt;&lt;/pre&gt;</content:encoded></item><item><title><![CDATA[Dartのアイソレート間で相互通信をする例]]></title><description><![CDATA[DartのIsolateを使って相互に通信をする例。 追記あり Isolate→spawn元(main)の方向の通信は、ReceivePort.sendPortをspawn時に渡してやれば良いが、逆方向の通信(main→Isolate)は、spawnしたIsolate…]]></description><link>https://ganevru.github.io/gatsby-starter-blog-grommet/blog/69d1eba89ebe51af6d02/</link><guid isPermaLink="false">https://ganevru.github.io/gatsby-starter-blog-grommet/blog/69d1eba89ebe51af6d02/</guid><pubDate>Thu, 20 Feb 2020 15:08:12 GMT</pubDate><content:encoded>&lt;p&gt;DartのIsolateを使って相互に通信をする例。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://qiita.com/uehaj/items/69d1eba89ebe51af6d02#%E8%BF%BD%E8%A8%982&quot;&gt;追記あり&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Isolate→spawn元(main)の方向の通信は、ReceivePort.sendPortをspawn時に渡してやれば良いが、逆方向の通信(main→Isolate)は、spawnしたIsolate先でReceivePortを作成し、そのsendPortをmainに戻してもらい、そのsendport経由で送信することになる。&lt;/p&gt;
&lt;p&gt;sendPortをどうやって戻すかだが、以下ではIsolateに渡すReceivePort経由で受けとっている。(これ以外の良い方法は、グローバル変数にするとか以外にあるかな。どなたかご存知の方教えて!)&lt;/p&gt;
&lt;p&gt;そのとき、sendPortをStream.firstで受けとろうとすると、&lt;a href=&quot;https://api.dartlang.org/stable/1.24.3/dart-async/Stream/first.html&quot;&gt;Stream.firstはSteramをlistenし受信後にsubscriptionをcancelしてしまう&lt;/a&gt;ので、listenerを一回限りしか設定できないsingle-subscription streamでは継続受信できなくなってしまう。なのでStream. asBroadcastStreamでbroadcast streamにしておく必要がある。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-dart&quot;&gt;import &apos;dart:isolate&apos;;
import &quot;dart:async&quot;;

main() async {
  try {
    var singleChannel = new ReceivePort();
    await Isolate.spawn(echo, singleChannel.sendPort);

    var multiChannel = singleChannel.asBroadcastStream();
    var callbackSendPort = await multiChannel.first;
    multiChannel.listen((msg) {
      print(&apos;main: received ${msg}&apos;);
      callbackSendPort.send(&apos;hoy!&apos;);
    });
  } catch (e) {
    print(&apos;error ${e}&apos;);
  }
}

// the entry point for the isolate
void echo(sendPort) async {

  var callBackReceivePort = new ReceivePort();
  sendPort.send(callBackReceivePort.sendPort);
  callBackReceivePort.listen((msg){
    print(&apos;echo: received ${msg}&apos;);
  });
  while (true) {
    await new Future.delayed(new Duration(seconds: 1));
    sendPort.send(&quot;hello&quot;);
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;結果&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;% dart web/index2.dart
main: received hello
echo: received hoy!
main: received hello
echo: received hoy!
main: received hello
echo: received hoy!
:
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;sendPortを送り戻してもらう他の方法としては、firstを使わずにストリームで最初に受けとる要素として取り出すという方法もあるだろう。
こんな感じ。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    var callbackSendPort = null;
    multiChannel.listen((msg) {
      if (callbackSendPort == null) {
        callbackSendPort = msg;
      }
      else {
        print(&apos;main: received ${msg}&apos;);
        callbackSendPort.send(&apos;hoy!&apos;);
      }
    });
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;これが嫌なのはまちがいない&lt;sup id=&quot;fnref-1&quot;&gt;&lt;a href=&quot;#fn-1&quot; class=&quot;footnote-ref&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;が、asBroadcastStreamも相当である。良い方法があればおしえてください。&lt;/p&gt;
&lt;h1&gt;追記&lt;/h1&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cresc.co.jp/tech/java/Google_Dart/DartLanguageGuide.pdf&quot;&gt;https://www.cresc.co.jp/tech/java/Google_Dart/DartLanguageGuide.pdf&lt;/a&gt;
18.5節 アイソレート間の通信リンクの確立&lt;/p&gt;
&lt;p&gt;を見ると、後者の方法に近く、ただ&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    var callbackSendPort = null;
    multiChannel.listen((msg) {
      if (msg is SendPort) {
        callbackSendPort = msg;
      }
      else {
        print(&apos;main: received ${msg}&apos;);
        callbackSendPort.send(&apos;hoy!&apos;);
      }
    });
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;に相当するような、実行時の型で切りわけをしていますね。また接続状態を状態遷移でしっかりと管理している。&lt;/p&gt;
&lt;h1&gt;追記2&lt;/h1&gt;
&lt;p&gt;StreamIteratorを使うのが良いみたい。asBroadcastStream()が不要であり、型も気持ち守れて、状態変数を導入しなくてよい。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-dart&quot;&gt;import &apos;dart:isolate&apos;;
import &quot;dart:async&quot;;

main() async {
  try {
    var channel = new ReceivePort();
    await Isolate.spawn(echo, channel.sendPort);

    StreamIterator itr = new StreamIterator(channel);
    if (await itr.moveNext()) {
       SendPort callbackSendPort = itr.current;
       while (await itr.moveNext()) {
         print(&apos;main: received ${itr.current}&apos;);
         callbackSendPort.send(&apos;hoy!&apos;);
       }
    }
  } catch (e) {
    print(&apos;error ${e}&apos;);
  }
}

// the entry point for the isolate
Future echo(sendPort) async {

  var callBackReceivePort = new ReceivePort();
  sendPort.send(callBackReceivePort.sendPort);
  callBackReceivePort.listen((msg){
    print(&apos;echo: received ${msg}&apos;);
  });
  while (true) {
    await new Future.delayed(new Duration(seconds: 1));
    sendPort.send(&quot;hello&quot;);
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;こちらも参考に
&lt;a href=&quot;https://speakerdeck.com/uehaj/dart-isolate-port-and-capabilities&quot;&gt;https://speakerdeck.com/uehaj/dart-isolate-port-and-capabilities&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;footnotes&quot;&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id=&quot;fn-1&quot;&gt;
&lt;p&gt;型制約できなくなる気がする。Dartにユニオン型ってあったっけ。&lt;/p&gt;
&lt;a href=&quot;#fnref-1&quot; class=&quot;footnote-backref&quot;&gt;↩&lt;/a&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</content:encoded></item><item><title><![CDATA[TypeScriptの関数の型指定まとめ]]></title><description><![CDATA[はじめに TypeScriptの関数型について、いまいちすっきりしてなかったので整理してみました。
まず、準備としてとして とします。 関数定義の基本パターン 次に、関数定義の基本パターンとして とします。このときfunc1の型は「function func1(a: IHoge…]]></description><link>https://ganevru.github.io/gatsby-starter-blog-grommet/blog/79c277301f89d109c11d/</link><guid isPermaLink="false">https://ganevru.github.io/gatsby-starter-blog-grommet/blog/79c277301f89d109c11d/</guid><pubDate>Thu, 20 Feb 2020 15:08:12 GMT</pubDate><content:encoded>&lt;h1&gt;はじめに&lt;/h1&gt;
&lt;p&gt;TypeScriptの関数型について、いまいちすっきりしてなかったので整理してみました。
まず、準備としてとして&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-TypeScript&quot;&gt;type IHoge = {
    a: number;
    b: string;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;とします。&lt;/p&gt;
&lt;h1&gt;関数定義の基本パターン&lt;/h1&gt;
&lt;p&gt;次に、関数定義の基本パターンとして&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-TypeScript&quot;&gt;function func1(a: IHoge): IHoge {
    return { a: 3, b: &apos;a&apos;};
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;とします。このときfunc1の型は「&lt;code&gt;function func1(a: IHoge): IHoge&lt;/code&gt;」です。
以降、このバリエーションを見ていきます。意味的にはすべて同じです。&lt;/p&gt;
&lt;h1&gt;アロー式での関数定義&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&quot;language-TypeScript&quot;&gt;//-------------------------これ以上できないぐらいの型のフル指定(アロー式リテラル版)。------------------
 const func2: (a: IHoge) =&gt; IHoge
    = (a: IHoge): IHoge =&gt; ({ a: 3, b: &apos;a&apos;}) ;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;アロー式で定義します。このときfunc2の型は「&lt;code&gt;const func2: (a: IHoge) =&gt; IHoge&lt;/code&gt;」です。
func1のfunction型とは型としては異なることがわかります。しかし両者の型は実質的には同じで、以下のように代入が可能です。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-TypeScript&quot;&gt;const func2_a: (a: IHoge) =&gt; IHoge = func1;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;「これ以上できないぐらいの型のフル指定」では、func2というシンボルの型と、関数本体の定義の方で、関数と引数と返り値の型を二重に指定していることがわかると思います。これは無駄なので、省略を試みます。
まず、シンボルの型を省略してみます。省略された場所は「&lt;code&gt;/**/&lt;/code&gt;」で示します。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-TypeScript&quot;&gt;//-------------------------以下の2つは型推論によりほぼ同じ(アロー式リテラル版)------------------
const func3 /**/
     = (a: IHoge): IHoge =&gt; ({ a: 3, b: &apos;a&apos;}) ;

const func4 /**/
    = (a: IHoge) /**/ =&gt; ({ a: 3, b: &apos;a&apos;}) ;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;のようになります。戻り値の型を省略したfunc4の場合、戻り値の型は関数本体から推論されていることになります。func4の戻り値の型は「&lt;code&gt;{ a: number; b: string; }&lt;/code&gt;」で、IHogeとはノミナルな意味では一致しませんが、TypeScriptでは特に問題はありません。しかし一般には、この推論があたっているとは限らないので、func3のように明示したいところです。型チェックの意義が薄れるからです。&lt;/p&gt;
&lt;p&gt;次、引数の型を省略を試みます。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-TypeScript&quot;&gt;//-------------------------引数は型推論しないので型指定すべき(アロー式リテラル版)------------------
const func5 /**/
    = (a: any/**/) : IHoge =&gt; ({ a: 3, b: &apos;a&apos;}) ;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;引数の型を省略すると、TypeScriptは呼び出し側の引数から型推論をすることはないので、「Parameter ‘a’ implicitly has an ‘any’ type.」というエラーになると思います(オプションによる)。ここではanyを補っていますが、こういうことをすると、引数の型チェックがなされなくなるので、やめるべきです。func1よりもコンパイル時に型エラーチェックできる能力が減損しています。&lt;/p&gt;
&lt;p&gt;次に、シンボルの型の方ではなく、関数定義本体の方の型を省略してみます。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-TypeScript&quot;&gt;//-------------------------以下の三つは同じ(アロー式リテラル版)------------------
const func6: (a: IHoge) =&gt; IHoge
     = (a /**/) /**/ =&gt; ({ a: 3, b: &apos;a&apos;}) ;

const func7: (a: IHoge) =&gt; IHoge
     = (a /**/): IHoge =&gt; ({ a: 3, b: &apos;a&apos;}) ;

const func8: (a: IHoge) =&gt; IHoge
     = (a : IHoge) /**/ =&gt; ({ a: 3, b: &apos;a&apos;}) ;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;これでわかるように、関数定義本体の方の型は省略しても不都合がありません。
func7, func8は二重指定になっています。
&lt;strong&gt;&lt;em&gt;個人的にはfunc6のパターンがお勧めです。&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;なお、func2〜3, 6〜8の型は「&lt;code&gt;const func*: (a: IHoge) =&gt; IHoge&lt;/code&gt;」です。
func4の型は「&lt;code&gt;const func11: (a: IHoge) =&gt; { a: number; b: string; }&lt;/code&gt;」です。
func5の型は「&lt;code&gt;const func5: (a: any) =&gt; IHoge&lt;/code&gt;」です。&lt;/p&gt;
&lt;h1&gt;functionリテラル形式での関数定義&lt;/h1&gt;
&lt;p&gt;さて、今まではアロー式で型を与えてきましたが、まったく同じことがfunction形式の関数でも言えます。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-TypeScript&quot;&gt;//-------------------------これ以上できないぐらいの型のフル指定(functionリテラル版)。------------------
const func9: (a: IHoge) =&gt; IHoge
    = function(a: IHoge): IHoge { return ({ a: 3, b: &apos;a&apos;}) }

//-------------------------以下の2つは型推論によりほぼ同じ(functionリテラル版)------------------
const func10 /**/
    = function(a: IHoge): IHoge { return ({ a: 3, b: &apos;a&apos;}) };

const func11 /**/
    = function(a: IHoge) { return ({ a: 3, b: &apos;a&apos;}) }

//-------------------------引数は型推論しないので型指定すべき(functionリテラル版)------------------
const func12 /**/
    = function(a: any/**/) : IHoge { return ({ a: 3, b: &apos;a&apos;}) }

//-------------------------以下の三つは同じ(functionリテラル版)------------------
const func13: (a: IHoge) =&gt; IHoge
    = function(a /**/) /**/ { return ({ a: 3, b: &apos;a&apos;}) }

const func14: (a: IHoge) =&gt; IHoge
    = function(a /**/): IHoge { return ({ a: 3, b: &apos;a&apos;}) }

const func15: (a: IHoge) =&gt; IHoge
    = function(a : IHoge) { return ({ a: 3, b: &apos;a&apos;}) }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;個人的おすすめはこのfunc13のパターンです。&lt;/p&gt;
&lt;p&gt;このとき、func9〜10, 13〜15の型は「&lt;code&gt;const func*: (a: IHoge) =&gt; IHoge&lt;/code&gt;」です。(functionではない)。
func11の型は「&lt;code&gt;const func11: (a: IHoge) =&gt; { a: number; b: string; }&lt;/code&gt;」です。
func12の型は「&lt;code&gt;const func12: (a: any) =&gt; IHoge&lt;/code&gt;」です。&lt;/p&gt;
&lt;p&gt;以下はテストコード。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-TypeScript&quot;&gt;const d = {a: 3, b: &apos;abc&apos;};
const x1: number = func1(3); const y1: number = func1(d); const z1: IHoge = func1(d);
const x2: number = func2(3); const y2: number = func2(d); const z2: IHoge = func2(d);
const x3: number = func3(3); const y3: number = func3(d); const z3: IHoge = func3(d);
const x4: number = func4(3); const y4: number = func4(d); const z4: IHoge = func4(d);
const x5: number = func5(3); const y5: number = func5(d); const z5: IHoge = func5(d);
const x6: number = func6(3); const y6: number = func6(d); const z6: IHoge = func6(d);
const x7: number = func7(3); const y7: number = func7(d); const z7: IHoge = func7(d);
const x8: number = func8(3); const y8: number = func8(d); const z8: IHoge = func8(d);
const x9: number = func9(3); const y9: number = func9(d); const z9: IHoge = func9(d);
const x10: number = func10(3); const y10: number = func10(d); const z10: IHoge = func10(d);
const x11: number = func11(3); const y11: number = func11(d); const z11: IHoge = func11(d);
const x12: number = func12(3); const y12: number = func12(d); const z12: IHoge = func12(d);
const x13: number = func13(3); const y13: number = func13(d); const z13: IHoge = func13(d);
const x14: number = func14(3); const y14: number = func14(d); const z14: IHoge = func14(d);
const x15: number = func15(3); const y15: number = func15(d); const z15: IHoge = func15(d);
&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt;まとめ&lt;/h1&gt;
&lt;p&gt;まとめますと、TypeScriptで関数の型定義は論理的には多種多様なパターンがありますが、個人的おすすめとして、&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-TypeScript&quot;&gt;function シンボル(引数と型指定): 戻り値型指定 {
 本体
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;か、&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-TypeScript&quot;&gt;const シンボル: (引数と型指定) =&gt; 戻り値型指定 = (引数指定) =&gt; {
 本体
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;が良いです。この2つで比べると、「=&gt;」が出てこない上の方が一見簡単です。しかし「関数をかえす関数」の場合にはいずれにせよ「=&gt;」を使わざるを得なくなります。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-TypeScript&quot;&gt;// 関数を返す関数
function シンボル(引数と型指定A): (引数と型指定B) =&gt; 戻り値型指定 {
 return (引数指定B) =&gt; { 本体 }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;language-TypeScript&quot;&gt;// 関数を返す関数
const シンボル: (引数と型指定A) =&gt; (引数と型指定B) =&gt; 戻り値型指定
 = (引数指定A) =&gt; {
 return (引数指定B) =&gt; { 本体 }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;これの各箇所で型指定を省略する、しないのパターンがあるので組み合わせ的に爆裂していき、ややこしです。&lt;/p&gt;
&lt;p&gt;このルールをわかりやすく書きたかったのですが力およばず。読むポイントは、型アノテーションがどこか、型アノテーションはどこで終るか、です。&lt;/p&gt;
&lt;p&gt;そして、型指定を、本体側でがんばるか、シンボル側でがんばるかですが、シンボル側に直接指定する型指定の部分をがんばって定義し、本体から暗黙の推論をさせないほうが、きっちりした型エラーチェックができると思います。特に、型が「関数を返す関数を…」といった複雑になる場合は、リターン型からの推論は、コードをまちがえたら終わりで、ある意味anyを使うのと同じだからです。&lt;/p&gt;
&lt;p&gt;本体側からは型を省略していく方針もあれば、「重複をおそれずに」という方針もありえます。まあそこは適当に。&lt;/p&gt;</content:encoded></item><item><title><![CDATA[Dartの変数定義時の修飾static/final/const、そしてconst constructorについて]]></title><description><![CDATA[2019/09/13追記 Dart 2.5で「 As of Dart 2.5, we support many more ways to define constant expressions, including the ability to use casts and the…]]></description><link>https://ganevru.github.io/gatsby-starter-blog-grommet/blog/7c07f019e05a743d1022/</link><guid isPermaLink="false">https://ganevru.github.io/gatsby-starter-blog-grommet/blog/7c07f019e05a743d1022/</guid><pubDate>Thu, 20 Feb 2020 15:08:12 GMT</pubDate><content:encoded>&lt;h1&gt;2019/09/13追記&lt;/h1&gt;
&lt;p&gt;&lt;a href=&quot;https://medium.com/dartlang/announcing-dart-2-5-super-charged-development-328822024970&quot;&gt;Dart 2.5&lt;/a&gt;で「 As of Dart 2.5, we support many more ways to define constant expressions, including the ability to use casts and the new control flow and collection spread features shipped in Dart 2.3:」とのことで以下が可能となりました。本文には反映していません。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Dart&quot;&gt;// Example: these are now valid compile-time constants.
const Object i = 3;
const list = [i as int];
const set = {if (list is List&amp;#x3C;int&gt;) ...list};
const map = {if (i is int) i: &quot;int&quot;};
&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt;はじめに&lt;/h1&gt;
&lt;p&gt;Dart言語における変数定義時の修飾子には&lt;a href=&quot;https://www.dartlang.org/guides/language/language-tour#final-and-const&quot;&gt;final、const&lt;/a&gt;、およびstaticがある。
final,const及び型を指定しないことを意味する「var」を指定することもできる。
本記事では、これらの変数修飾子、およびconst constructorについて説明する。&lt;/p&gt;
&lt;h1&gt;final指定&lt;/h1&gt;
&lt;p&gt;finalが指定された変数は、プログラム開始後のある時点で一回だけ初期化され、初期化以降は、代入などを通じて変更されない/できないことが保証される(再代入不可)。なお、finalな変数が「指す先」のメモリ領域の内容が変更されることについての制約はない。&lt;/p&gt;
&lt;h2&gt;finalの使用例&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&quot;language-Dart&quot;&gt;  final int i = 0;
  i = 2; // Error(再代入不可)
  final List&amp;#x3C;int&gt; a = [1,2,3];
  a[0] = 4; // OK(指す先は変更可能)
&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt;const指定&lt;/h1&gt;
&lt;p&gt;変数の値が「コンパイル時定数(compile-time constant)」であること、すなわち、コンパイル時に確定している値であることを示すための指定。constな変数の値はプログラムの実行開始に先立って初期化されており、プログラムの実行を通じて不変であることが保証される。const変数は再代入も不可である。つまり、finalの意味に加え、constな変数が指す先のメモリ領域の内容も変更不可であることを表す。&lt;/p&gt;
&lt;h2&gt;constの使用例&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&quot;language-Dart&quot;&gt;  const int i = 0;
  i = 2; // Error(再代入不可)
  const List&amp;#x3C;int&gt; a = [1,2,3]; // OK ※1
  const List&amp;#x3C;int&gt; b = const [1,2,3]; // OK(const値)
  b[0] = 4; // コンパイルエラー(指す先も変更不可)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;※1 コメント欄にてご指摘いただき修正しました。以前のDartでは配列リテラルに明示的にconstを付けないとconstなListを初期化できずコンパイルエラーだったのが、現在はコンパイルエラーにならないとのことです(むしろ付けない方が推奨)。&lt;/p&gt;
&lt;h1&gt;コンパイル時定数&lt;/h1&gt;
&lt;p&gt;const指定された変数を含み、より一般的な概念が「コンパイル時定数(compile-time constant)&lt;sup id=&quot;fnref-2&quot;&gt;&lt;a href=&quot;#fn-2&quot; class=&quot;footnote-ref&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;」である。以下はコンパイル時定数として扱うことのできる要素である。const指定する変数の値の初期化値はコンパイル時定数である必要がある。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;数値リテラル&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;例: &lt;code&gt;1.0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;例: &lt;code&gt;3&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;文字列リテラル&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;例: &lt;code&gt;&quot;abc&quot;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;boolean型リテラル&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;例: &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;false&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;const指定された定数&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;例: &lt;code&gt;myConst&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;null値&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;例: null&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;constなリストリテラル(型はListBase&amp;#x26;&amp;#x26;UnmodifiableListMixin)。当然ながら要素もコンパイル時定数である必要がある。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;例: &lt;code&gt;const [1,2,3]&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;constなマップリテラル(型は_ImmutableMap)。当然ながら要素もコンパイル時定数である必要がある。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;例: &lt;code&gt;const {&quot;a&quot;:1, &quot;b&quot;:2}&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;コンパイル時定数のみから成る演算式(の結果の値)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;例1: コンパイル時定数&lt;/li&gt;
&lt;li&gt;例: &lt;code&gt;2+3&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;例: &lt;code&gt;&quot;abc&quot;+&quot;def&quot;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;例2: const指定された定数&lt;/li&gt;
&lt;li&gt;例： &lt;code&gt;myConst1 + myConst2+5&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;例： &lt;code&gt;myConst1 &amp;#x26;&amp;#x26; myConst2&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;例3&lt;/li&gt;
&lt;li&gt;例: &lt;code&gt;3 == 4 ? &quot;a&quot; : &quot;b&quot;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;del&gt;コンパイル時定数の文字列テンプレート展開&lt;/del&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;del&gt;例: &lt;code&gt;&quot;const myConst ${myConst} is const&quot;&lt;/code&gt;&lt;/del&gt;(訂正: 文字列テンプレートはconstにならない)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;const constructor(後述)の呼び出し。const constructorに与える引数(finalフィールドに設定するための値)はコンパイル時定数である必要がある。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;例： &lt;code&gt;const ClassWithConstantConstructor(1, &quot;abc&quot;, [1,2,3])&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;関数や静的メソッドの参照&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;例:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import &apos;dart:math&apos;;
const f = min;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以下はコンパイル時定数にはならない。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;乱数値など呼び出す度に変化する値や式&lt;/li&gt;
&lt;li&gt;評価するために入出力の副作用を伴う式&lt;/li&gt;
&lt;li&gt;ランタイムにメモリ上にアロケートされる値(newで構築されるオブジェクトインスタンス)&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;値の計算に静的関数やメソッドの呼び出し結果を必要とする値&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;たとえば&lt;code&gt;const [1,2,3].length&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;たとえばリストの結合やマップの併合&lt;/li&gt;
&lt;li&gt;n回の繰り返し(たとえnがコンパイル定数であろうとも)。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;コンパイル時定数の実行時モデルとしては、ROM領域もしくは「初期化された静的定数領域」に、領域内のポインタ参照構造を含めて配置されることを想定すれば良いと思われる。&lt;/p&gt;
&lt;p&gt;全体としては、残念ながら皆が期待するところのコンパイル時プログラミングの用には供せないのではないかと思う(が定かではない)。&lt;/p&gt;
&lt;h2&gt;const constructor&lt;/h2&gt;
&lt;p&gt;前項で示した&lt;a href=&quot;https://www.dartlang.org/guides/language/language-tour#constant-constructors&quot;&gt;const constructorの呼び出し&lt;/a&gt;は、以下のようにconst constructorが定義されたクラス定義を前提とした例である。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-dart&quot;&gt;class ClassWithConstantConstructor{
  final int n;
  final String s;
  final List l;
  const ClassWithConstantConstructor(this.n, this.s, this.l); // const constructor
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;const constructorは通常のコンストラクタとは異なり、ボディを持つことができない。
前項の例でも示したように、const constructorの呼び出しは通常のコンストラクタ呼び出しで使用するnewの代りにconstキーワードを使用する。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-dart&quot;&gt;var x = const ClassWithConstantConstructor()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;del&gt;クラスには、const constructorと通常のconstructorの両方を定義することもできる。
Dart2ではインスタンス生成のためのキーワードnew、constが省略できるが、constの文脈ではconst constructorが、非constの文脈では通常のconstructorが呼び出される。&lt;/del&gt;(訂正)クラスには、同一名のconst constructorと通常のconstructorの両方を定義することはできない(重複定義となり構文エラーとなる)。一方を名前付きコンストラクタにする、異なる名前の名前つきコンストラクタにするなどすれば、1つのクラスが通常のconstructorとconst constructorの両方を持つことができる。&lt;/p&gt;
&lt;p&gt;const constructorを使うことで、「コンパイル時に定まるDAG構造&lt;sup id=&quot;fnref-1&quot;&gt;&lt;a href=&quot;#fn-1&quot; class=&quot;footnote-ref&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;」のリテラルを表現することができる。
なお、構造をもったコンパイル時定数(DAG構造、リスト、マップを含め)一般に、これらの構造はinternされる。すなわち値や構造が一致していればオブジェクトインスタンスが一致していることが保証される。&lt;/p&gt;
&lt;p&gt;internされることは、コンパイル時定数がswitch-case文のcase節に利用できることに関連して重要である。&lt;/p&gt;
&lt;h2&gt;const constructorの例&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&quot;language-dart&quot;&gt;class Cons {
  final dynamic car;
  final Cons cdr;
  const Cons(this.car, [this.cdr=null]);
  @override
  String toString() =&gt;
     &quot;(${this.car} . ${this.cdr == null ? &quot;nil&quot; : this.cdr.toString()})&quot;;

}

main() {
  const Cons list1 = Cons(1, Cons(2));
  const Cons list2 = Cons(list1, Cons(list1));
  const Cons list3 = Cons(Cons(1, Cons(2)), Cons(Cons(1, Cons(2))));

  print(list2); // ((1 . (2 . nil)) . ((1 . (2 . nil)) . nil))
  print(list3); // ((1 . (2 . nil)) . ((1 . (2 . nil)) . nil))
  print(list2 == list3); // 値が等しいのでtrueが表示される。
  print(identical(list2, list3)); // オブジェクトが等しいのでtrueが表示される(internされている)。
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt;constとfinalの違い&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;finalは&lt;strong&gt;&lt;em&gt;変数の性質&lt;/em&gt;&lt;/strong&gt;なので、「final変数に代入できない」など、代入の左辺になったときの&lt;strong&gt;&lt;em&gt;変数としての扱い&lt;/em&gt;&lt;/strong&gt;について差異が生じる。しかし、final変数の保持する&lt;strong&gt;&lt;em&gt;値&lt;/em&gt;&lt;/strong&gt;には影響を与えない。たとえば、「〜には、final変数の&lt;strong&gt;&lt;em&gt;値を&lt;/em&gt;&lt;/strong&gt;代入できない(orできる)」「〜の場合の引数には、final変数の&lt;strong&gt;&lt;em&gt;値を&lt;/em&gt;&lt;/strong&gt;渡せない」といったfinal指定起因の&lt;strong&gt;&lt;em&gt;値&lt;/em&gt;&lt;/strong&gt;に対する制約はない。&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;constは&lt;strong&gt;&lt;em&gt;変数の性質&lt;/em&gt;&lt;/strong&gt;でもあることに加えて、const変数が保持する&lt;strong&gt;&lt;em&gt;値の性質&lt;/em&gt;&lt;/strong&gt;も規定している(つまり値は「コンパイル時定数」であることを意味している)ので、const変数の&lt;strong&gt;&lt;em&gt;値を&lt;/em&gt;&lt;/strong&gt;他の変数に代入したり、関数の引数として&lt;strong&gt;&lt;em&gt;値を&lt;/em&gt;&lt;/strong&gt;渡したりするときに、constが付く・付かないで制約回避できる・できないといった差異が生じる場合がある。たとえば、以下の状況に使用できるのはコンパイル時定数のみである。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;const変数に代入&lt;/li&gt;
&lt;li&gt;省略可能パラメタのデフォルト値&lt;/li&gt;
&lt;li&gt;switch case文のcase節の式&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;static指定&lt;/h1&gt;
&lt;p&gt;クラスのフィールド変数に指定し、その変数がインスタンスごとに保持されるのではなく、クラスで1つの実体を持つことを宣言する。&lt;/p&gt;
&lt;p&gt;なお、Dart言語では関数ローカルなstatic変数や、関数の外側でのstatic指定は文法上使用できず、クラススコープのstaticのみが文法上許されている。CやC++における、名前空間のコントロールのためのstaticや、C/C++/Javaにおける「可視範囲は関数ローカルだが生存期間はグローバルであることを意味するstatic」はDartでは使用できない。&lt;/p&gt;
&lt;h2&gt;staticの例&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&quot;language-Dart&quot;&gt;class Test {
  static int i1;
  static var i2;
  static final int i3 = 3;
  static const int i4 = 4;
}
static int i5;  // Error
main() {
  static int i6; // Error
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt;(余談)Dartでの可視性の制御&lt;/h1&gt;
&lt;p&gt;前節で示したように、C/C++における「モジュールローカル」を意味するstaticの用法はDartには無い。Dartでのモジュール(ライブラリ)ローカルの指定は、大域変数の変数名をアンダースコア(下線, ’_‘)で始めることで実現される。同様に、可視性をクラス内に限定するためにはフィールドやメソッド名をアンダースコアで開始する。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Dart&quot;&gt;final int _modulePrivate = 0; // 他モジュールに公開されない変数

class _SomeClass { // 他モジュールに公開されないクラス
  int _num;  // クラス外から不可視なフィールド
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt;変数の初期化タイミング&lt;/h1&gt;
&lt;p&gt;ローカル変数は、関数が呼びだされ、その変数が宣言されているブロックに処理が入った時点で値が初期値指定があれば、その値で初期化される。この事はfinal、const、varを通じて同じである。ただし、constなローカル変数の初期化式はコンパイル時定数であることが必要である。&lt;/p&gt;
&lt;p&gt;初期化式を伴なって宣言されたconstではない大域変数、クラス変数(static変数)は、その変数の&lt;strong&gt;&lt;em&gt;初回参照時&lt;/em&gt;&lt;/strong&gt;に初期化式が評価され、値が確定する(Lazyな初期化)。constとは異なり、任意の初期化式が指定可能である。&lt;/p&gt;
&lt;p&gt;初期化指定のある大域変数やクラス変数を&lt;strong&gt;&lt;em&gt;初回参照する前&lt;/em&gt;&lt;/strong&gt;に代入したとき、初期化式は評価されず、代入する値に設定される。このことは直感的ではないかもしれないので再度強調しておくと、&lt;strong&gt;初期化式を伴なって宣言された大域変数やstatic変数を「参照する前に代入する」と、初期化がスキップされる。初期化式が関数呼び出しを含むのであれば、それは実行されない&lt;/strong&gt;ということである。&lt;/p&gt;
&lt;h1&gt;表にまとめると&lt;/h1&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align: left&quot;&gt;指定&lt;/th&gt;
&lt;th style=&quot;text-align: left&quot;&gt;変数への再代入&lt;/th&gt;
&lt;th style=&quot;text-align: left&quot;&gt;スコープ&lt;/th&gt;
&lt;th style=&quot;text-align: left&quot;&gt;変数値の設定タイミング&lt;/th&gt;
&lt;th style=&quot;text-align: left&quot;&gt;初期化/代入できる値&lt;/th&gt;
&lt;th style=&quot;text-align: left&quot;&gt;変数の指す先の破壊的変更&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align: left&quot; rowspan=&quot;3&quot;&gt;varもしくはなし&lt;/td&gt;
&lt;td style=&quot;text-align: left&quot; rowspan=&quot;3&quot;&gt;可&lt;/td&gt;
&lt;td style=&quot;text-align: left&quot;&gt;大域&lt;/td&gt;
&lt;td style=&quot;text-align: left&quot;&gt;初回参照時(Lazy)か代入時&lt;/td&gt;
&lt;td style=&quot;text-align: left&quot; rowspan=&quot;3&quot;&gt;任意&lt;/td&gt;
&lt;td style=&quot;text-align: left&quot; rowspan=&quot;3&quot;&gt;可&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align: left&quot;&gt;ローカル&lt;/td&gt;
&lt;td style=&quot;text-align: left&quot;&gt;初期化&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align: left&quot;&gt;クラス&lt;/td&gt;
&lt;td style=&quot;text-align: left&quot;&gt;コンストラクタでの初期化時、代入時&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align: left&quot; rowspan=&quot;3&quot;&gt;final&lt;/td&gt;
&lt;td style=&quot;text-align: left&quot; rowspan=&quot;3&quot;&gt;不可&lt;/td&gt;
&lt;td style=&quot;text-align: left&quot;&gt;大域&lt;/td&gt;
&lt;td style=&quot;text-align: left&quot;&gt;初回参照時(Lazy)&lt;/td&gt;
&lt;td style=&quot;text-align: left&quot; rowspan=&quot;3&quot;&gt;任意&lt;/td&gt;
&lt;td style=&quot;text-align: left&quot; rowspan=&quot;3&quot;&gt;可&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align: left&quot;&gt;ローカル&lt;/td&gt;
&lt;td style=&quot;text-align: left&quot;&gt;初期化時&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align: left&quot;&gt;クラス&lt;/td&gt;
&lt;td style=&quot;text-align: left&quot;&gt;コンストラクタでの初期化時&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align: left&quot; rowspan=&quot;2&quot;&gt;const&lt;/td&gt;
&lt;td style=&quot;text-align: left&quot; rowspan=&quot;2&quot;&gt;不可&lt;/td&gt;
&lt;td style=&quot;text-align: left&quot;&gt;大域&lt;/td&gt;
&lt;td style=&quot;text-align: left&quot; rowspan=&quot;2&quot;&gt;コンパイル時に確定&lt;/td&gt;
&lt;td style=&quot;text-align: left&quot; rowspan=&quot;2&quot;&gt;コンパイル時定数式&lt;/td&gt;
&lt;td style=&quot;text-align: left&quot; rowspan=&quot;2&quot;&gt;不可&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align: left&quot;&gt;ローカル&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align: left&quot;&gt;static var(あるいは単にstatic)&lt;/td&gt;
&lt;td style=&quot;text-align: left&quot;&gt;可&lt;/td&gt;
&lt;td style=&quot;text-align: left&quot; rowspan=&quot;3&quot;&gt;クラス&lt;/td&gt;
&lt;td style=&quot;text-align: left&quot;&gt;初回参照時(Lazy)か代入時&lt;/td&gt;
&lt;td style=&quot;text-align: left&quot; rowspan=&quot;2&quot;&gt;任意&lt;/td&gt;
&lt;td style=&quot;text-align: left&quot; rowspan=&quot;2&quot;&gt;可&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align: left&quot;&gt;static final&lt;/td&gt;
&lt;td style=&quot;text-align: left&quot;&gt;不可&lt;/td&gt;
&lt;td style=&quot;text-align: left&quot;&gt;初回参照時(Lazy)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align: left&quot;&gt;static const&lt;/td&gt;
&lt;td style=&quot;text-align: left&quot;&gt;不可&lt;/td&gt;
&lt;td style=&quot;text-align: left&quot;&gt;コンパイル時に確定&lt;/td&gt;
&lt;td style=&quot;text-align: left&quot;&gt;コンパイル時定数式&lt;/td&gt;
&lt;td style=&quot;text-align: left&quot;&gt;不可&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;!--
|指定|変数への再代入|スコープ|変数値の設定タイミング|初期化/代入できる値|変数の指す先の破壊的変更|
|:-- |:-- |:--|:--|:--|:--|:--|
|varもしくはなし|可|大域|初回参照時(Lazy)か代入時|任意|可|
|||ローカル|初期化時|||
|||クラス[*1]|コンストラクタでの初期化時、代入時|||
|final|不可|大域|初回参照時(Lazy)|任意|可|
|||ローカル|初期化時|||
|||クラス[*1]|コンストラクタでの初期化時|||
|const|不可|大域|コンパイル時に確定|コンパイル時定数式|不可
|||ローカル||||
|static var(あるいは単にstatic)|可|クラス|初回参照時(Lazy)か代入時|任意|可
|static final|不可||初回参照時(Lazy)|||
|static const|不可||コンパイル時に確定|コンパイル時定数式|不可|
--&gt;
&lt;ul&gt;
&lt;li&gt;スコープが「クラス」は、クラスのフィールドとして定義される変数の意。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;footnotes&quot;&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id=&quot;fn-2&quot;&gt;
&lt;p&gt;「const値」でも通じると思われる。&lt;/p&gt;
&lt;a href=&quot;#fnref-2&quot; class=&quot;footnote-backref&quot;&gt;↩&lt;/a&gt;
&lt;/li&gt;
&lt;li id=&quot;fn-1&quot;&gt;
&lt;p&gt;枝を共有できるので(次に例を示す)、ツリー以外のDAGも表現できる。なお、循環構造は表現できないようである(確信はないけど。もしできるのであれば教えて欲しい)。&lt;/p&gt;
&lt;a href=&quot;#fnref-1&quot; class=&quot;footnote-backref&quot;&gt;↩&lt;/a&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</content:encoded></item><item><title><![CDATA[第28回 オフラインリアルタイムどう書くの問題「十字の壁がそそり立つ世界の中を君は螺旋状に歩く」をRustで解く]]></title><description><![CDATA[第28回 オフラインリアルタイムどう書くの問題「十字の壁がそそり立つ世界の中を君は螺旋状に歩く」を、Rust(2015-02-22 nightly)で解きました。 u32だったのをu64にして、末尾再帰をloop…]]></description><link>https://ganevru.github.io/gatsby-starter-blog-grommet/blog/7de2d1b0fb2aabf2f27d/</link><guid isPermaLink="false">https://ganevru.github.io/gatsby-starter-blog-grommet/blog/7de2d1b0fb2aabf2f27d/</guid><pubDate>Thu, 20 Feb 2020 15:08:12 GMT</pubDate><content:encoded>&lt;p&gt;&lt;a href=&quot;http://qiita.com/Nabetani/items/ce3b4f8a34de8987c6bc&quot;&gt;第28回 オフラインリアルタイムどう書くの問題「十字の壁がそそり立つ世界の中を君は螺旋状に歩く」&lt;/a&gt;を、Rust(2015-02-22 nightly)で解きました。&lt;/p&gt;
&lt;p&gt;u32だったのをu64にして、末尾再帰をloopに置き換えただけで、追加問題も難なく実行できました。&lt;/p&gt;
&lt;h1&gt;感想&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;このレベル(並列なし、Owned Pointerなし、traitなし)だと、Rustは単に「すばらしいC言語」。何もデメリットがない。C言語経験者だったら、単に楽しく便利なだけ。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Boxとか駆使してライフタイムがごにょり始めると、コンパイルエラーを乗り越えるための苦痛が予想される…&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Rustは関数型プログラミングと相性が悪いと思う。&amp;#x26;mutとかとどう折り合いつけるの? 逆に&amp;#x26;mutを避けたいなら、Rust使う意味あんの？&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;コード&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;#![allow(unused_variables)]
#![allow(dead_code)]

static DIREC_STR:[&amp;#x26;&apos;static str;4] = [&quot;E&quot;, &quot;S&quot;, &quot;W&quot;, &quot;N&quot;];
static TURN_RIGHT:i32 = 1;
static TURN_LEFT:i32 = -1;
static FORWARD:i32 = 0;

#[derive(Debug)]
struct Segment {
    steps: u64,
    next_direc: i32
}

impl Segment {
    fn new(steps: u64, next_direc: i32) -&gt; Segment {
        Segment { next_direc:next_direc, steps:steps }
    }
}

#[derive(Debug)]
struct You {
    pos: u64,
    direc: u32
}

fn trace_segment_and_turn(day_of_answer:u64, segment: &amp;#x26;Segment, you: &amp;#x26;mut You)
{
    if day_of_answer &amp;#x3C; you.pos + (*segment).steps  {
        you.pos = day_of_answer;
        return;
    }
    you.pos += (*segment).steps;
    you.direc = ((you.direc as i32+(*segment).next_direc + 4) % 4) as u32;
}

fn create_segments(n:u64, e:u64, s:u64, w:u64, wall_thickness: u64) -&gt; Vec&amp;#x3C;Segment&gt;
{
    let mut segments = vec![
        Segment::new(e,              TURN_RIGHT),
        Segment::new(wall_thickness, TURN_RIGHT),
        Segment::new(e,              TURN_LEFT),
        Segment::new(s,              TURN_RIGHT),
        Segment::new(wall_thickness, TURN_RIGHT),
        Segment::new(s,              TURN_LEFT),
        Segment::new(w,              TURN_RIGHT),
        Segment::new(wall_thickness, TURN_RIGHT),
        Segment::new(w,              TURN_LEFT),
        Segment::new(n,              TURN_RIGHT)];
    if n &gt; 1 {
        segments.push(Segment::new(wall_thickness, TURN_RIGHT));
        segments.push(Segment::new(n-1,   TURN_LEFT));
    } else {
        segments.push(Segment::new(wall_thickness, FORWARD));
    }
    segments
}

fn trace_path(day_of_answer:u64, you: &amp;#x26;mut You,
              n:u64, e:u64, s:u64, w:u64, mut wall_thickness: u64) {
    loop {
        for segment in create_segments(n, e, s, w, wall_thickness).iter() {
            trace_segment_and_turn(day_of_answer, segment, you);
            if you.pos &gt;= day_of_answer { return; }
        }
        you.pos += 1;
        wall_thickness += 2;
    }
}

fn solve(e:u64, s:u64, w:u64, n:u64, day_of_answer:u64) -&gt; &amp;#x26;&apos;static str {
    let mut you = You {pos:0, direc:0};
    trace_path(day_of_answer, &amp;#x26;mut you, e, s, w, n, 2);
    return DIREC_STR[you.direc as usize]
}

fn test(e:u64, s:u64, w:u64, n:u64, day_of_answer:u64, expected:&amp;#x26;str) {
    assert_eq!(solve(e, s, w, n, day_of_answer), expected);
}

#[test]
fn test_case() {
    /*0*/ test( 2, 3, 5, 4, 85, &quot;S&quot; );
    /*1*/ test( 1, 2, 3, 4, 1, &quot;E&quot; );
    /*2*/ test( 1, 2, 3, 4, 2, &quot;S&quot; );
    /*3*/ test( 1, 2, 3, 4, 3, &quot;S&quot; );
    /*4*/ test( 1, 2, 3, 4, 4, &quot;W&quot; );
    test( 2, 3, 5, 4,  85, &quot;S&quot;);
    test( 1, 2, 3, 4,  1, &quot;E&quot;);
    test( 1, 2, 3, 4,  2, &quot;S&quot;);
    test( 1, 2, 3, 4,  3, &quot;S&quot;);
    test( 1, 2, 3, 4,  4, &quot;W&quot;);
    test( 1, 2, 3, 4,  27, &quot;E&quot;);
    test( 1, 2, 3, 4,  63, &quot;E&quot;);
    test( 1, 2, 3, 4,  40, &quot;W&quot;);
    test( 1, 4, 3, 2,  40, &quot;S&quot;);
    test( 3, 3, 3, 3,  30, &quot;S&quot;);
    test( 3, 3, 3, 3,  31, &quot;E&quot;);
    test( 3, 3, 3, 3,  32, &quot;E&quot;);
    test( 3, 3, 3, 3,  70, &quot;S&quot;);
    test( 3, 3, 3, 3,  71, &quot;E&quot;);
    test( 3, 3, 3, 3,  72, &quot;E&quot;);
    test( 1, 1, 1, 1,  7, &quot;N&quot;);
    test( 1, 2, 1, 1,  7, &quot;W&quot;);
    test( 1, 6, 1, 1,  7, &quot;S&quot;);
    test( 1, 8, 1, 1,  7, &quot;E&quot;);
    test( 1, 1, 1, 1,  30, &quot;N&quot;);
    test( 1, 2, 1, 1,  30, &quot;W&quot;);
    test( 1, 5, 1, 1,  30, &quot;S&quot;);
    test( 1, 8, 1, 1,  30, &quot;E&quot;);
    test( 9, 9, 9, 9,  99, &quot;W&quot;);
    test( 5, 6, 3, 8,  3, &quot;E&quot;);
    test( 5, 8, 1, 1,  11, &quot;W&quot;);
    test( 2, 8, 1, 2,  18, &quot;S&quot;);
    test( 3, 2, 3, 1,  20, &quot;N&quot;);
    test( 3, 3, 8, 1,  28, &quot;N&quot;);
    test( 2, 5, 1, 2,  32, &quot;E&quot;);
    test( 2, 5, 1, 6,  33, &quot;E&quot;);
    test( 1, 2, 5, 7,  34, &quot;N&quot;);
    test( 3, 6, 5, 6,  36, &quot;E&quot;);
    test( 6, 2, 8, 1,  39, &quot;S&quot;);
    test( 3, 1, 2, 3,  41, &quot;W&quot;);
    test( 1, 1, 3, 4,  45, &quot;W&quot;);
    test( 1, 3, 1, 2,  46, &quot;N&quot;);
    test( 4, 4, 4, 4,  49, &quot;W&quot;);
    test( 3, 1, 4, 4,  55, &quot;N&quot;);
    test( 6, 6, 2, 1,  56, &quot;W&quot;);
    test( 3, 2, 1, 2,  59, &quot;S&quot;);
    test( 2, 7, 7, 1,  60, &quot;S&quot;);
    test( 3, 1, 1, 1,  63, &quot;N&quot;);
    test( 4, 6, 4, 1,  78, &quot;E&quot;);
    test( 7, 5, 3, 6,  79, &quot;W&quot;);
    test( 7, 8, 3, 1,  81, &quot;E&quot;);
    test( 3, 2, 5, 2,  82, &quot;S&quot;);
    test( 1, 1, 3, 4,  84, &quot;N&quot;);
    test( 7, 4, 1, 5,  88, &quot;S&quot;);
    test( 3, 6, 5, 3,  89, &quot;S&quot;);
    test( 1, 4, 2, 3,  92, &quot;N&quot;);
    test( 1, 3, 4, 5,  93, &quot;W&quot;);
    test( 2, 4, 8, 1,  94, &quot;W&quot;);
    test( 3, 6, 1, 7,  99, &quot;S&quot;);
}

fn main() {
    assert_eq!(solve(1234, 2345, 3456, 4567, 978593417), &quot;E&quot;);
    assert_eq!(solve(1234, 2345, 3456, 4567, 978593418), &quot;S&quot;);
    assert_eq!(solve(31415, 92653, 58979, 32384, 9812336139), &quot;W&quot;);
    assert_eq!(solve(31415, 92653, 58979, 32384, 9812336140), &quot;S&quot;);
    assert_eq!(solve(314159, 265358, 979323, 84626, 89099331642), &quot;S&quot;);
    assert_eq!(solve(314159, 265358, 979323, 84626, 89099331643), &quot;W&quot;);
}
&lt;/code&gt;&lt;/pre&gt;</content:encoded></item><item><title><![CDATA[第13回オフラインリアルタイムどう書くの参考問題をFregeで解く]]></title><description><![CDATA[第13回 オフラインリアルタイムどう書くの参考問題「増やす減らす二倍する」を、JVM上で動作するHaskellライクな言語Frege(フレーゲ)で解きました。]]></description><link>https://ganevru.github.io/gatsby-starter-blog-grommet/blog/944cd9903c3827f1d1bc/</link><guid isPermaLink="false">https://ganevru.github.io/gatsby-starter-blog-grommet/blog/944cd9903c3827f1d1bc/</guid><pubDate>Thu, 20 Feb 2020 15:08:12 GMT</pubDate><content:encoded>&lt;p&gt;&lt;a href=&quot;http://atnd.org/events/41603&quot;&gt;第13回 オフラインリアルタイムどう書く&lt;/a&gt;の参考問題「&lt;a href=&quot;http://nabetani.sakura.ne.jp/hena/ord13updowndouble/&quot;&gt;増やす減らす二倍する&lt;/a&gt;」を、JVM上で動作するHaskellライクな言語&lt;a href=&quot;https://github.com/Frege/frege/wiki/_pages&quot;&gt;Frege&lt;/a&gt;(フレーゲ)で解きました。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-frege:shortest.fr&quot;&gt;shortestPath&apos; :: Int -&gt; Int -&gt; Int
shortestPath&apos; n maxn
  | n==0 = 0
  | n==1 = 1
  | n &gt; maxn = maxBound::Int
  | even(n) = (shortestPath&apos; (n `div` 2) (maxn-2)) + 1
  | otherwise = minimum [(shortestPath&apos; (n-1) (maxn-2)) + 1, (shortestPath&apos; (n+1) (maxn-2)) + 1]

shortestPath :: Int -&gt; Int  
shortestPath n = shortestPath&apos; n (n*2)
  

main args = do
  println (shortestPath 59 ==  9)
  println (shortestPath 10 ==  5)
  println (shortestPath 11 ==  6)
  println (shortestPath 12 ==  5)
  println (shortestPath 13 ==  6)
  println (shortestPath 14 ==  6)
  println (shortestPath 15 ==  6)
  println (shortestPath 16 ==  5)
  println (shortestPath 17 ==  6)
  println (shortestPath 18 ==  6)
  println (shortestPath 27 ==  8)
  println (shortestPath 28 ==  7)
  println (shortestPath 29 ==  8)
  println (shortestPath 30 ==  7)
  println (shortestPath 31 ==  7)
  println (shortestPath 32 ==  6)
  println (shortestPath 33 ==  7)
  println (shortestPath 34 ==  7)
  println (shortestPath 35 ==  8)
  println (shortestPath 41 ==  8)
  println (shortestPath 71 ==  9)
  println (shortestPath 1023 ==  12)
  println (shortestPath 1024 ==  11)
  println (shortestPath 1025 ==  12)
  println (shortestPath 1707 ==  17)
  println (shortestPath 683 ==  15)
  println (shortestPath 123 ==  10)
  println (shortestPath 187 ==  11)
  println (shortestPath 237 ==  12)
  println (shortestPath 5267 ==  18)
  println (shortestPath 6737 ==  18)
  println (shortestPath 14796 ==  20)
  println (shortestPath 18998 ==  20)
  println (shortestPath 23820 ==  20)
  println (shortestPath 30380 ==  21)
  println (shortestPath 31119 ==  21)
  println (shortestPath 33301 ==  20)
  println (shortestPath 33967 ==  21)
  println (shortestPath 35443 ==  22)
  println (shortestPath 35641 ==  22)
  println (shortestPath 43695 ==  23)
  println (shortestPath 44395 ==  23)
  println (shortestPath 44666 ==  22)
  println (shortestPath 987 ==  14)
  println (shortestPath 1021 ==  13)
  println (shortestPath 1019 ==  13)
  println (shortestPath 1015 ==  13)
  println (shortestPath 1007 ==  13)
  println (shortestPath 1011 ==  14)
  println (shortestPath 1003 ==  14)
  println (shortestPath 983 ==  14)
  println (shortestPath 999 ==  14)
  println (shortestPath 2731 ==  18)
  println (shortestPath 6827 ==  20)
  println (shortestPath 10923 ==  21)
  println (shortestPath 27307 ==  23)
  println (shortestPath 43691 ==  24)
  println (shortestPath 109227 ==  26)
  println (shortestPath 174763 ==  27)
  
&lt;/code&gt;&lt;/pre&gt;</content:encoded></item><item><title><![CDATA[React HooksのuseCallbackを正しく理解する]]></title><description><![CDATA[はじめに React HooksのuseCallback…]]></description><link>https://ganevru.github.io/gatsby-starter-blog-grommet/blog/99f7cd014e2c0fa1fc4e/</link><guid isPermaLink="false">https://ganevru.github.io/gatsby-starter-blog-grommet/blog/99f7cd014e2c0fa1fc4e/</guid><pubDate>Thu, 20 Feb 2020 15:08:12 GMT</pubDate><content:encoded>&lt;h1&gt;はじめに&lt;/h1&gt;
&lt;p&gt;React HooksのuseCallbackは、イベントハンドラ(コールバック)を使うときは無条件に使うものだと思っていませんか。実際にはコールバックが「ある条件をみたす」ときに使うべきもののようです。このある条件を整理して明確にするために記事を書きました。&lt;/p&gt;
&lt;h1&gt;useCallbackとは何か&lt;/h1&gt;
&lt;p&gt;useCallbackは、useMemoのような、重い計算を回避しキャッシュを使うというような効率向上のための仕組みではありません。useCallbackに渡す関数内で行なう計算の重さはまったく無関係です。
useCallbackがやることは、「コールバック関数の不変値化」です。&lt;/p&gt;
&lt;p&gt;「関数を決定する処理のメモ化」と言えるかもしれません。アロー式は原理的に常に新規関数オブジェクトを作ってしまいますが、useCallbackは「意味的に同じ関数」が返るかどうかを判別して、同じ値を返す関数が返るべきなら新規のアロー式を捨てて、前に渡した同じ結果を返す関数を使い回しで返します。&lt;/p&gt;
&lt;p&gt;同じ値を返す関数なのに、異なる実体関数をpropsに渡すと無駄なrenderが走ってしまうので、「一回useCallbackをくぐらせる」ことで一意化し、引き起こされるかもしれない無駄なレンダリングを抑制することができます。&lt;/p&gt;
&lt;p&gt;関数が純粋であれば、引数が同じなら常に同じ値を返すはずだから毎回「くぐらせる」必要なんかなくて、保存していた前の値を常にかえせばいいのでは、と思うかもしれませんが、関数がクロージャとして変数をキャプチャしているとそうはいかず、「同じ引数なのに異なる値を返す」ということがありうるのです。クロージャがキャプチャしている変数は、追加的な暗黙の引数なのです。なのでキャプチャしていて、結果に影響を及ぼす変数の値を考慮するために、それらを依存変数として渡して判別を行います。&lt;/p&gt;
&lt;h2&gt;コールバック関数の不変値化とは何か&lt;/h2&gt;
&lt;p&gt;ローカル関数がローカル変数などをキャプチャするというのは実質的にはそのローカル関数の引数なのですが、useCallbackがやってくれることは、ローカル関数と、そのローカル関数がキャプチャする変数列を依存変数として与えて呼び出すと、依存引数の値と関数本体をあわせてinternし、不変値化することです。Immutable.jsの提供する不変データと同じように、その結果を使うことでpropsとして関数を使う場合のシャロー比較がうまくいきます。&lt;/p&gt;
&lt;p&gt;その結果として、その渡したコンポーネントが以下の条件を満す場合、不要な画面更新が減ります。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;React.memo()されている場合&lt;/li&gt;
&lt;li&gt;クラスコンポーネントでshouldComponentUpdate()でpropsをシャロー比較して同じならスキップしている場合&lt;/li&gt;
&lt;li&gt;クラスコンポーネントでPureComponentから継承した場合に相当)場合&lt;/li&gt;
&lt;li&gt;react-reduxのconnectを使ったSmartコンポーネント&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;基本の整理&lt;/h1&gt;
&lt;p&gt;useCallback Hookは以下の形で呼び出します。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-JavaScript&quot;&gt;const callback = useCallback(関数, [deps])
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ここで関数にアロー式をあたえたとします。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-JavaScript&quot;&gt;const Component = () =&gt; {
  const callback = useCallback(()=&gt;{処理}, [deps])
    :
  return &amp;#x3C;Hoge onHoge={callback} /&gt;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;JavaScriptの言語仕様上、renderごとに常にアロー関数の生成式「()=&gt;{処理}」が評価されて新たな関数オブジェクトがつくられます(アロー関数のボディは評価されるわけではない)。アロー式が関数引数である場合、たとえばuseCallbackの引数である場合にしても同じです。引数として評価されたときに、&lt;strong&gt;常に新しく関数オブジェクトが作られます&lt;/strong&gt;。useCallback側で処理の選択肢があるのは、その関数値を捨てるか、次の呼び出しで返すまえにとっとくかだけです。&lt;/p&gt;
&lt;p&gt;なので、このComponentのrender時に毎回関数オブジェクトを作らせないためには、関数本体の外側に移動して&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-JavaScript&quot;&gt;const handlerFunc = ()=&gt;{処理}
const Component = () =&gt; {
    :
  return &amp;#x3C;Hoge onHoge={handlerFunc} /&gt;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;とするしかありません。こうすると、&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;利点1.&lt;/strong&gt; 関数オブジェクトの生成を抑制する&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;利点2.&lt;/strong&gt; Hogeが「propsがシャロー比較の意味で変化しなければrenderを呼ばない」という最適化されたコンポーネント(Rect.memo化されたコンポーネントやPureComponent)であったときに効率が良い&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;という2点で効率が高いです。&lt;/p&gt;
&lt;h1&gt;何が問題か&lt;/h1&gt;
&lt;p&gt;問題は、イベントハンドラを関数コンポーネントの外側に外出しできるのは、そのハンドラ本体の処理が、propsなどの関数引数(=ローカルスコープ)や、useStateなどで得られるローカル変数としてのstateを使用しないで実行できる場合のみだということです。それらへのアクセスが必要な場合は非常に多いので、無視することはできません。&lt;/p&gt;
&lt;p&gt;なので、ローカル関数にする場合が多くなるでしょう。しかし、ローカル関数は、render時点でのローカル変数をキャプチャしてしまう&lt;sup id=&quot;fnref-1&quot;&gt;&lt;a href=&quot;#fn-1&quot; class=&quot;footnote-ref&quot;&gt;1&lt;/a&gt;&lt;/sup&gt; ので、へたに保存して使いまわそうとすると、一般に非同期に呼び出されるイベントハンドラでは、そのキャプチャ元の変数の最新の値を使って処理できない、という問題があります。使いまわさなければいいんですけどね。使いまわしたくなる事情もあるのです。
&lt;sup id=&quot;fnref-1&quot;&gt;&lt;a href=&quot;#fn-1&quot; class=&quot;footnote-ref&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;: &lt;a href=&quot;https://overreacted.io/ja/how-are-function-components-different-from-classes/&quot;&gt;https://overreacted.io/ja/how-are-function-components-different-from-classes/&lt;/a&gt;&lt;/p&gt;
&lt;h1&gt;問題回避策&lt;/h1&gt;
&lt;h2&gt;問題回避策1&lt;/h2&gt;
&lt;p&gt;先ほど、ローカル関数がローカル変数をキャプチャしてしまうことが問題の一環だと述べました。useStateの返り値もローカル変数であり、この問題をかかえます。しかしuseStateを上手く使うことでイベントハンドラでのキャプチャを回避できる場合があります。&lt;/p&gt;
&lt;p&gt;この状況を説明します。
useState Hooksの返り値の配列(タプル)第二要素のいわゆるsetter関数が得られます。たとえば、&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-JavaScript&quot;&gt;const Component = () =&gt; {
  const [counter, setCounter] = useState(0);
    :
  return &amp;#x3C;Hoge onHoge={setCounter} /&gt;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ここでのsetCounterがsetter関数です。setter関数には通常は新しいstateの値を渡しますが、値ではなく関数を渡すこともでき、たとえば以下のように使えます。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-JavaScript&quot;&gt;setCounter((oldCounter)=&gt;(oldCounter + 1)) // counterを1増加させる。
// setCounter(counter + 1)と同じだがcounterをキャプチャしない。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;こちらを使ってstateをローカル関数経由ではなくsetStateの引数からもらうようにすれば、ローカル変数としてのcounterはキャプチャしないので、「古い値」問題はおきません。
上の場合、setCounter自体もuseStateの返り値なのでローカル変数じゃないかと思うかもしれませんが、Hooksのしくみ的にはsetCounter自体はコンポーネントごとに一意で、複数回のuseStateでも同じ関数が得られますのでキャプチャ問題は起きません。&lt;/p&gt;
&lt;h2&gt;問題回避策2&lt;/h2&gt;
&lt;p&gt;useStateが返すsetCounter関数はローカルスコープにある変数や引数(具体的にはprops引数)に依存しないので、useCllbackに包まずにHogeのonHogeに直接わたしても効率は劣化しませんし問題も起きません。そのsetterを渡した側で、回避策1の方式でstateの値を参照することもできます。&lt;/p&gt;
&lt;p&gt;もっともこれは個々の変数レベルのsetter操作なので、「いくつかの変数に対するロジック、操作」を、自コンポーネントでまとめてイベントハンドラに渡すためには関数にする必要があり、コールバック関数を定義する必要がでてきます。&lt;/p&gt;
&lt;h2&gt;問題回避策3&lt;/h2&gt;
&lt;p&gt;useReducerを使い、イベントハンドラ用途ではdispatchをprops経由で渡します。&lt;/p&gt;
&lt;h2&gt;問題回避策4&lt;/h2&gt;
&lt;p&gt;react-reduxを使い、イベントハンドラをpropsとしてはバケツリレーせず、イベントを検出する直下のコンポーネントでuseDispatchしてアクションをdispachさせます。
これが個人的には妥当だとおもってます。react-redux 7.1のhooksベースreduxは別ものです。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://qiita.com/uehaj/items/f91d68ea4ef8450fc45c&quot;&gt;Redux Starter KitでHooksとReduxを使いこなそう
&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;useCallbackを使うかどうかの判断&lt;/h1&gt;
&lt;p&gt;さて、いずれの回避策も適用できない、もしくはしたくないとして、いよいよuseCallbackを使うかどうかの判断しなければなりません。&lt;/p&gt;
&lt;h2&gt;ケース1「利点1」を得たい場合(自動的に「利点2」も得られる)&lt;/h2&gt;
&lt;p&gt;「利点1」のために、不変のイベントハンドラを定義することが必要であり、state, props, ローカル変数を直接参照する必要がないなら以下が可能です。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-JavaScript&quot;&gt;const handleHoge = () =&gt; {propsやstateを使わない処理}
const Component = (props) =&gt; {
  return &amp;#x3C;Hoge onHoge={handleHoge} /&gt;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;ケース2-1「利点1」をあきらめるが、「利点2」を得たい場合&lt;/h2&gt;
&lt;p&gt;state, props, ローカル変数を参照する必要があり、かつその変更にもかかわらず同じ関数を得たいなら、それらを間接的に参照するように関数を作りこむことになります。ある意味、クラスコンポーネントのthisをエミュレーションし、それを通じてpropsアクセスするようにします。&lt;/p&gt;
&lt;p&gt;具体的には、useRefなどを使ってstateやpropsの値をコピーしておき、それをつかった処理をする関数を保存して渡します。propsなどをrender時に毎回そのrefに保存するようにすればよいわけです。&lt;/p&gt;
&lt;p&gt;useCallbackの依存変数指定にたよらず(指定を間違えるかもしれない! 依存変数はあとで増えるかもしれない!)、propsのみを信じ、そこを直接使います。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-JavaScript&quot;&gt;// 試してない
const Component = (props) =&gt; {
  const ref = useRef(props);
  useEffect(() =&gt; {
    ref.current = props;
  });
  const handleHoge = useCallback(()=&gt;{
    const props = ref.current;
    // propsを使った処理 
  }, []);
  return &amp;#x3C;Hoge onHoge={handleHoge} /&gt;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;(やったことないので本当にできるか不明)
propsの変更を適当にスロットルして、依存変数を制御するとかもできるかもれない。
(追記:コメントでうまくいったとご報告をいただきました。またアドバイスいただき[ref]を依存変数から除去しました。)&lt;/p&gt;
&lt;h2&gt;ケース2-2「利点1」をあきらめるが、「利点2」は得られる場合その2&lt;/h2&gt;
&lt;p&gt;依存変数がなければ、useCallbackは常に前回と同じ値もしくは初期値を返します。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-JavaScript&quot;&gt;const Component = (props) =&gt; {
  const handleHoge = useCallback(() =&gt; {propsやstateを使わない処理}, []);
  return &amp;#x3C;Hoge onHoge={handleHoge} /&gt;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ケース1と比べると、利点2は同等です。利点1は得られませんが、たいてい無視できるでしょう。&lt;/p&gt;
&lt;h2&gt;ケース2-3「利点1」をあきらめるが、「利点2」を&lt;strong&gt;&lt;em&gt;一部&lt;/em&gt;&lt;/strong&gt;得たい場合&lt;/h2&gt;
&lt;p&gt;useCallbackに、必要な依存をつけてローカル関数をくぐらせたものを使ってください。
useCallbackの使いかたの本道です。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-JavaScript&quot;&gt;const Component = (props) =&gt; {
  const [state, setState] = useState(..);
  const handleHoge = useCallback(
     () =&gt; {propsやstateを使った処理},
     [props.x, state]
  );
  return &amp;#x3C;Hoge onHoge={handleHoge} /&gt;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;「利点2」を一部得たい場合」の一部というのは、依存変数が変化しなければ一応、再renderはおきないからです。しかし、クラスコンポーネントの場合に、コンストラクタでイベントハンドラを.bind(this)して保存しなおしたり、クラスフィールドで保存した場合は関数の更新は一切起きなかったわけなので、一部はあきらめていることになります。これは関数コンポーネントではthis経由でpropsとstateがアクセスできないことに起因する問題です。&lt;/p&gt;
&lt;h2&gt;ケース3「利点1」と「利点2」の両方をあきらめる場合。&lt;/h2&gt;
&lt;p&gt;ローカルなアロー関数をそのままわたしてください。useCallbackはdepsが漏れるとバグになりやすいので、良い選択かもしれません。&lt;/p&gt;
&lt;h1&gt;利点2がそもそも得られないパターン&lt;/h1&gt;
&lt;p&gt;上のケース2のいずれかを採用して、利点2が得られるとおもってuseCallbackを使うとしても、実際には利点2が得られていない場合があります。この場合ケース3にフォールダウンした方がよいかもしれません(統一性のためケース2-2,2-3を採用するという判断もありえますが、前述のようにバグ注意です)&lt;/p&gt;
&lt;h2&gt;propsの変化の有無が効率に無関係な場合&lt;/h2&gt;
&lt;p&gt;デフォルトでは、render()呼び出しはpropsの変化にかかわらず常に行なわれます。なので利点2を考えてケース2にする意味がない場合があります。propsをシャロー比較してrenderを最適化しようとしているケースは以下が考えられます。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;React.memoでメモ化されているケース&lt;/li&gt;
&lt;li&gt;PureComponent&lt;/li&gt;
&lt;li&gt;componentWillUpdateでシャロー比較の更新制御などをしているコンポーネント&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;react-reduxのconnectを使ったSmartコンポーネント&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;redux暗黙の処理として、propsのシャロー比較での更新制御が入っているので、ケース2-1,2-2のuseCallbackで「利点2」が得られる可能性があります。&lt;/li&gt;
&lt;li&gt;ただし、reduxのdumbコンポーネントやreact-redux 7.1移行のHooks系でstoreと結びつけている場合はこの限りではありません。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;html要素にコールバックを渡す場合&lt;/h2&gt;
&lt;p&gt;たとえばbuttonはReact.memo化されていないので(要出典)、利点2が得られません。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;#x3C;button onClick={()=&gt;{}} &gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;で充分です。&lt;/p&gt;
&lt;h1&gt;まとめ&lt;/h1&gt;
&lt;p&gt;まとめると、useCallbackを使うべきなのは、イベントハンドラをローカル関数にせざるを得ない場合、つまり関数コンポーネント本体のスコープ内の引数や、ローカル変数、特にpropの引数や他のuseStateを始めとするhooks呼び出しで得られるローカル変数の値に、関数の処理が依存している場合であり、かつ、そのローカル変数をイベントハンドラとして渡そうとしているReact要素がReact.memoされている場合です。&lt;/p&gt;
&lt;h1&gt;おわり&lt;/h1&gt;
&lt;p&gt;hooksは最高なんですが、留意点がありますので気をつけて使っていきましょう。&lt;/p&gt;</content:encoded></item><item><title><![CDATA[Elmでやってみようシリーズ1]]></title><description><![CDATA[elmでやってみるシリーズ1: ●を動かす。 こちらで実行できます。 感想 foldpは好き。 inputに対応するSignal…]]></description><link>https://ganevru.github.io/gatsby-starter-blog-grommet/blog/ce95865dc999be1d68eb/</link><guid isPermaLink="false">https://ganevru.github.io/gatsby-starter-blog-grommet/blog/ce95865dc999be1d68eb/</guid><pubDate>Thu, 20 Feb 2020 15:08:12 GMT</pubDate><content:encoded>&lt;p&gt;&lt;a href=&quot;http://elm-lang.org/&quot;&gt;elm&lt;/a&gt;でやってみるシリーズ1: ●を動かす。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-haskell&quot;&gt;import Window

pos : Signal Int
pos =let f = \tmp -&gt; (tmp `mod` 30) - 10
        in f &amp;#x3C;~ foldp (\it acc-&gt; acc + 1) 0 (fps 50)

drawCircle : Float -&gt; Float -&gt; Form
drawCircle x y = move (x,y) &amp;#x3C;| filled red (circle 20)

drawMatrix : [Form]
drawMatrix = map (\x -&gt; drawLine &amp;#x3C;| x*10) [-10..10]

drawLine : Float -&gt; Form
drawLine x = traced (solid blue) ( segment (x,-100) (x,100) )

main : Signal Element
main=let f = \w h p-&gt; collage w h ([drawCircle ((toFloat p)*10) 10]++drawMatrix)
     in f &amp;#x3C;~ Window.width ~ Window.height ~ pos
&lt;/code&gt;&lt;/pre&gt;
&lt;iframe width=&quot;100%&quot; src=&quot;http://share-elm.com/sprout/53c8a01ee4b07afa6f983053/stable/view&quot;&gt;
&lt;/iframe&gt;
# 実行する
&lt;p&gt;&lt;a href=&quot;http://share-elm.com/sprout/53c8a01ee4b07afa6f983053/stable/view&quot;&gt;こちら&lt;/a&gt;で実行できます。&lt;/p&gt;
&lt;h1&gt;感想&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;foldpは好き。&lt;/li&gt;
&lt;li&gt;inputに対応するSignalってグローバル変数じゃね?まあ「マウスがクリックされる」とか「時間が経過する」という事実はグローバルなんだが、それによって引き起こされるイベントもそうなる…。プログラムからその値を能動的に制御できないから変数とは呼べない…のかな。でもユーザがフィールドに値を入力したり、ラジオボタンをクリックしたり、という操作によって設定項目をリアクティブに変更したその結果の、Signalである設定項目って、どう見てもグローバル変数だよね。まだよくわからない。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;関連エントリ&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://uehaj.hatenablog.com/entry/2014/07/03/023808&quot;&gt;http://uehaj.hatenablog.com/entry/2014/07/03/023808&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[redux-sagaで検索機能の実装を写経してCSPのパワーを感じる]]></title><description><![CDATA[この記事は、@inuscriptさんによる「redux-observableで検索機能の実装を写経してRxJSのパワーを感じる」をRedux-Saga…]]></description><link>https://ganevru.github.io/gatsby-starter-blog-grommet/blog/bee9b9dd8279b1a769bb/</link><guid isPermaLink="false">https://ganevru.github.io/gatsby-starter-blog-grommet/blog/bee9b9dd8279b1a769bb/</guid><pubDate>Thu, 20 Feb 2020 15:08:12 GMT</pubDate><content:encoded>&lt;p&gt;この記事は、@inuscriptさんによる「&lt;a href=&quot;http://qiita.com/inuscript/items/c672ddad4c24936b1061&quot;&gt;redux-observableで検索機能の実装を写経してRxJSのパワーを感じる&lt;/a&gt;」を&lt;a href=&quot;https://github.com/redux-saga/redux-saga&quot;&gt;Redux-Saga&lt;/a&gt;で書きなおしたものです。&lt;/p&gt;
&lt;h1&gt;本記事の目的&lt;/h1&gt;
&lt;p&gt;実用コードにおける非同期処理では以下のような問題が頻出する。これらについて元記事におけるRedux-obserbable(あるいはAngularが提供する)RxJSを用いた解決方法に対して、Redux-sagaによる解決方法を比較する。&lt;/p&gt;
&lt;p&gt;(&lt;a href=&quot;http://qiita.com/inuscript/items/c672ddad4c24936b1061&quot;&gt;元記事&lt;/a&gt;よりの引用)&lt;/p&gt;
&lt;pre&gt;
この時、大きく以下３つの問題に当たる

1: キーストローク毎にリクエストするのはよろしくない
2: 同じリクエストで済むのに無意味にリクエスト飛ばすのはよろしくない
foo -&gt; fooo -&gt; foo -&gt; fooo -&gt; foo みたいな入力をした場合に不必要にデータ飛んでしまう可能性
3: 複数リクエストを発火した場合の処理
A -&gt; Bの順番にリクエストしたら B -&gt; Aの順で返ってきちゃって表示がおかしくなる場合
Anglar を扱ったサンプルの記事
&lt;/pre&gt;
&lt;h1&gt;redux-sagaの説明&lt;/h1&gt;
&lt;h2&gt;redux-sagaとは何か&lt;/h2&gt;
&lt;p&gt;reduxのミドルウェアとして実装されたコンカレント処理エンジン(プロセスマネージャ)。コンカレント処理モデルはCSP&lt;sup id=&quot;fnref-6&quot;&gt;&lt;a href=&quot;#fn-6&quot; class=&quot;footnote-ref&quot;&gt;6&lt;/a&gt;&lt;/sup&gt;に基づいている。並行性の単位は協調型マルチタスク(非プリエンプティブ)で、これらはコルーチンを使用して実現される。generator functionがコルーチン処理を実装するために使用されている。エフェクト(作用)をデータとして扱い、副作用の分離&lt;sup id=&quot;fnref-5&quot;&gt;&lt;a href=&quot;#fn-5&quot; class=&quot;footnote-ref&quot;&gt;5&lt;/a&gt;&lt;/sup&gt;を可能とすることが特徴である。&lt;/p&gt;
&lt;h2&gt;generator functionでコルーチンってどういうこと?&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;http://d.hatena.ne.jp/minekoa/20070410/1176177653&quot;&gt;こちら&lt;/a&gt;などを参照。&lt;/p&gt;
&lt;blockquote&gt;
ジェネレータが作る「値を次々に返すモノ」は、味付けこそイテレータ風ですが、 本質的には コルーチン(coroutine) です。 コルーチンとは、「実行の途中でリターンでき、次回コール時にはそこから処理を再開することが出来るモノ」で*2、 「メインとサブ」という関係を持たないルーチンを示すします
&lt;/blockquote&gt;
&lt;h2&gt;ジェネレータ関数/コルーチンでコンカレント処理ってどういうこと?&lt;/h2&gt;
&lt;p&gt;readux-sagaランタイムの処理を想像するに、以下のようなことをしていると思われる。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ジェネレータ関数は一連のエフェクトを返すイテレータです。rootSagaなどのジェネレータ関数(saga)はそれぞれ一つのイテレータに対応します。&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;takeエフェクトの処理&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;イテレータが特定のアクションをtakeするエフェクトを返したとき、アクションとイテレータの対応を保存しておきます。&lt;/li&gt;
&lt;li&gt;ReduxアプリケーションがReduxアクションをdispatchしたとき、redux-sagaミドルウェアはその対応を検索し、該当アクションでブロックしているイテレータに対してnext()を呼び出します(このときdispatchの引数を与えてnextを呼び出す。その値がyieldされる値となる)。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;callエフェクトの処理&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Promiseにつないだthen中でそのイテレータにnextします(Proimseの結果値がyieldされる値となる)。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;他、タスク間の親子関係の管理、それに従うキャンセル処理、レースコンディション(race)の処理なども行なう。&lt;/p&gt;
&lt;h2&gt;redux-sagaはテストコードを書きやすくするものって聞いたんだけど&lt;/h2&gt;
&lt;p&gt;そういう効用はあるでしょうが、本質ではない。それが証拠に、仮にテストをしなかったとしてredux-sagaの効用は無くならない。複雑な非同期処理のハンドリングに本質的な価値がある。&lt;/p&gt;
&lt;h1&gt;大まかな意味での比較&lt;/h1&gt;
&lt;p&gt;ReactiveXもredux-sagaもいずれもイベントの繰り返しをイテレータに類する機能でハンドリングする。ただし前者は内部イテレータ(プッシュ型)、後者は外部イテレータ(プル型)風味である。&lt;/p&gt;
&lt;h1&gt;コード比較&lt;/h1&gt;
&lt;h2&gt;(比較対象として)Redux-observableの場合(&lt;a href=&quot;http://qiita.com/inuscript/items/c672ddad4c24936b1061&quot;&gt;こちらの「完成品 &amp;#x26; 最終形」&lt;/a&gt;からの引用)&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;// epic.js
const searchEpic = (action$) =&gt; (
  action$.ofType(CHANGE_INPUT)
    .map( ({payload}) =&gt; payload )
    .debounceTime(400)
    .distinctUntilChanged()
    .switchMap( (payload) =&gt; searchApi(payload) )
    .map( result =&gt; loadResult(result) )
)

export const epics = combineEpics(
  searchEpic,
)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Redux-sagaで書きなおしたコード&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;// sagas.js
let lastWord;
function* changeInput() {
  yield delay(400);
  const word = yield select(state =&gt; { return state.word; });
  if (lastWord === word) {
    return;
  }
  lastWord = word;
  const json = yield call(searchApi, word);
  yield put(loadResult(json));
}

export default function* rootSaga() {
  yield takeLatest(CHANGE_INPUT, changeInput);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上記と&lt;a href=&quot;https://github.com/uehaj/search-sample-saga/blob/master/src/store.js#L11&quot;&gt;ミドルウェアの組み込みのところ&lt;/a&gt;以外はRedux-observable版と全く同じ。&lt;/p&gt;
&lt;h1&gt;redux-saga版ソースコード全体&lt;/h1&gt;
&lt;p&gt;redux-saga版のコード全体は&lt;a href=&quot;https://github.com/uehaj/search-sample-saga&quot;&gt;こちら&lt;/a&gt;&lt;/p&gt;
&lt;h1&gt;redux-saga版のデモ&lt;/h1&gt;
&lt;p&gt;デモは&lt;a href=&quot;https://uehaj.github.io/search-sample-saga/&quot;&gt;こちら&lt;/a&gt;。&lt;/p&gt;
&lt;h1&gt;redux-saga版のコードの解説&lt;/h1&gt;
&lt;h2&gt;rootSaga saga全体&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;export default function* rootSaga() {
  yield takeLatest(CHANGE_INPUT, changeInput);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;rootSaga一行目&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;export default function* rootSaga() {
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;redux-sagaにおけるsaga&lt;sup id=&quot;fnref-7&quot;&gt;&lt;a href=&quot;#fn-7&quot; class=&quot;footnote-ref&quot;&gt;7&lt;/a&gt;&lt;/sup&gt;はエフェクトをyieldするgenerator functionとして定義する(エフェクトについては後述)。&lt;/li&gt;
&lt;li&gt;sagaが記述している実行単位はタスクと呼ばれる。sagaをforkするとタスクが起動する。&lt;/li&gt;
&lt;li&gt;sagaによるタスク記述というのは&lt;a href=&quot;https://en.wikipedia.org/wiki/Workflow_engine&quot;&gt;ワークフローエンジン&lt;/a&gt;におけるワークフローシナリオと思えば良い。「こうなったらこうする」といったイベントベースの処理フローを、JavaScriptのif文やwhileループで書いていく。ただし、処理の各ステップは、「エフェクトをyieldする」という形式に統一する必要がある。すると複数のタスクがコンカレントに処理されたり、副作用を伴う処理をランタイムに任せたりすることになる。&lt;/li&gt;
&lt;li&gt;rootSagaでは、エントリポイントとしてページ全体で一回だけ最初にfork起動されるタスクを記述する。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;rootSaga二行目〜&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;  yield takeLatest(CHANGE_INPUT, changeInput);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;takeLatestは、「Reduxアクションが発生したら指定したsagaからタスクをfork起動する、そしてすでに同じアクションに対して別のタスクが起動していたら、その先行するタスクはキャンセルする」という意味のエフェクトである。&lt;/li&gt;
&lt;li&gt;エフェクトは単なるデータである。エフェクトを解釈するのはredux-sagaランタイムであり、sagaは副作用を持たない純粋関数である。(だからテストがしやすい)&lt;/li&gt;
&lt;li&gt;エフェクトには、reduxアクションを待つtake、reduxアクションを発行するput、プロミスの完了を待つcallや、タスクを起動するfork、エフェクトを組合わせる各種エフェクト(race, takeLatest, …)などがある。(&lt;a href=&quot;https://redux-saga.js.org/docs/api/index.html#effect-creators&quot;&gt;参考&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;上記では、「CHANGE_INPUTアクション」が発行されたとき、changeInput sagaをtakeLatestで起動している。これで元問題の「複数リクエストを発火した場合の処理」を解決している(先行するリクエストの結果は無視される)。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;changeInput saga全体&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;let lastWord;
function* changeInput() {
  yield delay(400);
  const word = yield select(state =&gt; { return state.word; });
  if (lastWord === word) {
    return;
  }
  lastWord = word;
  const json = yield call(searchApi, word);
  console.log(json);
  yield put(loadResult(json));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;changeInput 1行目〜&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;let lastWord;
function* changeInput() {
    :
  const word = yield select(state =&gt; { return state.word; });
  if (lastWord === word) {
    return;
  }
  lastWord = word;
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;「distinctUntilChanged」に対応する処理。前回実行した検索時のwordと一致していたら検索を行わずにリターンする&lt;sup id=&quot;fnref-1&quot;&gt;&lt;a href=&quot;#fn-1&quot; class=&quot;footnote-ref&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;。これで「同じリクエストで済むのに無意味にリクエスト飛ばすのはよろしくない」問題を解決している。&lt;/li&gt;
&lt;li&gt;&lt;sup id=&quot;fnref-1&quot;&gt;&lt;a href=&quot;#fn-1&quot; class=&quot;footnote-ref&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;: 複数のsagaが並行実行される場合も考えると、共有変数で重複をチェックするこの方法は少々ナイーブである。ちゃんとやるならtakeLastestを使わずに明示的にtakeで回して、lastWordはそのループで参照するローカル変数にするのかな(changeInputを分離せずにrootSagaに展開)。もしくはreduxのstore変数にするのだが、それをやりたくないからsagaを使う面もある。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;changeInput 2行目&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;function* changeInput() {
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;chageInput sagaの定義である。前述のように、各段階でエフェクトをyieldするgenerator関数として定義されている。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;changeInput 3行目&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;  yield delay(400);
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;delayは、指定したミリセカンド数遅延してからresolveするProimseを返す関数をcallするエフェクトを返すユーティリティ関数。意味は「400ms delayする」ただそれだけの話。&lt;/li&gt;
&lt;li&gt;これで元問題の「キーストローク毎にリクエストするのはよろしくない」問題が解決される。takeLatestと合せ技で、400ms以内に発行された先行タスクはキャンセルされるため。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;changeInput 4行目&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;  const word = yield select(state =&gt; { return state.word; });
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;selectエフェクトは、stateから値を取り出す(たぶん同期的)。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;changeInput 9行目&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;  const json = yield call(searchApi, word);
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;callエフェクトはPromiseを返す関数の呼び出し。ここではsearchApi API関数を呼んでいる。awaitと同様に同期的に書ける。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;changeInput 10行目〜&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;  yield put(loadResult(json));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;putはreduxアクションを発行するエフェクトである。ここでは検索APIの呼び出し結果jsonをresultに設定するReduxアクションを発行する。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;主観としての感想&lt;/h1&gt;
&lt;p&gt;RxJSは便利なオペレータが準備されていれば良し。ただしその大量のオペレータの正確な意味を覚え続けていられるか、他メンバーや未来の自分自身と共有できるかという問題がある。さらに上記コードにはないが、ストリームが分岐したり合流したりしたとき、極めて分かりにくいコードになる。&lt;/p&gt;
&lt;p&gt;redux-sagaは「ベッタベタ」のコードとなり、数個のエフェクトの意味さえ押えれば読み書きができる。使いこなすにはES2015のジェネレータ関数のシンタックスとセマンティクスについてある程度熟知しておく必要はある。&lt;/p&gt;
&lt;p&gt;要するに、「FRPの語彙」と、「ifやwhileや関数呼び出しなどの古典的命令的プログラミングの語彙」のいずれを好むのか、が両者の差異の核心である。&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;こちらもどうぞ → &lt;a href=&quot;https://qiita.com/uehaj/items/eaa039a7ce44d5969f06&quot;&gt;Redux-Sagaでテトリス風ゲームを実装して学んだこと&lt;/a&gt;。&lt;/p&gt;
&lt;div class=&quot;footnotes&quot;&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id=&quot;fn-7&quot;&gt;
&lt;p&gt;redux-sagaのsagaという名は、長命分散トランザクションにおけるエラーハンドリングの&lt;a href=&quot;https://medium.com/@roman01la/confusion-about-saga-pattern-bbaac56e622&quot;&gt;sagaパターン&lt;/a&gt;から来ている。転じて、プロセスマネージャを意味する場合もあるようで、redux-sagaはこの意味でのsagaである。ただし、後者はそもそも誤用に近い用法である気がする。&lt;/p&gt;
&lt;a href=&quot;#fnref-7&quot; class=&quot;footnote-backref&quot;&gt;↩&lt;/a&gt;
&lt;/li&gt;
&lt;li id=&quot;fn-6&quot;&gt;
&lt;p&gt;CSPは&lt;a href=&quot;https://ja.wikipedia.org/wiki/Communicating_Sequential_Processes&quot;&gt;Concurrent Sequencial Processing&lt;/a&gt;の略。redux-sagaはtake/putに関してredux action型を持つ単一のチャンネルを扱うCSPと見做せる&lt;sup id=&quot;fnref-2&quot;&gt;&lt;a href=&quot;#fn-2&quot; class=&quot;footnote-ref&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;。redux-sagaを典型的なCSPとよぶべきかはわからないが、語呂が良いのでこういうタイトルにした。コルーチンとかワークフローエンジンとか副作用の分離などで置き換えても良いと思う。&lt;/p&gt;
&lt;a href=&quot;#fnref-6&quot; class=&quot;footnote-backref&quot;&gt;↩&lt;/a&gt;
&lt;/li&gt;
&lt;li id=&quot;fn-5&quot;&gt;
&lt;p&gt;副作用のデータ化と分離は、&lt;a href=&quot;https://guide.elm-lang.org/architecture/&quot;&gt;Elm Architecture&lt;/a&gt;にインスパイアされていると感じられる。&lt;/p&gt;
&lt;a href=&quot;#fnref-5&quot; class=&quot;footnote-backref&quot;&gt;↩&lt;/a&gt;
&lt;/li&gt;
&lt;li id=&quot;fn-2&quot;&gt;
&lt;p&gt;redux-sagaでは&lt;a href=&quot;http://qiita.com/wadahiro/items/7d54a6be592d06bdf559&quot;&gt;複数チャンネルも扱える&lt;/a&gt;。&lt;/p&gt;
&lt;a href=&quot;#fnref-2&quot; class=&quot;footnote-backref&quot;&gt;↩&lt;/a&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</content:encoded></item><item><title><![CDATA[macosで Control+[ 押下をEscapeに割り当てる]]></title><description><![CDATA[Escapeキーは遠く、さらにtouch barでは押しにくいので、Control+[をEscapeキーにわりあてます。 Karabinar Elementsをインストールする 以下を作成する。 `json:~/.config/karabiner/assets…]]></description><link>https://ganevru.github.io/gatsby-starter-blog-grommet/blog/a6637482c5f6246cb30f/</link><guid isPermaLink="false">https://ganevru.github.io/gatsby-starter-blog-grommet/blog/a6637482c5f6246cb30f/</guid><pubDate>Thu, 20 Feb 2020 15:08:12 GMT</pubDate><content:encoded>&lt;p&gt;Escapeキーは遠く、さらにtouch barでは押しにくいので、Control+[をEscapeキーにわりあてます。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Karabinar Elementsをインストールする&lt;/li&gt;
&lt;li&gt;以下を作成する。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;`&lt;code&gt;&lt;/code&gt;json:~/.config/karabiner/assets/complex&lt;em&gt;modifications/myconfig.json
{
“title”: “Ctrl+[をEscapeにする。”,
“rules”: [
{
“description”: “Ctrl+[をEscapeにする。”,
“manipulators”: [
{
“type”: “basic”,
“from”: {
“key&lt;/em&gt;code”: “open&lt;em&gt;bracket”,
“modifiers”: {
“mandatory”: [“control”]
}
},
“to”: [
{
“key&lt;/em&gt;code”: “escape”
}
]
}
]
}
]
}&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;3. karabinar-elementsのpreferenceからenableする

&amp;#x3C;img width=&quot;945&quot; alt=&quot;スクリーンショット 2019-02-23 10.45.59.png&quot; src=&quot;https://qiita-image-store.s3.amazonaws.com/0/9979/2560d287-f1ef-ac12-1d78-3fd3ca60c421.png&quot;&gt;
&lt;/code&gt;&lt;/pre&gt;</content:encoded></item><item><title><![CDATA[「リアクティブプログラミングが読み難い」というのは本当なのか?]]></title><description><![CDATA[追記(2017/05/2) redux-sagaでの非同期バージョンの紹介とリンクを追記。 追記(2017/2/23修正) 元記事の追記…]]></description><link>https://ganevru.github.io/gatsby-starter-blog-grommet/blog/80056c1ff10c63dc7810/</link><guid isPermaLink="false">https://ganevru.github.io/gatsby-starter-blog-grommet/blog/80056c1ff10c63dc7810/</guid><pubDate>Thu, 20 Feb 2020 15:08:12 GMT</pubDate><content:encoded>&lt;h1&gt;追記(2017/05/2)&lt;/h1&gt;
&lt;p&gt;redux-sagaでの非同期バージョンの紹介とリンクを追記。&lt;/p&gt;
&lt;h1&gt;追記(2017/2/23修正)&lt;/h1&gt;
&lt;p&gt;&lt;font color=&quot;red&quot;&gt;&lt;a href=&quot;http://qiita.com/hiruberuto/items/39e4126f470d8b84b291#%E8%BF%BD%E8%A8%98%EF%BC%93%E3%82%AB%E3%82%A6%E3%83%B3%E3%82%BF%E3%83%BC%E3%82%A8%E3%83%B3%E3%83%88%E3%83%AA%E3%82%92%E9%A0%82%E3%81%84%E3%81%9F%E3%81%AE%E3%81%A7%E3%81%99%E3%81%8C%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%A0%E3%81%AB%E8%AA%A4%E3%82%8A%E3%81%8C%E3%81%82%E3%82%8A%E3%81%BE%E3%81%99&quot;&gt;元記事の追記3&lt;/a&gt;にて言及を頂いたように、&lt;/font&gt;以下の「見易い版」コードは元コードが実現していた機能が抜けおちているという誤りがあります。遅くなりましたが、お詫びの上修正させていただきます。
修正内容は以下の「&lt;a href=&quot;http://qiita.com/uehaj/items/80056c1ff10c63dc7810#refresh%E3%83%9C%E3%82%BF%E3%83%B3%E6%8A%BC%E4%B8%8B%E3%81%A7%E3%81%99%E3%81%B9%E3%81%A6%E3%81%AE%E5%80%99%E8%A3%9C%E3%82%92%E6%B6%88%E5%8E%BB2017223%E8%BF%BD%E8%A8%98&quot;&gt;refreshボタン押下ですべての候補を消去&lt;/a&gt;」の項目に追記しました。&lt;/p&gt;
&lt;p&gt;上記追記の趣旨として、リアクティブプログラミングはそれほど判り難いのだ、というご指摘になっていますが、返す言葉もございません。&lt;/p&gt;
&lt;h1&gt;はじめに&lt;/h1&gt;
&lt;p&gt;先日「&lt;a href=&quot;http://qiita.com/hiruberuto/items/39e4126f470d8b84b291&quot;&gt;リアクティブプログラミングとは何だったか&lt;/a&gt;」という記事を目にしまして、内容はたいへん興味深かったのですが、以下の記述がありました。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;『宣言的』といえそうなのはわかりますし、パラダイムとして従来のコードとは一線を画すものであることは確かですが、どう贔屓目にみてもひたすら読みづらいとしか感じられません。ここでもう一度、先に示したモナド版のほうを見て比較してみます。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;比較しているのは、&lt;a href=&quot;http://jsfiddle.net/staltz/8jFJH/48/&quot;&gt;RxJS版&lt;/a&gt;と、&lt;a href=&quot;https://gist.github.com/aratama/fa9fd5eca5573fc2e6dd&quot;&gt;PurescriptのAffモナド版&lt;/a&gt;なのですが、わたしはいずれについても詳しい知識はありませんが、ReactiveXのObservableは、私の理解では&lt;strong&gt;「ストリームモナド」&lt;/strong&gt;であり、Affモナドも(名前から判断する限り)どっちもモナドなわけで、基本的な記述でなぜそのような差が出るのかが良くわかりませんでした。 &lt;/p&gt;
&lt;p&gt;ということで、調べてみました。&lt;/p&gt;
&lt;h1&gt;TL;DR&lt;/h1&gt;
&lt;p&gt;リアクティブプログラミングが読み難いかどうかは、書き方によるが、簡単なケースでは言うほど読みにくい、というわけでもない(個人の感想です)。また読者の背景知識にもよる。&lt;/p&gt;
&lt;h1&gt;「ひたすら読み難い」と言われているコード&lt;/h1&gt;
&lt;p&gt;先の記事中で比較対象は&lt;a href=&quot;http://ninjinkun.hatenablog.com/entry/introrxja&quot;&gt;「あなたが求めていたリアクティブプログラミング入門」&lt;/a&gt;&lt;a href=&quot;https://gist.github.com/staltz/868e7e9bc2a7b8c1f754&quot;&gt;(original)&lt;/a&gt;に示されていた&lt;a href=&quot;https://github.com/Reactive-Extensions/RxJS&quot;&gt;RxJS&lt;/a&gt;のコード(&lt;a href=&quot;http://jsfiddle.net/staltz/8jFJH/48/&quot;&gt;全体はこちら&lt;/a&gt;)です。&lt;/p&gt;
&lt;p&gt;一部引用するとこんな感じ。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-JavaScript&quot;&gt;var refreshClickStream = Rx.Observable.fromEvent(refreshButton, &apos;click&apos;);
var close1ClickStream = Rx.Observable.fromEvent(closeButton1, &apos;click&apos;);
var close2ClickStream = Rx.Observable.fromEvent(closeButton2, &apos;click&apos;);
var close3ClickStream = Rx.Observable.fromEvent(closeButton3, &apos;click&apos;);

var requestStream = refreshClickStream.startWith(&apos;startup click&apos;)
    .map(function() {
        var randomOffset = Math.floor(Math.random()*500);
        return &apos;https://api.github.com/users?since=&apos; + randomOffset;
    });

var responseStream = requestStream
    .flatMap(function (requestUrl) {
        return Rx.Observable.fromPromise($.getJSON(requestUrl));
    });

function createSuggestionStream(closeClickStream) {
    return closeClickStream.startWith(&apos;startup click&apos;)
        .combineLatest(responseStream,             
            function(click, listUsers) {
                return listUsers[Math.floor(Math.random()*listUsers.length)];
            }
        )
        .merge(
            refreshClickStream.map(function(){ 
                return null;
            })
        )
        .startWith(null);
}
var suggestion1Stream = createSuggestionStream(close1ClickStream);
var suggestion2Stream = createSuggestionStream(close2ClickStream);
var suggestion3Stream = createSuggestionStream(close3ClickStream);
 ：
suggestion1Stream.subscribe(function (suggestedUser) {
    renderSuggestion(suggestedUser, &apos;.suggestion1&apos;);
});

suggestion2Stream.subscribe(function (suggestedUser) {
    renderSuggestion(suggestedUser, &apos;.suggestion2&apos;);
});

suggestion3Stream.subscribe(function (suggestedUser) {
    renderSuggestion(suggestedUser, &apos;.suggestion3&apos;);
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;なるほどなるほど。確かに確かに。&lt;/p&gt;
&lt;h1&gt;なぜ読み難いのか&lt;/h1&gt;
&lt;h2&gt;変数の多用&lt;/h2&gt;
&lt;p&gt;一見してわかるのは、ストリーム(=Observable)を保持するための変数を多用しているということです。この理由はおそらく、本文中での説明時の参照のしやすさ、特に図表で説明するためではないかと思いました。たとえば、&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    requestStream: --r---------------&gt;
   responseStream: ------R-----------&gt;
close1ClickStream: ------------c-----&gt;
suggestion1Stream: ------s-----s-----&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上記の左の桁にストリームを特定するための変数名を書きたかった、ということです。&lt;/p&gt;
&lt;p&gt;結果として読む流れが上に行ったり下に行ったりしてしまいます。ただこれは使用箇所で値を展開するようにすれば改善されるでしょう。&lt;/p&gt;
&lt;h2&gt;不要な処理(2017/2/23訂正)&lt;/h2&gt;
&lt;p&gt;&lt;del&gt;いくつか不要な処理が混入していることに気付きました。具体的にはmergeの呼び出しや、startwithを2回呼び出していることなどです。ステップバイステップで改良しつつ説明していくときに、古いステップで必要だったが、処理を追加することで不要になったものを削除しわすれてる、って気がします。&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;&lt;del&gt;この結果、 refreshClickStreamが2箇所で使用され、最後に合流していくように見え、なんだこりゃ、と思えるようになっていました。でもそれで動くっていうのもある意味すごい。&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;当初、refreshStreamのmergeによる合流は不要な処理と思いましたが、後述のように重要な仕様を実現するためのもので不要ではありませんでした。startwithの2回の呼び出しのうち1回は不要な処理だと思っています。&lt;/p&gt;
&lt;h2&gt;ES2015の不使用&lt;/h2&gt;
&lt;p&gt;アロー関数をつかってないので煩雑に見えます。枝葉ですけどね。&lt;/p&gt;
&lt;h1&gt;書き直してみた&lt;/h1&gt;
&lt;p&gt;上記を中心に修正してみると、先ほど引用した部分に対応する部分は以下のようになりました。(全体および詳しい説明は&lt;a href=&quot;http://jsdo.it/uehaj/rxjs1&quot;&gt;こちら&lt;/a&gt;。)&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-JavaScript&quot;&gt;// お奨めユーザ一覧を取得する非同期通信の発行結果のプロミスをストリームで包んで返す。
function getNewUsers() {
    const randomOffset = Math.floor(Math.random()*500);
    const requestUrl = &apos;https://api.github.com/users?since=&apos; + randomOffset
    return Rx.Observable.fromPromise($.getJSON(requestUrl))
}

// closeボタンにイベントストリームを設定するぜ!
[[closeButton1, &quot;.suggestion1&quot;],
 [closeButton2, &quot;.suggestion2&quot;],
 [closeButton3, &quot;.suggestion3&quot;]]
    .forEach(([closeButton, selector]) =&gt;
             Rx.Observable.fromEvent(closeButton, &apos;click&apos;)
             .startWith(&apos;startup click&apos;)
             .combineLatest(
                 Rx.Observable.fromEvent(refreshButton, &apos;click&apos;)
                     .startWith(&apos;startup click&apos;)
                     .flatMap(() =&gt; getNewUsers()),
                 (_, listUsers) =&gt; listUsers[Math.floor(Math.random()*listUsers.length)])
             .subscribe((suggestedUser) =&gt; renderSuggestion(suggestedUser, selector)))
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;refreshボタン押下ですべての候補を消去(2017/2/23追記)&lt;/h2&gt;
&lt;p&gt;当初、本記事は、上記まででしたが、重要な仕様である「refreshボタン押下の瞬間に一旦すべての候補が消去される」が実装されていませんでした。私の理解不足によるもので申し訳なく思います。該当機能を実装した版を以下にしめします。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-JavaScript&quot;&gt;// お奨めユーザ一覧を取得する非同期通信の発行結果のプロミスをストリームで包んで返す。
function getNewUsers() {
    const randomOffset = Math.floor(Math.random()*500);
    const requestUrl = &apos;https://api.github.com/users?since=&apos; + randomOffset
    return Rx.Observable.fromPromise($.getJSON(requestUrl))
}

const refreshClickStream = Rx.Observable.fromEvent(refreshButton, &apos;click&apos;); //追加

// closeボタンにイベントストリームを設定するぜ!
[[closeButton1, &quot;.suggestion1&quot;],
 [closeButton2, &quot;.suggestion2&quot;],
 [closeButton3, &quot;.suggestion3&quot;]]
    .forEach(([closeButton, selector]) =&gt;
             Rx.Observable.fromEvent(closeButton, &apos;click&apos;)
             .startWith(&apos;startup click&apos;)
             .combineLatest(
                 refreshClickStream // 変更
                     .startWith(&apos;startup click&apos;)
                     .flatMap(() =&gt; getNewUsers()),
                 (_, listUsers) =&gt; listUsers[Math.floor(Math.random()*listUsers.length)])
             .merge(refreshClickStream.map(()=&gt;null))// 追加。refreshボタンが押されたらsuggestedUser==nullという出力を折り込む
             .subscribe((suggestedUser) =&gt; renderSuggestion(suggestedUser, selector)))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;修正版の全体は&lt;a href=&quot;http://jsdo.it/uehaj/45A9&quot;&gt;こちら&lt;/a&gt;。&lt;/p&gt;
&lt;h2&gt;combineLatestの使用&lt;/h2&gt;
&lt;p&gt;上記では特に&lt;a href=&quot;http://reactivex.io/documentation/operators/combinelatest.html&quot;&gt;combineLatest&lt;/a&gt;のところが難解に感じられるかもしれませんので説明します。このサンプルコードでは、個々の推奨ユーザに付随するcloseボタンの押下ではAJAXのXHRリクエストが発行されずに、最後に実行したrefreshで取得した推奨ユーザリストの値を再利用するようにしています。&lt;/p&gt;
&lt;p&gt;combineLatestは2つのストリームに関数を適用したストリームを返す、Haskellのリスト処理で言えば、「zipWith」に対応するものです。ただしストリームは非同期で離散的な値であるので、イベント生成タイミングとzipするべきペアは自明ではありません。combineLatestは「いずれかのストリームのイベント発生のタイミングで、それぞれのストリームの直近で最後の値」に対して、指定した関数を適用し、その結果から成るストリームを返します。&lt;/p&gt;
&lt;p&gt;このコードでは、refreshボタンのストリームから「推奨ユーザリストのストリーム」を生成させ、combineLatestで組合せることによって、close時に利用できる「refreshで最後に取得した推奨ユーザリスト」のイベントストリームを生成します。&lt;/p&gt;
&lt;p&gt;もちろん上記のコードはcombineLatestの意味がわからないと理解できませんが、ReactiveXの中核価値の一つは、ストリームに対する高機能なオペレータが数多く取り揃えられていることであり、それらを適切に使い分けて活用するのがRxのキモの一つだと思います。興味を引くための例示コードとしては適切だと言えましょう。&lt;/p&gt;
&lt;p&gt;実際、&lt;a href=&quot;http://ninjinkun.hatenablog.com/entry/introrxja&quot;&gt;「あなたが求めていたリアクティブプログラミング入門」&lt;/a&gt;でも(太字は引用者)、こんな風に書かれています。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;これは1つをクリックしただけなのに、クローズして全ての候補を再読み込みする。この問題を解決する方法は色々あるが、&lt;strong&gt;面白さを保つために&lt;/strong&gt;も、先ほどのレスポンスを再利用して解決してみる。APIレスポンスのページサイズは100人のユーザー分あるが、我々は3人分しか使っていない。そこにはまだ豊富な新しいデータがある。追加のリクエストをする必要は無い&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;キャッシュしないバージョン&lt;/h2&gt;
&lt;p&gt;Affモナド版では、推奨ユーザ一覧の&lt;del&gt;キャッシュ処理を(おそらく)していません。「同機能なものに対するコード比較」をしてみるのも意味があるかと思うので、&lt;/del&gt;(訂正、されておりました。大変もうしわけありません)。&lt;/p&gt;
&lt;p&gt;RxJSでキャッシュをしないバージョンも書いてみました(全体は&lt;a href=&quot;http://jsdo.it/uehaj/rxjs2&quot;&gt;こちら&lt;/a&gt;)。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-JavaScript&quot;&gt;// closeボタンにイベントストリームを設定するぜ!
[[closeButton1, &quot;.suggestion1&quot;],
 [closeButton2, &quot;.suggestion2&quot;],
 [closeButton3, &quot;.suggestion3&quot;]]
    .forEach(([closeButton, selector]) =&gt;
             Rx.Observable.fromEvent(closeButton, &apos;click&apos;)
             .startWith(null)
             .merge(Rx.Observable.fromEvent(refreshButton, &apos;click&apos;).startWith(null))
             .flatMap(() =&gt; getNewUsers())
             .subscribe((listUsers) =&gt; renderSuggestion(listUsers[Math.floor(Math.random()*listUsers.length)], selector)))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上記ではcombineLatestは使用せずに、単にmergeをしています。「refreshを押したかあるいはその推奨ユーザに対するcloseを押したか」のいずれかで都度推奨ユーザ一覧の取得処理が行なわれます。&lt;/p&gt;
&lt;p&gt;ずいぶんと分かりやすくなった気がしますがいかがしょうか。&lt;/p&gt;
&lt;h1&gt;読み難いのか?&lt;/h1&gt;
&lt;p&gt;ここまで見てきたように、ReactiveX/RxJSのコードを読むにはストリームオペレータに関する知識を必要とします。でもそれは、例えばHaskellのList処理で、foldlとかscanl,zipWithなどの標準ライブラリ関数を使ったコードに対して、それらの関数が何をするかを知らないと理解が難しいと感じるのと同様です。&lt;/p&gt;
&lt;p&gt;逆にそれらに習熟したならば、短く書け、むしろ読みやすいと感じる場合も多々あるでしょう。&lt;/p&gt;
&lt;p&gt;ちなみに、このコードはRxの真価を発揮するのにはたぶん単純すぎます。複数の関連し合うイベントソースに対する処理記述において、モジュラリティとコンポーザビリティが得られることが、真にユニークな、ほかの方法では得られないリアクティブプログラミングの利点です。しかしだからといって、単純なケースが書きにくいわけではないと思います。例えば非同期モナド(Promise想定)などと少なくとも同程度ではないでしょうか。&lt;/p&gt;
&lt;p&gt;もちろん、ストリームが何個もあって、相互に絡みあう結合・分岐が複雑になってくると、わかりにくくなって、図表とかが必要になってくるでしょう。かと言ってそれをストリームを使わないで書いた場合、その何倍もツラいコードになる気がします。&lt;/p&gt;
&lt;h2&gt;んでやっぱり読み難いのか?(2017/2/23追記)&lt;/h2&gt;
&lt;p&gt;やってしまってもう恥かしいので、読者の判断におまかせしたいと思います。今後、redux-sagaなどで非同期バージョンを書いて比較してみようと思います。&lt;/p&gt;
&lt;h1&gt;redux-sagaでの非同期バージョン(2017/5/2追記)&lt;/h1&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/uehaj/followbox-redux-saga/blob/master/sagas.js&quot;&gt;redux-sagaでの非同期バージョン&lt;/a&gt;を書いた。元の仕様に加えて、リフレッシュ・リムーブについてモーダルダイアログでの確認も追加している(sagaらしくて面白いので)。&lt;a href=&quot;https://followbox-redux-saga-vevubwrmcf.now.sh/&quot;&gt;デモ&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;// show modal dialog and get user response(Ok/Cancel) synchronously
function* askYesNo(content) {
  yield put(Actions.setModal({ show: true, title: &apos;Are you sure?&apos;, content }));
  const answer = yield race({
    ok: take(Types.UI_MODAL_OK),
    cancel: take(Types.UI_MODAL_CANCEL),
  });
  yield put(Actions.setModal({ show: false }));
  return answer;
}

// remove and get new follower
function* remove(users, action) {
  // make sure to remove
  if (
    action.payload.verify &amp;#x26;&amp;#x26;
    !(yield askYesNo(&amp;#x3C;div&gt;Delete and refresh this follower?&amp;#x3C;/div&gt;)).ok
  ) {
    return;
  }
  // get one random user from the users list
  const user = users[Math.floor(Math.random() * users.length)];
  yield put(Actions.setFollower({ idx: action.payload.idx, user }));
}

// refresh all folllowers
export function* refresh(action) {
  // make sure to refresh
  if (
    action.payload.verify &amp;#x26;&amp;#x26;
    !(yield askYesNo(&amp;#x3C;div&gt;Refresh all followers?&amp;#x3C;br /&gt;&amp;#x3C;/div&gt;)).ok
  ) {
    return;
  }
  // remove all followers on screen immediately
  yield [0, 1, 2].map(i =&gt;
    put(Actions.setFollower({ idx: i, user: { avatar_url: null } }))
  );

  try {
    // get user list pool (reuse following remove calls)
    yield put(Actions.setLoading(true));
    const users = yield call(Api.getNewUsers);
    yield put(Actions.setLoading(false));
    // remove and refresh all followers
    yield [0, 1, 2].map(i =&gt;
      fork(remove, users, Actions.remove({ idx: i, verify: false }))
    );
    // wait until remove link[x] clicks
    yield takeLatest(Types.UI_REMOVE, remove, users);
  } catch (e) {
    console.error(e);
  }
}

// single entry point to start all Sagas at once
export default function* rootSaga() {
  yield takeLatest(Types.UI_REFRESH, refresh);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt;その他&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;元記事の「あなたが求めていたリアクティブプログラミング入門」のサンプルコードだけを読むと、結構ひどいという印象になるのはしょうがない気がする。かといって、稠密なプロフェッショナルコードが入門記事のサンプルとしてふさわしいか、というと違う気もする。難しいところです。&lt;/li&gt;
&lt;li&gt;ReactiveXの利点は他にもある。バックプレッシャーつきバッファリング、他言語での同アーキテクチャ共有などなど。&lt;/li&gt;
&lt;li&gt;私はReactiveX/RxJSの知識はあんまりありません(この記事を書くために調べただけで本格的に使ったことはない)ので、不足や間違いなどありましたらご指摘ください。&lt;/li&gt;
&lt;li&gt;この記事では流れでReactiveX/RxJSをもって「リアクティブプログラミングの代表」みたいな話にしてしまってますが、一例です。本当はそれどころかReactiveX/RxJSが厳密な意味でリアクティブプログラミングにあてはまるかは不明です(参考→&lt;a href=&quot;http://postd.cc/what-is-functional-reactive-programming/&quot;&gt;FRP&lt;/a&gt;。わけわかんねー。)。この記事では、少なくとも「広義のリアクティブプログラミング」にはあてはまるものだとみなしています。&lt;/li&gt;
&lt;li&gt;flatMapをネストさせていくときに、JSではdo記法がないので煩雑になるかと思いましたが(当初それが原因かと当て推量していた)、今回のコードではそんな複雑なものではありませんでした。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;おわりに&lt;/h1&gt;
&lt;p&gt;元記事「リアクティブプログラミングとは何だったか」をかかれた、hiruberutoさまにおかれましては、上記調査のきっかけを作ってくださったことを感謝いたします。ありがとうございました。&lt;/p&gt;</content:encoded></item><item><title><![CDATA[Redux-Sagaでテトリス風ゲームを実装して学んだこと]]></title><description><![CDATA[はじめに React #1 Advent Calendar 2017の11日目です。 Reduxのミドルウェア「Redux-saga…]]></description><link>https://ganevru.github.io/gatsby-starter-blog-grommet/blog/eaa039a7ce44d5969f06/</link><guid isPermaLink="false">https://ganevru.github.io/gatsby-starter-blog-grommet/blog/eaa039a7ce44d5969f06/</guid><pubDate>Thu, 20 Feb 2020 15:08:12 GMT</pubDate><content:encoded>&lt;h1&gt;はじめに&lt;/h1&gt;
&lt;p&gt;&lt;a href=&quot;https://qiita.com/advent-calendar/2017/react&quot;&gt;React #1 Advent Calendar 2017&lt;/a&gt;の11日目です。&lt;/p&gt;
&lt;p&gt;Reduxのミドルウェア「Redux-saga」で「やや複雑なリアルタイムゲーム」としてテトリス風のゲームの基本部分を開発し、それを通じて学んだこと・感じたことを紹介します。&lt;/p&gt;
&lt;h1&gt;画面例&lt;/h1&gt;
&lt;p&gt;まずは実装したテトリス風ゲームの画面例。矢印キーの左右下でピースを動かし、z,xで回転です。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://qiita-image-store.s3.amazonaws.com/0/9979/86cb9f8e-b2df-6747-51f0-fa7fefb1f2a5.gif&quot; alt=&quot;sagaris.gif&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://qiita-image-store.s3.amazonaws.com/0/9979/b621eae9-5c08-3d95-f0ce-c3ee5b91c08e.gif&quot; alt=&quot;sagaris2.mov.gif&quot;&gt;&lt;/p&gt;
&lt;p&gt;実際に&lt;a href=&quot;https://uehaj.github.io/redux-saga-tetris/index.html&quot;&gt;こちら&lt;/a&gt;から遊べます。ソースコードは&lt;a href=&quot;https://github.com/uehaj/redux-saga-tetris&quot;&gt;こちら&lt;/a&gt;から。&lt;/p&gt;
&lt;h1&gt;テトリス風ゲーム実装を通じて学んだこと&lt;/h1&gt;
&lt;p&gt;Redux-Sagaの効用として良く言われるのは、「作用を分離する」とか「テストを簡単にする」ということです。それ以外に、今回、ゲームの実装を通じて思ったこと、思いついたことをつらつらと書いていきたいと思います。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;em&gt;利点1.&lt;/em&gt;&lt;/strong&gt; ビューからビジネスロジックを分離する&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;em&gt;利点2.&lt;/em&gt;&lt;/strong&gt; ロジックとロジックの間を疎結合にする&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;em&gt;利点3.&lt;/em&gt;&lt;/strong&gt; ロジックフローの明確化&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;それぞれ説明します。&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;&lt;em&gt;利点1.&lt;/em&gt;&lt;/strong&gt; ビューからビジネスロジックを分離する&lt;/h2&gt;
&lt;h3&gt;React単独だと分離できない&lt;/h3&gt;
&lt;p&gt;コンポーネント指向のビューライブラリであるReactにおいて、ロジックは起点としてonClickなどに設定するコールバック関数、もしくはコールバックから呼び出す関数やメソッドで実現されます。このとき、依存性は以下のようになります。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.plantuml.com/plantuml/png/SoWkIImgAStDuSf9JIjHACbNACfCpoXHICaiIaqkoSpFuz9ut3pvSVFInyrxD1LqTUqK5802QnytxNZStFouQRqcbqDgNWfGFm00&quot; alt=&quot;alt&quot;&gt;&lt;/p&gt;
&lt;p&gt;ビューはロジックに依存します。たとえば、イベントが発生したときに実行されるロジックの処理が存在するか否か、処理の個数、メソッド名や引数の変更などに応じてビューを変更しなければならない可能性があります。&lt;sup id=&quot;fnref-11&quot;&gt;&lt;a href=&quot;#fn-11&quot; class=&quot;footnote-ref&quot;&gt;11&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;
&lt;h3&gt;Reduxと組合わせれば…&lt;/h3&gt;
&lt;p&gt;Reduxは、ビューから状態を分離します。さらにビューは「Actionをdispatchする」という建前なので、依存性は以下のようになります。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.plantuml.com/plantuml/png/SoWkIImgAStDuSf9JIjHACbNACfCpoXHICaiIaqkoSpFuz9ut3pvSVFInyrxD1LqTUqKD1p1uffS2d2cGbsT0b3PsiTDEnutDpzkMg_9vP2Qbm8q5G00&quot; alt=&quot;alt&quot;&gt;&lt;/p&gt;
&lt;p&gt;Actionを介して依存性の逆転を行うことができ、ビューはActionのみに依存するようになります…。
…と言ったか? &lt;b&gt;それは嘘だ。&lt;/b&gt;&lt;/p&gt;
&lt;h3&gt;Redux-thunk(その他)ではビュー→ロジックの依存性を排除できない&lt;/h3&gt;
&lt;p&gt;Redux-thunkでは「Actionをdispatchするかわりに関数をdispatchする」というだけのものなので、「どの処理をすべきか考え、どこに処理があるかを見つけて取得するか記述して、dispatchに渡す」という責任がビューにあります。ロジックが記述されているのがメソッドであろうがアロー関数であろうが、Action Creatorで隠蔽しても同じことです。&lt;/p&gt;
&lt;p&gt;Redux-thunkに限らず、ロジックをコンポーネントのメソッドに書く場合でも、mapDispathchToPropsに書く場合でも、ImmutableJSのRecordのメソッドに書く場合でも同じです。&lt;sup id=&quot;fnref-1&quot;&gt;&lt;a href=&quot;#fn-1&quot; class=&quot;footnote-ref&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;
&lt;p&gt;もちろん、ロジックを変更したときにビューへの影響が最小限にするための努力は可能でしょう。たとえば、「将来に変更が必要にならないように、ロジックの関数名やシグネチャを十分事前に検討する」などです。しかしながら、予測できないことは発生するのが常であり、限界があると知るべきでしょう。&lt;/p&gt;
&lt;h3&gt;Redux-Sagaで実現されるビュー→ロジックへの依存の完全排除&lt;/h3&gt;
&lt;p&gt;Redux-Sagaでは、Actionは&lt;strong&gt;&lt;em&gt;かならずシンプルなデータ&lt;/em&gt;&lt;/strong&gt;であり、ビューが発行するActionに対してどんな処理が実行されるか、そもそも処理が実行されるかどうかすら、ビューの関知することではありません。このことがビューの債務を明確かつ単純にしてくれ、また試験を容易にしてくれることは明らかです。
Redux-Sagaの効用の一つは、以下のような依存性の逆転をきちんと実現することです。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.plantuml.com/plantuml/png/SoWkIImgAStDuSf9JIjHACbNACfCpoXHICaiIaqkoSpFuz9ut3pvSVFInyrxD1LqTUqKD1p1uffS2d2cWeskheB6uwRzZvjsFcvQh_-uUUtZfXsFcvk174qkXzIy5A050000&quot; alt=&quot;alt&quot;&gt;&lt;/p&gt;
&lt;p&gt;Actionさえ完成していれば、ビューを完成させテストすることができるし、タスク/ロジックについても同様です。&lt;/p&gt;
&lt;p&gt;タスクはRedux-Sagaが実現する並行動作の単位であり、Actionの発生を監視し、Actionに応じて処理を実行する存在です(Sagaと呼びます)。&lt;/p&gt;
&lt;p&gt;さらに、&lt;a href=&quot;http://www.s-arcana.co.jp/blog/2017/03/07/3499&quot;&gt;『実践 Redux Saga』 – React, FLUX, Redux, Redux Saga – // 第21回社内勉強会 #sa_study&lt;/a&gt;で紹介されている「&lt;a href=&quot;https://medium.com/@marcelschulze/using-react-native-with-redux-and-redux-saga-a-new-proposal-ba71f151546f&quot;&gt;Using React (-Native) with Redux and Redux-Saga. A new proposal?&lt;/a&gt;」のアーキテクチャを援用すれば、ビューから発行されるのは「UIアクション」のみとなり、もはや「Action(動作)」という意識も薄れることになります。ビューの債務は、「動作」や「reducerでデータを更新すること」にも関知せず、「HOWや動作を考えず、UIアクション(そのUIイベントを最小完全に表現するデータ)を発行すること」に縮退するのです。&lt;/p&gt;
&lt;p&gt;上記のアーキテクチャのポイントの一つは、ActionをUser/System/Reducer Actionの3種類にわけるというものですが、今回、ちょっとアレンジ&lt;sup id=&quot;fnref-2&quot;&gt;&lt;a href=&quot;#fn-2&quot; class=&quot;footnote-ref&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;して、以下のようにしてみました。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;UIアクション…ビューのみが発行し、Sagaのみがtakeする。&lt;/li&gt;
&lt;li&gt;システムアクション…ビューあるいはSagaが発行し、Sagaのみがtakeする。&lt;/li&gt;
&lt;li&gt;Reducerアクション…Sagaのみが発行し、Reducerのみが受けとる。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;これに従って今回実装したテトリス風ゲームのAction一覧は以下のとおりです。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align: left&quot;&gt;種別&lt;/th&gt;
&lt;th style=&quot;text-align: left&quot;&gt;アクション&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align: left&quot; rowspan=&quot;5&quot;&gt;UIアクション&lt;/td&gt;
&lt;td style=&quot;text-align: left&quot;&gt;UI_BUTTON_CLICKED&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align: left&quot;&gt;UI_KEY_DOWN&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align: left&quot;&gt;UI_MODAL_OPEN&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align: left&quot;&gt;UI_MODAL_OK&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align: left&quot;&gt;UI_MODAL_CANCEL&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align: left&quot; rowspan=&quot;5&quot;&gt;システムアクション&lt;/td&gt;
&lt;td style=&quot;text-align: left&quot;&gt;SYS_TIME_TICK&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align: left&quot;&gt;SYS_GAME_START&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align: left&quot;&gt;SYS_GAME_QUIT&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align: left&quot;&gt;SYS_GAME_OVER&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align: left&quot;&gt;SYS_FIX_DOWN_PIECE&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align: left&quot; rowspan=&quot;8&quot;&gt;Reducerアクション&lt;/td&gt;
&lt;td style=&quot;text-align: left&quot;&gt;UPDATE_CELL&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align: left&quot;&gt;SET_BOARD&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align: left&quot;&gt;SET_CURRENT_PIECE&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align: left&quot;&gt;SET_GAME_RUNNING&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align: left&quot;&gt;SET_GAME_PAUSING&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align: left&quot;&gt;SET_MODAL&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align: left&quot;&gt;SET_SCORE&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align: left&quot;&gt;ADD_SCORE&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;イメージわきますでしょうか。システムアクションはロジックにかかわる、アプリケーションで発生する意味的なレベルのイベントです。
Reducerアクションのreducerでのハンドリングは本当に機械的なstoreの更新のみです。ロジックは全く・ほとんど含みません。もし含むとしたらバリデーションみたいなものでしょうか。&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;&lt;em&gt;利点2.&lt;/em&gt;&lt;/strong&gt; ロジックとロジックの間を疎結合にする&lt;/h3&gt;
&lt;p&gt;Redux-Sagaではコンカレントに動作する複数のタスクを記述することができます。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://camo.qiitausercontent.com/f3a9835dc103b7037d34144facb1d0417f4205d6/68747470733a2f2f71696974612d696d6167652d73746f72652e73332e616d617a6f6e6177732e636f6d2f302f36393836302f38636331613837332d633637352d393030392d353730642d3936383464613461373034662e706e67&quot; alt=&quot;alt&quot;&gt;
(&lt;a href=&quot;https://qiita.com/kuy/items/716affc808ebb3e1e8ac&quot;&gt;「redux-sagaで非同期処理と戦う」&lt;/a&gt;より引用)&lt;/p&gt;
&lt;p&gt;並行動作するタスクととタスクの間の連携や連動、同期のキック処理は、ビューとタスクと同様に、シンプルデータとしてのActionのみが取り持ちます。(ちなみにこのときのActionは、go言語のCSPチャンネルのように振る舞っていると言えるんじゃないかと思います)&lt;/p&gt;
&lt;p&gt;ビューとタスクの依存性を除去したのと同じように、タスク間において、タスクを追加したり、変更したりすることが他のタスクへの影響を及ぼさないようにすることができます&lt;sup id=&quot;fnref-3&quot;&gt;&lt;a href=&quot;#fn-3&quot; class=&quot;footnote-ref&quot;&gt;3&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;
&lt;p&gt;書き方にもよるのですが、たとえば今回のテトリス風ゲームで言えば、ゲームの起動画面の処理と、実際のゲームの処理を分けることができます。&lt;/p&gt;
&lt;p&gt;以下は起動面側のタスク「&lt;a href=&quot;https://github.com/uehaj/redux-saga-tetris/blob/master/src/sagas.js#L168&quot;&gt;sagas.js&lt;/a&gt;」での処理です。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;function* demoScreen() {
  if (Config.PREDICTABLE_RANDOM) {
    Math.seedrandom(&apos;sagaris&apos;);
  }
  yield put(push(&apos;/&apos;));

  while (true) {
    // デモ画面
    while ((yield take(Types.UI_KEY_DOWN)).payload !== Keys.KEY_S) {
      /* do nothinng */
    }
    // ゲーム開始
    yield put(Actions.setGameRunning(true));
    yield put(Actions.sysGameStart());
    // ゲームオーバー、もしくはQ押下を待つ
    const gameResult = yield race({
      over: take(Types.SYS_GAME_OVER),
      quit: take(Types.SYS_GAME_QUIT),
    });
    yield put(Actions.setGameRunning(false));
    if (gameResult.over) {
      // ゲームオーバー画面(確認ダイアログ)表示
      yield* gameOver();
    }
    yield put(push(&apos;/&apos;));
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ここでは、“Ｓ”キーの入力を待ち、SYS&lt;em&gt;GAME&lt;/em&gt;STARTイベントを発行し、SYS&lt;em&gt;GAME&lt;/em&gt;OVERもしくはSYS&lt;em&gt;GAME&lt;/em&gt;QUITイベントを待ちます。ゲームを実行する別のタスクがSYS&lt;em&gt;GAME&lt;/em&gt;STARTイベントを待ち受けています。demoScreenは、gameのことを何も知りません。逆も然りです。&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;&lt;em&gt;利点3.&lt;/em&gt;&lt;/strong&gt; ロジックフローの明確化&lt;/h3&gt;
&lt;p&gt;Redux-Saga以前、ブラウザ内で動作するJSコードはServiceWorker, WebWorkerを除き本質的には「イベントハンドラの集合」であり、複数のイベントに関連する「一連のロジック」を協調的に実行させる場合、イベントハンドラ間の連携は状態変数(reduxではstateなど)で表現する他はありませんでした。これはBSDソケットのselectを使った通信処理や、協調型イベントドリブンプログラミングと同じ状況で、コンテキストを維持するスレッド等が無いので「どこまで処理が進んだか」という情報で状態を共有できないためです。&lt;/p&gt;
&lt;p&gt;たとえばウィザード形式の入力フォームで、入力が「どこまで進んだか」を表わすstateを保持するとか、あるいはモーダルダイログを「今開き中です」みたいなstateを定義するとかが典型的ですが、UIの複数箇所で進行中のものがあったりネストしたりすると記述が煩雑になります。&lt;/p&gt;
&lt;p&gt;また、Redux-Sagaを使うと「待ち受ける処理」すなわちイベントハンドラやコールバックをプル型、すなわち同期的に「取ってきくる」処理のように記述できます。async/awaitと同じですが、Redux-SagaではGeratorを用いてPromiseに限らず前述のUIアクションやシステムアクションの待ちうけを実行することができます。&lt;/p&gt;
&lt;p&gt;たとえば、テトリス風ゲームでは&lt;a href=&quot;https://github.com/uehaj/redux-saga-tetris/blob/master/src/sagas.js#L88&quot;&gt;タスクpieceFall&lt;/a&gt;で以下のような処理を実行しています。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;新しい落下テトロミノのピースを乱数で決定する。&lt;/li&gt;
&lt;li&gt;ピースをボードの初期位置に置けないならGAME_OVERシステムイベントを発行する&lt;/li&gt;
&lt;li&gt;ピースを「現在のピース」に設定する&lt;/li&gt;
&lt;li&gt;「キーの入力、一定時間経過、現在のピースが一番下まで落下して固着」のいずれかが発生するまで待つ&lt;/li&gt;
&lt;li&gt;発生したイベントが「現在のピースが一番下まで落下して固着」のときスコアを増加&lt;/li&gt;
&lt;li&gt;現在のピースが一番下まで落下したが未だ固着していないなら「余裕時間」タスクをバックグラウンド起動。&lt;/li&gt;
&lt;li&gt;余裕時間タスクはカウントダウンして、余裕時間が終了すると「現在のピースが一番下まで落下して固着」イベントを発行&lt;/li&gt;
&lt;li&gt;入力キーが’Q’や’P’のときポーズ処理や、終了の確認モーダルダイアログ処理&lt;/li&gt;
&lt;li&gt;一定時間が経過したか、↓キーが入力されたときピースを下方移動。&lt;/li&gt;
&lt;li&gt;その他の方向キーが入力されたときピースをその方向に移動&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;該当部分のコードは以下のとおりです。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-js:saga.js&quot;&gt;  :
export function* pieceFall() {
  let piece = new Piece(3, 1, Math.floor(Math.random() * 7), 0);
  let board = yield select(state =&gt; state.main.board);
  if (!piece.canPut(board)) {
    // トップ位置に置けなければゲームオーバー
    yield put(Actions.sysGameOver());
    return;
  }
  yield put(Actions.setCurrentPiece(piece));

  let stcTask = null;
  while (true) {
    const { keyDown, fixDown, timeTick } = yield race({
      keyDown: take(Types.UI_KEY_DOWN),
      fixDown: take(Types.SYS_FIX_DOWN_PIECE),
      timeTick: take(Types.SYS_TIME_TICK),
    });
    if (fixDown) {
      // this piece is fall to bottom or other piece, and fixed
      board = piece.setTo(board);
      const [newBoard, clearedLines] = Board.clearLines(board);
      board = newBoard;
      yield put(Actions.setBoard(board));
      // line clear bonus
      yield put(Actions.addScore(Config.LINES_SCORE[clearedLines]));
      break;
    }
    // 固定時間処理タスクを起動
    if (piece.reachedToBottom(board)) {
      if (stcTask === null) {
        stcTask = yield fork(slackTimeChecker);
      }
    } else if (stcTask !== null) {
      // 固定時間中の操作で底から脱却したときは固定時間を抜ける
      yield cancel(stcTask);
      stcTask = null;
    }
    if (keyDown) {
      if (keyDown.payload === Keys.KEY_Q) {
        yield* gameQuit();
      } else if (keyDown.payload === Keys.KEY_P) {
        yield* gamePause();
      }
    }
    if (keyDown || (timeTick &amp;#x26;&amp;#x26; timeTick.payload % 60 === 0)) {
      // calcurate next piece position &amp;#x26; spin
      const nextPiece = piece.nextPiece(
        (keyDown &amp;#x26;&amp;#x26; keyDown.payload) || Keys.KEY_ARROW_DOWN
      );
      if (nextPiece.canPut(board)) {
        if (
          nextPiece !== piece &amp;#x26;&amp;#x26;
          keyDown &amp;#x26;&amp;#x26;
          keyDown.payload === Keys.KEY_ARROW_DOWN
        ) {
          yield put(Actions.addScore(1));
        }
        piece = nextPiece;
        yield put(Actions.setCurrentPiece(piece));
      }
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;1つのピースを生成し、落下しつつ操作され、最後に固着するまでが一連の処理として書かれています。イベントを発生させたり、あるいはイベント発生を待ちあわせたり、「一連の処理」が連携し、データをローカル変数として共有しながら連続していきます。&lt;/p&gt;
&lt;p&gt;このような一連の処理を、たとえばasync/awaitなり、Reduxステートなり、あるいはRxJSで読みやすく書けるのかに疑問を持っています。まあもちろん、Redux-Sagaのコードが本当に読みやすいかにも疑問を持つべきですが、可読性の底ぬけ崩壊を避け、踏ん張れるかな、という印象です。&lt;/p&gt;
&lt;h1&gt;業務用アプリでも役にたつのか?&lt;/h1&gt;
&lt;p&gt;もっとも、リアルタイムゲームではなく、一般的な業務用アプリで上記ぐらいの制御が求められるのか、という疑問もあるでしょう。この疑問については、まずは複雑なものを読み易く書き下せるなら、より簡単なものを書くことにも恩恵がある、ということが言えます。
また、以下のようなケースでは業務用アプリでも恩恵があるでしょう。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ウィザード形式のフォーム入力など、ステップ・分岐で進行する処理。&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;サーバプッシュやサーバ状況変化への対応&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;たとえば、編集している帳票が他の人によって削除されたり、チャットしている相手がログアウトする&lt;/li&gt;
&lt;li&gt;たとえば「予約」のような刻々と状況が変化する対象に対する処理&lt;/li&gt;
&lt;li&gt;たとえば監視系のコンソール&lt;/li&gt;
&lt;li&gt;電波状況の変化によってオフライン・オンラインになったときのデータ更新、オフラインになっていた他者がオンラインになることによる更新&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;IDEのような複数ペインで同時進行するUI処理。例えばVSCodeのコンソール出力やバックグラウンドでのエラーチェック、など。&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;比較的複雑な処理&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;インクリメンタルサーチなどに伴い、非同期的な複数の値の取得、処理結果を整列させる、キャンセル、キャッシュ、スロットル、デバウンス、およびそれらの組合せ&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;独立性の高いコンポーネント群としてアプリケーションを構成する。 利点3で示した利点により、アプリケーションをサブシステムとして(おそらくNPMとして)分離分割する戦略に貢献することができます。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;3D化してみよう&lt;/h1&gt;
&lt;p&gt;「ReduxおよびRedux-Sagaを使用することで、ビューとロジック・状態が完全分離できる」というのが本記事の主張です。その証明として、Sagaによるタスク定義とredux部分に1行たりとも変更を加えず、ビューだけを&lt;a href=&quot;https://facebook.github.io/react-vr/&quot;&gt;ReactVR&lt;/a&gt;に置き変えてみます。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://qiita-image-store.s3.amazonaws.com/0/9979/eb1c4580-1536-c97b-4fdf-176d005d3e5f.gif&quot; alt=&quot;tetrominovr.mov.gif&quot;&gt;&lt;/p&gt;
&lt;p&gt;いともたやすくVRゲーム化できました&lt;sup id=&quot;fnref-4&quot;&gt;&lt;a href=&quot;#fn-4&quot; class=&quot;footnote-ref&quot;&gt;4&lt;/a&gt;&lt;/sup&gt;。&lt;a href=&quot;https://uehaj.github.io/rect-vr-samples/TetrominoGame0/index.html&quot;&gt;こちらからゲームをプレイ&lt;/a&gt;できます。カードボードなどVRゴーグルがあれば没入できるはずです。ソースコードは&lt;a href=&quot;https://github.com/uehaj/rect-vr-samples/tree/master/TetrominoGame&quot;&gt;こちら&lt;/a&gt;から。&lt;/p&gt;
&lt;h1&gt;まとめ&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;Redux-SagaはReduxのキラーアプリケーション。このためだけにReduxを使うということもあり。&lt;/li&gt;
&lt;li&gt;速度もこのぐらいなら十分だった。&lt;/li&gt;
&lt;li&gt;ビュー・ロジック間、ロジック間の疎結合性が特によいところ。&lt;/li&gt;
&lt;li&gt;「思いっきり命令型」だと? わーっわーっわーっ。聞こえない聞こえない(耳を塞いで)&lt;/li&gt;
&lt;li&gt;requestAnimationFrameをSagaから実行してTIME_TICKアクションを発行してますが、副作用なので本当はモックするとかせんといかん&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;おまけ&lt;/h1&gt;
&lt;p&gt;去年のRedux Advent Calenderで「&lt;a href=&quot;https://qiita.com/kuy/items/fd4ae1e3e3b34f934756&quot;&gt;Obelisk.jsとReduxで3Dテトリス「Oberis」を作ってみた
&lt;/a&gt;」という記事があることに気づきました。3Dまでまるかぶりや。普遍性があるということで。&lt;/p&gt;
&lt;h1&gt;参考、ReactVRの記事&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.ntt-tx.co.jp/column/dojo_review_blog/20170511/&quot;&gt;VRコンテンツをWebアプリのように開発するReact VR登場、その1【がっつりReact!シリーズ 第1回】
&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.ntt-tx.co.jp/column/dojo_review_blog/20170929/&quot;&gt;React VRで太陽系を創ろう、3次元モデリングとアニメーションの基礎(前編)【がっつりReact!シリーズ 第2回】
&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;footnotes&quot;&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id=&quot;fn-11&quot;&gt;
&lt;p&gt;ここで言う「ビュー」はReactコンポーネントを組合せて作られたビュー全体です。コールバック関数をpropsで外部から供給すれば、そのコンポーネントはロジックから独立になりますが、それはpropsを供給する側のコンポーネントに責任が移動したにすぎません。&lt;/p&gt;
&lt;a href=&quot;#fnref-11&quot; class=&quot;footnote-backref&quot;&gt;↩&lt;/a&gt;
&lt;/li&gt;
&lt;li id=&quot;fn-1&quot;&gt;
&lt;p&gt;redux-promise&lt;del&gt;~やredux-observable(redux-observableでは同様にアクションを監視できるので削除。)&lt;/del&gt;~でも同じと思うが良く知らないので自信なし。&lt;/p&gt;
&lt;a href=&quot;#fnref-1&quot; class=&quot;footnote-backref&quot;&gt;↩&lt;/a&gt;
&lt;/li&gt;
&lt;li id=&quot;fn-2&quot;&gt;
&lt;p&gt;元のアーキテクチャではシステムアクションはビューが発行しSagaでは発行しない。しかしたとえばrequestAnimatonFrameなどSagaで管理した方がやりやすいものがあり、また「タスク間の疎結合」の実現のためにも有用なので、システムアクションはSagaでも発行するようにした。&lt;/p&gt;
&lt;a href=&quot;#fnref-2&quot; class=&quot;footnote-backref&quot;&gt;↩&lt;/a&gt;
&lt;/li&gt;
&lt;li id=&quot;fn-3&quot;&gt;
&lt;p&gt;もちろん直接fork作用でタスクをバックグラウンド起動したりするとこの疎結合性は失なわれる。&lt;/p&gt;
&lt;a href=&quot;#fnref-3&quot; class=&quot;footnote-backref&quot;&gt;↩&lt;/a&gt;
&lt;/li&gt;
&lt;li id=&quot;fn-4&quot;&gt;
&lt;p&gt;react-routerの組込みなど未完成です。&lt;/p&gt;
&lt;a href=&quot;#fnref-4&quot; class=&quot;footnote-backref&quot;&gt;↩&lt;/a&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</content:encoded></item><item><title><![CDATA[Visual Studio Codeでエスケープキーの代りに^[を使用する設定]]></title><description><![CDATA[TouchBarつきのMacBookでは、エスケープキーが使いにくいので、Escapeキーの代りに ^[を割り当てます。Cmd-K Cmd-s からkeybindigs.jsonを開いて以下を追加。]]></description><link>https://ganevru.github.io/gatsby-starter-blog-grommet/blog/f2c71325c9f7dc10357c/</link><guid isPermaLink="false">https://ganevru.github.io/gatsby-starter-blog-grommet/blog/f2c71325c9f7dc10357c/</guid><pubDate>Thu, 20 Feb 2020 15:08:12 GMT</pubDate><content:encoded>&lt;p&gt;TouchBarつきのMacBookでは、エスケープキーが使いにくいので、Escapeキーの代りに &lt;code&gt;^[&lt;/code&gt;を割り当てます。&lt;code&gt;Cmd-K&lt;/code&gt; &lt;code&gt;Cmd-s&lt;/code&gt; からkeybindigs.jsonを開いて以下を追加。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;[
  {
    &quot;key&quot;: &quot;ctrl+[&quot;,
    &quot;command&quot;: &quot;search.action.cancel&quot;,
    &quot;when&quot;: &quot;searchViewletVisible&quot;
  },
  {
    &quot;key&quot;: &quot;ctrl+[&quot;,
    &quot;command&quot;: &quot;closeFindWidget&quot;,
    &quot;when&quot;: &quot;findWidgetVisible&quot;
  },
  {
    &quot;key&quot;: &quot;ctrl+[&quot;,
    &quot;command&quot;: &quot;closeReplaceInFilesWidget&quot;,
    &quot;when&quot;: &quot;replaceInputBoxFocus &amp;#x26;&amp;#x26; searchViewletVisible&quot;
  },
  {
    &quot;key&quot;: &quot;ctrl+[&quot;,
    &quot;command&quot;: &quot;workbench.action.hideInterfaceOverview&quot;,
    &quot;when&quot;: &quot;interfaceOverviewVisible&quot;
  },
  {
    &quot;key&quot;: &quot;ctrl+[&quot;,
    &quot;command&quot;: &quot;workbench.action.terminal.hideFindWidget&quot;,
    &quot;when&quot;: &quot;terminalFindWidgetVisible &amp;#x26;&amp;#x26; terminalFocus&quot;
  },
  {
    &quot;key&quot;: &quot;ctrl+[&quot;,
    &quot;command&quot;: &quot;cancelRenameInput&quot;,
    &quot;when&quot;: &quot;editorFocus &amp;#x26;&amp;#x26; renameInputVisible&quot;
  },
  {
    &quot;key&quot;: &quot;ctrl+[&quot;,
    &quot;command&quot;: &quot;cancelSelection&quot;,
    &quot;when&quot;: &quot;editorHasSelection &amp;#x26;&amp;#x26; textInputFocus&quot;
  },
  {
    &quot;key&quot;: &quot;ctrl+[&quot;,
    &quot;command&quot;: &quot;closeAccessibilityHelp&quot;,
    &quot;when&quot;: &quot;accessibilityHelpWidgetVisible &amp;#x26;&amp;#x26; editorFocus&quot;
  },
  {
    &quot;key&quot;: &quot;ctrl+[&quot;,
    &quot;command&quot;: &quot;closeBreakpointWidget&quot;,
    &quot;when&quot;: &quot;breakpointWidgetVisible &amp;#x26;&amp;#x26; textInputFocus&quot;
  },
  {
    &quot;key&quot;: &quot;ctrl+[&quot;,
    &quot;command&quot;: &quot;closeDirtyDiff&quot;,
    &quot;when&quot;: &quot;dirtyDiffVisible&quot;
  },
  {
    &quot;key&quot;: &quot;ctrl+[&quot;,
    &quot;command&quot;: &quot;closeFindWidget&quot;,
    &quot;when&quot;: &quot;editorFocus &amp;#x26;&amp;#x26; findWidgetVisible&quot;
  },
  {
    &quot;key&quot;: &quot;ctrl+[&quot;,
    &quot;command&quot;: &quot;closeMarkersNavigation&quot;,
    &quot;when&quot;: &quot;editorFocus &amp;#x26;&amp;#x26; markersNavigationVisible&quot;
  },
  {
    &quot;key&quot;: &quot;ctrl+[&quot;,
    &quot;command&quot;: &quot;closeParameterHints&quot;,
    &quot;when&quot;: &quot;editorTextFocus &amp;#x26;&amp;#x26; parameterHintsVisible&quot;
  },
  {
    &quot;key&quot;: &quot;ctrl+[&quot;,
    &quot;command&quot;: &quot;closeReferenceSearch&quot;,
    &quot;when&quot;: &quot;referenceSearchVisible &amp;#x26;&amp;#x26; !config.editor.stablePeek&quot;
  },
  {
    &quot;key&quot;: &quot;ctrl+[&quot;,
    &quot;command&quot;: &quot;closeReferenceSearchEditor&quot;,
    &quot;when&quot;: &quot;inReferenceSearchEditor &amp;#x26;&amp;#x26; !config.editor.stablePeek&quot;
  },
  {
    &quot;key&quot;: &quot;ctrl+[&quot;,
    &quot;command&quot;: &quot;editor.action.webvieweditor.hideFind&quot;,
    &quot;when&quot;: &quot;webviewEditorFocus &amp;#x26;&amp;#x26; webviewFindWidgetVisible&quot;
  },
  {
    &quot;key&quot;: &quot;ctrl+[&quot;,
    &quot;command&quot;: &quot;hideSuggestWidget&quot;,
    &quot;when&quot;: &quot;suggestWidgetVisible &amp;#x26;&amp;#x26; textInputFocus&quot;
  },
  {
    &quot;key&quot;: &quot;ctrl+[&quot;,
    &quot;command&quot;: &quot;keybindings.editor.clearSearchResults&quot;,
    &quot;when&quot;: &quot;inKeybindings &amp;#x26;&amp;#x26; inKeybindingsSearch&quot;
  },
  {
    &quot;key&quot;: &quot;ctrl+[&quot;,
    &quot;command&quot;: &quot;leaveEditorMessage&quot;,
    &quot;when&quot;: &quot;messageVisible&quot;
  },
  {
    &quot;key&quot;: &quot;ctrl+[&quot;,
    &quot;command&quot;: &quot;leaveSnippet&quot;,
    &quot;when&quot;: &quot;editorTextFocus &amp;#x26;&amp;#x26; inSnippetMode&quot;
  },
  {
    &quot;key&quot;: &quot;ctrl+[&quot;,
    &quot;command&quot;: &quot;list.clear&quot;,
    &quot;when&quot;: &quot;listFocus &amp;#x26;&amp;#x26; !inputFocus&quot;
  },
  {
    &quot;key&quot;: &quot;ctrl+[&quot;,
    &quot;command&quot;: &quot;notifications.hideList&quot;,
    &quot;when&quot;: &quot;notificationCenterVisible&quot;
  },
  {
    &quot;key&quot;: &quot;ctrl+[&quot;,
    &quot;command&quot;: &quot;notifications.hideToasts&quot;,
    &quot;when&quot;: &quot;notificationToastsVisible&quot;
  },
  {
    &quot;key&quot;: &quot;ctrl+[&quot;,
    &quot;command&quot;: &quot;removeSecondaryCursors&quot;,
    &quot;when&quot;: &quot;editorHasMultipleSelections &amp;#x26;&amp;#x26; textInputFocus&quot;
  },
  {
    &quot;key&quot;: &quot;ctrl+[&quot;,
    &quot;command&quot;: &quot;search.action.cancel&quot;,
    &quot;when&quot;: &quot;listFocus &amp;#x26;&amp;#x26; searchViewletVisible &amp;#x26;&amp;#x26; !inputFocus&quot;
  },
  {
    &quot;key&quot;: &quot;ctrl+[&quot;,
    &quot;command&quot;: &quot;settings.action.clearSearchResults&quot;,
    &quot;when&quot;: &quot;inSettingsSearch&quot;
  },
  {
    &quot;key&quot;: &quot;ctrl+[&quot;,
    &quot;command&quot;: &quot;workbench.action.closeQuickOpen&quot;,
    &quot;when&quot;: &quot;inQuickOpen&quot;
  },
  {
    &quot;key&quot;: &quot;ctrl+[&quot;,
    &quot;command&quot;: &quot;workbench.action.exitZenMode&quot;,
    &quot;when&quot;: &quot;inZenMode&quot;
  }
]
&lt;/code&gt;&lt;/pre&gt;</content:encoded></item><item><title><![CDATA[Redux Starter KitでHooksとReduxを使いこなそう]]></title><description><![CDATA[React-Reduxの公式から「Redux Starter Kit」というものが公開されています。 これがなにかといえば、私の理解するかぎり以下です。 React-Redux…]]></description><link>https://ganevru.github.io/gatsby-starter-blog-grommet/blog/f91d68ea4ef8450fc45c/</link><guid isPermaLink="false">https://ganevru.github.io/gatsby-starter-blog-grommet/blog/f91d68ea4ef8450fc45c/</guid><pubDate>Thu, 20 Feb 2020 15:08:12 GMT</pubDate><content:encoded>&lt;table&gt;
&lt;tr&gt;&lt;td&gt;Redux Sterter KitはRedux-Toolkitに名称変更されてAPIも変更されています。本記事はそのままでは最新版redux-toolkitとして動作しません。
https://github.com/reduxjs/redux-toolkit&lt;/td&gt;&lt;/tr&gt;
&lt;table&gt;
#はじめに
&lt;p&gt;React-Reduxの公式から「&lt;a href=&quot;https://redux-starter-kit.js.org/&quot;&gt;Redux Starter Kit&lt;/a&gt;」というものが公開されています。&lt;/p&gt;
&lt;p&gt;これがなにかといえば、私の理解するかぎり以下です。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;React-Reduxまわりのベストプラクティス、定番拡張、定番併用ライブラリ、定番ミドルウェアを、簡単に組込むための簡単で軽めのライブラリ、メタパッケージ。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;CLIコマンドではなくライブラリです。
これは良いものだと思いましたので全力でお勧めしていきます。&lt;/p&gt;
&lt;h1&gt;特徴&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;TypeScriptフル対応。当然ですね。&lt;/li&gt;
&lt;li&gt;React Redux 7.1対応、つまりHooks対応。これからはHooksで生きていく。Hooksの無い人生は考えられない。&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/immerjs/immer&quot;&gt;Immer&lt;/a&gt;が組込まれることで、&lt;a href=&quot;https://redux-starter-kit.js.org/api/createreducer#direct-state-mutation&quot;&gt;直接state変更&lt;/a&gt;可能になり、reducer記述が簡潔になる。これはイイ! 一番の推しポイントかもしれない。MobXの利点を一部とりこんだと言えるのかも??(追記、後で知ったのですが、MobxとImmerの作者は同じ) Reduxが冗長? 昔の話です。🎉🎉🎉🎉&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Immutable.jsとくらべてImmerのいいところは、Immutable.jsのように記述が特殊にならないことが一つと、他に、同じぐらい重要なのは、他の箇所にImmutable.jsの要求するデータ構造を感染させていかないこと。非侵襲的。重要。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Sliceなるものでモジュール化できる。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Sliceは&lt;a href=&quot;https://redux.js.org/faq/code-structure#what-should-my-file-structure-look-like-how-should-i-group-my-action-creators-and-reducers-in-my-project-where-should-my-selectors-go&quot;&gt;Redux Ducks&lt;/a&gt;が提供するものと&lt;a href=&quot;https://redux-starter-kit.js.org/api/createslice#return-value&quot;&gt;似た&lt;/a&gt;モジュール概念。同じではないらしい。&lt;/li&gt;
&lt;li&gt;Sliceは以下を束ねたもの。&lt;/li&gt;
&lt;li&gt;Redux Stateのトップレベルのslice。ただしこれはオプショナルで、sliceにわけないこともできる。&lt;/li&gt;
&lt;li&gt;それぞれごとの、combineReducerでまとめる元となるそれぞれのReducer群&lt;/li&gt;
&lt;li&gt;sliceごとのState初期値&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Sliceからaction creatorは&lt;strong&gt;&lt;em&gt;型付き&lt;/em&gt;&lt;/strong&gt;で自動生成される🎉🎉🎉🎉&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ACTION定義は完全に消える。action定数も。creatorも。1行も。一行もだ。Reduxが冗長? 昔の話です。🎉🎉🎉🎉&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;これはReact-Reduxの機能の良さからだが、&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;useSelector呼び出すhookをslice Module側で定義すれば、もうほんとにstateとりだしは楽です。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;デフォルトで今は「[immutableStateInvariant, thunk, serializableStateInvariant]の&lt;a href=&quot;https://redux-starter-kit.js.org/api/getdefaultmiddleware#development&quot;&gt;ミドルウェアが設定される&lt;/a&gt;。thunkは議論あるでしょうが、使わないことももちろん可能。&lt;/li&gt;
&lt;li&gt;Redux DevToolsの設定がデフォルトで入っている。&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;上記のようなことのワイアリングが1パッケージでできる。🎉🎉🎉🎉&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://redux-starter-kit.js.org/usage/usage-guide#manual-store-setup&quot;&gt;configureStoreまわりのmiddlewareEnhancerとかapplyMiddlewareとかcomposedEnhancersとかのごちゃごちゃした難しいところ&lt;/a&gt;が&lt;a href=&quot;https://redux-starter-kit.js.org/usage/usage-guide#simplifying-store-setup-with-configurestore&quot;&gt;スッキリ&lt;/a&gt;できる。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;上記はこれだけでも素晴らしいと思うのですが、さらに公式から、というのが安心感があって良いです。この形のReduxがデファクトスタンダードと扱われるようになることを期待します。&lt;/p&gt;
&lt;h1&gt;コード例&lt;/h1&gt;
&lt;p&gt;まずは、TodoMVCみたいなものを作るとします。そのときのタスクリストをredux stateとしてあつかうとします。そのためにTodoをあつかうためのモジュールをこんな風に定義します。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-typescript:todoModule.ts&quot;&gt;import { createSlice } from &quot;redux-starter-kit&quot;;
import { useSelector } from &quot;react-redux&quot;;

export type TodoItem = {
    title: string;
    completed: boolean;
    key: string;
}
// createSlice() で actions と reducers を一気に生成
const todoModule = createSlice({
    // slice: &quot;todo&quot;,
    initialState: [] as TodoItem[],
    reducers: {
        addTodo: (state, action: { payload: TodoItem }) =&gt; {
            state.push(action.payload)
        },
        removeTodo: (state, action: { payload: string }) =&gt; {
            return state.filter((item) =&gt; item.key !== action.payload);
        },
        setCompleted: (state, action: { payload: { completed: boolean, key: string } }) =&gt; {
            state.forEach((item) =&gt; {
                if (item.key === action.payload.key) {
                    item.completed = action.payload.completed;
                }
            });
        },
    }
});

export const useTodoItems = () =&gt; {
    return useSelector((state: ReturnType&amp;#x3C;typeof todoModule.reducer&gt;) =&gt; state);
}
// 他に便利なuseSelect呼び出しや、粒度の細かいaction creatorのexportをここに追加していってもいい。

export default todoModule;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Immerのおかげで、reducerが劇的に簡潔になってます。stateをまるごとおきかえるときはreturnで返します。あとは代入などで副作用バリバリで書いてますがProxy経由なので実際にはStateを変更していません。&lt;/p&gt;
&lt;p&gt;上ではcombineReducerも使わないという前提でsliceプロパティは定義してません。もちろん規模が大きくなれば使ってもかまいません。使ったとしてもsliceの存在は最後のuseTodoItemsで隠蔽できます。
ちなみに、dispatchでまるごと公開するのは楽とはいえ粗い、という人は、&lt;a href=&quot;https://redux-starter-kit.js.org/usage/usage-guide#exporting-and-using-slices&quot;&gt;ちまちまとaction creatorを公開していくこともできます&lt;/a&gt;。お好みで。&lt;/p&gt;
&lt;p&gt;一つだけ、この記事で独自に提案したいこととして、&lt;strong&gt;useSelectorの呼出は、このモジュール側でHooks(ここではuseTodoItems)として定義して、使いやすくしたものをexportする&lt;/strong&gt;ということです。特に、useSelectorの直接呼出は型定義に関して長く煩雑になりがちで、こちらに隠蔽するメリットがあります。&lt;/p&gt;
&lt;p&gt;次に、上に含まれるreducerから以下のようにstoreを構築します。デフォルトのミドルウェアが組み込まれますが、もちろん好きなものを組みこめもします。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-typescript:store.ts&quot;&gt;import { configureStore } from &quot;redux-starter-kit&quot;;
import todoModule from &quot;./modules/todoModule&quot;;

export const setupStore = () =&gt; {
    const store = configureStore({
        reducer: todoModule.reducer
    });
    return store
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;そのstoreから以下のようにProviderコンポーネントでアプリに組み込んで、&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-typescript:App.tsx&quot;&gt;import React from &apos;react&apos;;
import ReactDOM from &apos;react-dom&apos;;
import App from &apos;./App&apos;;
import { Provider } from &quot;react-redux&quot;;
import { setupStore } from &quot;./store&quot;;

const store = setupStore();

ReactDOM.render(
    &amp;#x3C;Provider store={store}&gt;
        &amp;#x3C;App /&gt;
    &amp;#x3C;/Provider&gt;,
    document.getElementById(&apos;root&apos;));
serviceWorker.unregister();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;準備は完了。
あとは、それぞれのコンポーネントからstoreの値をつかいたければ、&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-typescript&quot;&gt;import { useTodoItems } from &quot;./modules/todoModule&quot;;
  :
  const todos = useTodoItems();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;actionをディスパッチしたければ、&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-typescript&quot;&gt;import { useDispatch } from &quot;react-redux&quot;;
import todoModule from &quot;./modules/todoModule&quot;;

  ：
  const dispatch = useDispatch();

  dispatch(todoModule.actions.addTodo({ title: &quot;TITLE&quot;, completed: false, key: &apos;XXX&apos; }))  

  const todos = useTodoItems();
  const todo = todos[key];

  dispatch(todoModule.actions.setCompleted({ key: todo.key, completed: !todo.completed }));
  dispatch(todoModule.actions.removeTodo(todo.key));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;のように、任意のコンポーネントからも自由自在です。connect, mapStateToProps, mapDispatchToPropsよさらば。&lt;/p&gt;
&lt;p&gt;以上です。ザッツオール。ナッシングエルス。驚異的に簡単になったわけです。&lt;/p&gt;
&lt;p&gt;コンポーネント間で状態を共有する場合は、間違いなく&lt;strong&gt;素のuseStateでやるよりも簡単&lt;/strong&gt;になります。あっちはImmer使えないですし&lt;sup id=&quot;fnref-1&quot;&gt;&lt;a href=&quot;#fn-1&quot; class=&quot;footnote-ref&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;、stateのsetterをプロパティで取り回したりイベントハンドラとりまわすのはつらいですからね。&lt;/p&gt;
&lt;h1&gt;参考&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://qiita.com/Ouvill/items/a76e9cbce569d01f2931&quot;&gt;Redux の記述量多すぎなので、 Redux の公式ツールでとことん楽をする ( Redux Starter Kit)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;footnotes&quot;&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id=&quot;fn-1&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://qiita.com/seya/items/f6d311b32cf711a02020&quot;&gt;こちら&lt;/a&gt;にあるような各種Hooks(useArrayとか)を使えば、Immerに匹敵するぐらいには楽かもしれない。&lt;/p&gt;
&lt;a href=&quot;#fnref-1&quot; class=&quot;footnote-backref&quot;&gt;↩&lt;/a&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</content:encoded></item><item><title><![CDATA[Material UIのスタイル指定(JSS)]]></title><description><![CDATA[Material UIでのスタイル指定方法を説明します。Material UIのスタイルシステムの実体はJSSです。themeについては言及しません。もっと基礎的なところだけです。 classNameで即値指定 HTMLで言うclass=の指定。Material UI…]]></description><link>https://ganevru.github.io/gatsby-starter-blog-grommet/blog/969ef20ccef850d2e9b1/</link><guid isPermaLink="false">https://ganevru.github.io/gatsby-starter-blog-grommet/blog/969ef20ccef850d2e9b1/</guid><pubDate>Thu, 20 Feb 2020 15:08:12 GMT</pubDate><content:encoded>&lt;p&gt;Material UIでのスタイル指定方法を説明します。Material UIのスタイルシステムの実体はJSSです。themeについては言及しません。もっと基礎的なところだけです。&lt;/p&gt;
&lt;h1&gt;classNameで即値指定&lt;/h1&gt;
&lt;p&gt;HTMLで言うclass=の指定。Material UI的には何もしない。BEMやscssでもなんでもいいのですが、外部スタイルシートを定義してあてがっていくパターン。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-jsx&quot;&gt;&amp;#x3C;Hoge className=&quot;hoge fuga&quot;/&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt;styleで指定&lt;/h1&gt;
&lt;p&gt;styleプロパティの指定。Material UI的には何もしない。オブジェクトがdomのstyle属性に変換されて付けられる、Reactの仕組み。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-jsx&quot;&gt;&amp;#x3C;Hoge style={{fontSize:1, padding: &apos;1rem&apos;} /&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;DOM上は、要素に直接紐付いたスタイル指定(devtool上、element.styleで表示される)となる。疑似要素は原理的に指定不可。&lt;/p&gt;
&lt;h1&gt;StyledComponent💅で指定。&lt;/h1&gt;
&lt;p&gt;&lt;a href=&quot;https://material-ui.com/styles/api/#styled-component-styles-options-component&quot;&gt;こちら&lt;/a&gt;を参照。本資料では説明を割愛する。&lt;/p&gt;
&lt;h1&gt;JSSのスタイルシートオブジェクトで指定&lt;/h1&gt;
&lt;p&gt;Material UIがかかわるのはここから。JSSは基本的にDOMのインラインスタイル属性ではなく、クラス名による指定の仕組みである。&lt;/p&gt;
&lt;h2&gt;大きな流れ&lt;/h2&gt;
&lt;p&gt;以下のような流れとなる。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;スタイルシートの元になる「元のスタイルシートオブジェクト」をJSで作る&lt;code&gt;const styles = { root: { backgroundColor: &apos;red&apos;, }, };&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;「元のスタイルシートオブジェクト」を元に、Material UIが準備しているHoCやhooksを使って、以下を生成する。&lt;/li&gt;
&lt;li&gt;「元のスタイルシートオブジェクト」のプロパティ名と、コンポーネントローカルにリネームされた実際に生成される「クラス名の対応表」。こんなやつ:
&lt;code&gt;{&quot;tabBar&quot;:&quot;TabBar-tabBar-284&quot;,&quot;selectedTab&quot;:&quot;TabBar-selectedTab-285&quot;}&lt;/code&gt;&lt;br/&gt;この値自体をプログラマが意識することは(デバッグ時を除き)基本的にはない。&lt;/li&gt;
&lt;li&gt;この実クラス名でのスタイル定義が、背後で&amp;#x3C;head&gt;に挿入される(プログラマは意識しないでよい)。&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;「クラス名の対応表」をMaterial UIが提供するReactコンポーネントにおいて以下のいずれかの方法で利用する&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;「クラス名の対応表」から実クラス名を取得して「classNames」propsで指定する。&lt;/li&gt;
&lt;li&gt;「クラス名の対応表」から実クラス名を「classes」propsで指定する。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;「元のスタイルシートオブジェクト」の作りかた&lt;/h2&gt;
&lt;h3&gt;単なるJSオブジェクトとして「スタイルシートオブジェクト」を作る&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&quot;language-jsx&quot;&gt;const styles = {
  root: {
    backgroundColor: &apos;red&apos;,
  },
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;もしくは&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-jsx&quot;&gt;const styles = createStyles({
  root: {
    backgroundColor: &apos;red&apos;,
  },
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;両者の意味は同じである。後者ではTypeScriptの型エラーを黙らすことができる。&lt;/p&gt;
&lt;h2&gt;themeを引数とする関数として「スタイルシートオブジェクト」を作る&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&quot;language-jsx&quot;&gt;const styles = (theme: Theme) =&gt;{
  root: {
    backgroundColor: theme.color.red,
  },
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;もしくは&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-jsx&quot;&gt;const styles = (theme: Theme) =&gt; createStyles({
  root: {
    backgroundColor: theme.color.red,
  },
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;両者の意味は同じである。後者ではTypeScriptの型エラーを黙らすことができる。&lt;/p&gt;
&lt;p&gt;ここでは、Reactのインラインstyle属性のようにJavaScriptオブジェクトを用いるが、rootの階層が入っていることが異なる。この階層の名前は、(実CSSクラス名を隠蔽した)、ローカルなCSSクラス名と思ってよい。&lt;/p&gt;
&lt;p&gt;CSSクラスなので疑似クラスも指定できる。たとえば、以下のように:hover疑似クラスが指定できる。(JSSの機能)&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-jsx&quot;&gt;const styles: any = (theme: Theme): StyleRules =&gt;
  createStyles({
    button: {
      margin: &apos;0.3rem&apos;,
      &apos;&amp;#x26;:hover&apos;: { transform: &apos;scale(1.1)&apos; },
    },
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;「元のスタイルシートオブジェクト」から「クラス名の対応表」を入手する&lt;/h2&gt;
&lt;h3&gt;React Hooks系で&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://material-ui.com/styles/api/#makestyles-styles-options-hook&quot;&gt;こちらから&lt;/a&gt;引用だが、以下のように「makeStyles」の引数に「元のスタイルシートオブジェクト」を渡すと、「クラス名の対応表」を取得できるフック関数を入手することができる。そのフック関数の呼び出し結果をclasses変数に取得している。(createStylesは使用していない。)&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-jsx&quot;&gt;import React from &apos;react&apos;;
import { makeStyles } from &apos;@material-ui/core/styles&apos;;

const useStyles = makeStyles({
  root: {
    backgroundColor: &apos;red&apos;,
    color: props =&gt; props.color,
  },
});

export default function MyComponent(props) {
  const classes = useStyles(props);
  return &amp;#x3C;div className={classes.root} /&gt;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;HoC系で&lt;/h3&gt;
&lt;p&gt;HoCである&lt;a href=&quot;https://material-ui.com/styles/api/#withstyles-styles-options-higher-order-component&quot;&gt;withStyles&lt;/a&gt;を使う。こちらも引用だが以下となる。意味はHooks系と同じだが、「元のスタイルシートオブジェクト」をwithStylesの入力として与え、「クラス名の対応表」がprops.classesに得られるようなコンポーネントを生成している。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-jsx&quot;&gt;import React from &apos;react&apos;;
import { withStyles } from &apos;@material-ui/core/styles&apos;;

const styles = {
  root: {
    backgroundColor: &apos;red&apos;,
  },
};

function MyComponent(props) {
  return &amp;#x3C;div className={props.classes.root} /&gt;;
}

export default withStyles(styles)(MyComponent);
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;取得した「クラス名の対応表」の使いかた&lt;/h2&gt;
&lt;p&gt;「クラス名の対応表」は、入手方法としてHooksでもHoCで得ることができるが、同じものである。上記サンプルでは、入手した「クラス名の対応表」はclassesという名前のprops(props.classes)もしくは変数classesに格納している。&lt;/p&gt;
&lt;p&gt;「クラス名の対応表」には2つの使いかたがある。&lt;/p&gt;
&lt;h2&gt;classNameに与える&lt;/h2&gt;
&lt;p&gt;サンプルにもあるが、&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-jsx&quot;&gt;  return &amp;#x3C;div className={classes.root} /&gt;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;のように指定する。複数あれば&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-jsx&quot;&gt;  return &amp;#x3C;div className={classNames(classes.root,classes.hoge)} /&gt;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;のようにNPMモジュールclassnamesを使うのがよいだろう。classnamesはクラス名を結合させているだけである。(&lt;a href=&quot;https://qiita.com/taqm/items/c38855d8158cdd9d5a3e&quot;&gt;clsx&lt;/a&gt;というのもあり効率がよいらしい)。&lt;/p&gt;
&lt;h2&gt;classesで指定&lt;/h2&gt;
&lt;p&gt;最後になったが、これがJSSの本領である。Material UIのコンポーネントにはCSS APIというものが定義されており、それを使ってカスタマイズすることができる。
たとえば、&lt;a href=&quot;https://material-ui.com/api/tabs/&quot;&gt;Tabsコンポーネントには以下のようにかかれている&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;CSS&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Style sheet name: MuiTab.&lt;/li&gt;
&lt;li&gt;Style sheet details:&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&quot;left&quot;&gt;Rule name&lt;/th&gt;
&lt;th align=&quot;left&quot;&gt;Global class&lt;/th&gt;
&lt;th align=&quot;left&quot;&gt;Description&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;root&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;.MuiTab-root&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;Styles applied to the root element.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;labelIcon&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;.MuiTab-labelIcon&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;Styles applied to the root element if both icon and label are provided.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;textColorInherit&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;.MuiTab-textColorInherit&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;Styles applied to the root element if the parent Tabs has textColor=“inherit”.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;textColorPrimary&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;.MuiTab-textColorPrimary&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;Styles applied to the root element if the parent Tabs has textColor=“primary”.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;textColorSecondary&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;.MuiTab-textColorSecondary&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;Styles applied to the root element if the parent Tabs has textColor=“secondary”.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;&lt;font color=&quot;red&quot;&gt;selected&lt;/font&gt;&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;.Mui-selected&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;Pseudo-class applied to the root element if selected={true} (controlled by the Tabs component).&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;これらを必要に応じてオーバーライド定義することができる。赤字”selected”は後述の説明で例として使用するCSS APIのキー名である。このスタイルをオーバーライドする方法は3つある。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;With a rule name of the classes object prop.(classes propsのルール名)&lt;/li&gt;
&lt;li&gt;With a global class name. (グローバルクラス名)&lt;/li&gt;
&lt;li&gt;With a theme and an overrides property..(テーマと上書きプロパティ)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以降では最初の「 rule name of the classes object prop.」について説明する。
やるべきことは、classes属性に、指定したCSS API名をキー(ここではslected)とし「クラス名の対応表」の実クラス名を指定するのである。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-jsx&quot;&gt;const styles = (theme: any) =&gt;
  createStyles({
    selectedTab: {
      backgroundColor: &apos;#eeeeff&apos;,
      fontWeight: &apos;bold&apos;,
    },
  });
:
          &amp;#x3C;Tabs&gt;
            &amp;#x3C;Tab
              classes={{ selected: classes.selectedTab }} /&gt;
               :
          &amp;#x3C;/Tabs&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;するともともとMUIで定義されていたCSSに上書きされる形でCSSスタイルが定義される。&lt;/p&gt;</content:encoded></item><item><title><![CDATA[JSでデフォルトカリー化]]></title><description><![CDATA[JS(ES2015)でデフォルトカリー化を味わうためには、関数定義は以下のようにするものだ、と自分に言いきかせます。 func = arg1 => arg2 => .. 関数本体 たとえば、以下のように関数を定義して… 呼び出しは以下のようにします。 これでOK…]]></description><link>https://ganevru.github.io/gatsby-starter-blog-grommet/blog/d3dd93bc9266d35bd1c6/</link><guid isPermaLink="false">https://ganevru.github.io/gatsby-starter-blog-grommet/blog/d3dd93bc9266d35bd1c6/</guid><pubDate>Thu, 20 Feb 2020 15:08:12 GMT</pubDate><content:encoded>&lt;p&gt;JS(ES2015)でデフォルトカリー化を味わうためには、関数定義は以下のようにするものだ、と自分に言いきかせます。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;func = arg1 =&gt; arg2 =&gt; .. 関数本体&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;たとえば、以下のように関数を定義して…&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;func = x =&gt; y =&gt; z =&gt; x+y+z;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;呼び出しは以下のようにします。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;console.log(func(3)(4)(5)); // ==&gt; 12
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;これでOK。
え?呼び出しが煩雑だって?
ならば、以下のように$プロパティをFunctionに定義すると…&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;uncurry = (func) =&gt; {
    return new Proxy(func,
                     {
                         apply(target, thisArg, argsList) {
                             return argsList.reduce((last, arg)=&gt;{
                                 return last.call(thisArg, arg);
                             }, target);
                         }
                     }
                    );
};


Object.defineProperty(Function.prototype, &quot;$&quot;, {
    get: function() {return uncurry(this); },
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;こんな風にできます。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;console.log(func.$(3,4,5)); // ==&gt; 12 
console.log(func(3).$(4,5)); // ==&gt; 12 
console.log(func(3)(4).$(5)); // ==&gt; 12 
console.log(func.$(3,4)(5)); // ==&gt; 12
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;$&lt;/code&gt;はhaskellの$のイメージ。&lt;/p&gt;
&lt;h1&gt;追記&lt;/h1&gt;
&lt;p&gt;NPMパッケージ化しました。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.npmjs.com/package/uncurry-apply&quot;&gt;https://www.npmjs.com/package/uncurry-apply&lt;/a&gt;&lt;/p&gt;</content:encoded></item><item><title><![CDATA[関数型プログラミングを業務開発に適用するための架空の社内勉強会資料]]></title><description><![CDATA[関数型プログラミングを業務開発で活用するために HaskellやScala、Erlang/Elixir、Clojure…]]></description><link>https://ganevru.github.io/gatsby-starter-blog-grommet/blog/ff13229413b785cd9cf8/</link><guid isPermaLink="false">https://ganevru.github.io/gatsby-starter-blog-grommet/blog/ff13229413b785cd9cf8/</guid><pubDate>Thu, 20 Feb 2020 15:08:12 GMT</pubDate><content:encoded>&lt;h1&gt;関数型プログラミングを業務開発で活用するために&lt;/h1&gt;
&lt;p&gt;HaskellやScala、Erlang/Elixir、Clojureなどの関数型プログラミング言語に興味がある人は多いと思いますが、自分らが日常行なっている業務での開発では到底それらの関数型言語を採用できないのが現実、という場合があるかもしれません。&lt;/p&gt;
&lt;p&gt;なので、当面はJavaやGroovy、JS,Ruby,Pythonなどの非関数型プログラミング言語の上で関数型プログラミングスタイルや考え方をなるべく使っていくことでFPの考え方や技法に馴染み広めていき、利点を享受しつつ、将来は大手を振って&lt;strike&gt;転職&lt;/strike&gt;業務開発で本格的な関数型言語を使えるようにしていこうというのが現実的な戦略かもしれません。&lt;/p&gt;
&lt;p&gt;以下はそのような目的での&lt;strike&gt;洗脳&lt;/strike&gt;勉強会をやるための架空の資料の目次(案)のようなものです。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;「独自研究」の注意&lt;/p&gt;
&lt;p&gt;「FPとは何か」の定義について、現時点で一般に合意のある明確な唯一のものはないように見えます。しかし、上の目的を達成するためには「関数型プログラミングの本質は、非関数型言語での適用においても同様に有効だ、OOPと併用できる」という結論になる必要があります。また、良くある説明「関数型プログラミングには定義がなく人によってうんたらかんたら」というのも、「わかんねーよ!!おまえら初心者だと思って馬鹿にしてんのか」という印象を持たれる可能性があります。これらの問題を解決するため、本記事では意図的に独断的にFPの本質的定義を提示します。読者の方の認識と一致しない場合、「一つのあり得る説明のしかた」としてでも見ていただけますとありがたいです。コメント歓迎です。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;(追記)
「FPに定義などいらない書けばわかるさ」という意見もあると思いますが、またそれも一面の真理だと思いますが、それだと体験している特性が言語のものなのか、関数型パラダイムのものなのか弁別できません。それでも良いとは思いますが、この記事における独断的定義は、&lt;b&gt;他の言語、特に非関数型プログラミング言語に持ち込んでもなお有効であれば、つまり具体的な関数型言語それぞれの利点を完全に除去しても残っている特性があり利点を発揮し続けるのであれば、それこそが、あるいはそれのみが、個々の言語の利点と言うにはとどまらない関数型プログラミング固有の本質的な有効性と呼ぶに値する&lt;/b&gt;のではないか、という仮説に基づいています。ただ、言語個別のメリットを除去することによって「FPとしては残ってるのはほんのちょっぴり」に感じられたらごめんなさい。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1&gt;関数型プログラミング(FP)とは何か？&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;現象面・表象面では以下のとおり&lt;/li&gt;
&lt;li&gt;(1)再代入をしない&lt;/li&gt;
&lt;li&gt;(2)不変的データを使う(破壊的操作を禁止する)&lt;/li&gt;
&lt;li&gt;(3)値を返さない関数や式・制御構造を使用せず、値や式、返り値を返す関数(メソッド)間の依存関係から構成される式木としてプログラムを記述する&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;以下はFPの必要条件とはしない。つまりFPにおいても許容する。理由は、完全には達成できないし、もしできたとしても入出力をしないプログラムには意味がないため。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;(4)副作用としての入出力禁止。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;「FPの本質」とは&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;プログラムの実行は、引数を入力として結果を得るような計算であるとみなした上で、&lt;br&gt;計算結果を得るために必要な値の間の依存関係を、そのまま平たくプログラムに書き出すこと(cf.&lt;a href=&quot;https://ja.wikipedia.org/wiki/%E9%A0%85%E6%9B%B8%E3%81%8D%E6%8F%9B%E3%81%88&quot;&gt;項書き換え&lt;/a&gt; ※)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;結果を得るための計算が、「変更される状態、すなわちプログラムの実行=計算の進行によって刻々と変わっていく値」には依存しないようにする(メモ:図が必要)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;排除できなければ分離する&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;宣言的とも言う&lt;/li&gt;
&lt;li&gt;←→命令型、手続き型&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;この特性から、上の(1)(2)(3)が結果として導入される。また後述の「FPの効用」が得られる。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;(追記)
※ここで「項書き換え」をFPの本質と言っているわけではなくて、計算の結果の値を得るために必要な値の集合(葉としての引数・定数、中間計算結果としての節)の依存関係を有向グラフとみたときにプログラムないし着目した関数の評価の過程を通じて、&lt;b&gt;そのグラフが静的に定まっている&lt;/b&gt;(ボトムがあるからこの表現が適切かは確信ありませんが)、ということを言っています。項書き換えなりは評価戦略の話であり、結果的には得られる値が同じになるので参考としてリンクを貼りましたが、そこは主眼ではないです。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1&gt;上の説明に「関数」と言う言葉が出てきませんが?&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;それでよい。関数はここでは値の依存グラフを表現するための名前の付いた結節点にすぎない。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;(追記)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;関数の振る舞いの特性に限定した定義にしてしまうと再代入禁止の根拠が薄れる。loopカウンタによる単なるforループの存在や、i=1;i++というコード断片を私はシンプルな統一的根拠によってなるべく否定したい。&lt;/li&gt;
&lt;li&gt;「関数」の意味するものは言語によって異なる。かといって数学的関数で規定したくもない。だって明確化したいプログラムの振る舞いは、それとは実際に異なるものだから。嘘だと思うなら、純粋関数と信じるものを書き下して、呼び出し前の時刻と呼び出し後の時刻を計測してみると良い。「時間が経過した」という副作用を観測する事ができるから（cf.sleep sort）。電力消費量と熱雑音操作して音楽を鳴らすことだってできるらしいし。&lt;/li&gt;
&lt;li&gt;計算に必要な値の依存関係に着目するのは、そのような関数概念や副作用概念の定義の差異やブレが介入できないと言う意味で本質的、少なくとも実用的である。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h1&gt;FPでやりたいこと・やれること&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;上記で「禁止」「排除」されたものは誰かが背負うことになる。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ランタイムがやる←Haskell&lt;/li&gt;
&lt;li&gt;ライブラリがやる←FRP…&lt;/li&gt;
&lt;li&gt;ユーザーコードの中で分離する。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;なので、結局やってることは「副作用の分離と管理」である。
この観点から、前述の&lt;b&gt;「(4)副作用としての入出力」も射程に入る&lt;/b&gt;。
入出力が禁止できなくても、分離もしくは管理できれば良し(HaskellのIOアクションがやっていることの一つ)。&lt;/li&gt;
&lt;li&gt;「FPにおいて(副作用などを)禁止することで得られるものは何か？」
は、問いが間違っていたことになる。
FPは副作用を禁止しない。それを分離・管理する技術である。&lt;/li&gt;
&lt;li&gt;FP以前も副作用、明示的状態管理はなされてきた。FPは、純粋関数、参照透過性という基準を元に明確にコード上に明確に
わかる形で意識してやろうとする、のが違い。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;純粋関数と参照透過性&lt;/h1&gt;
&lt;h2&gt;不純さは伝染する&lt;/h2&gt;
&lt;p&gt;tbd&lt;/p&gt;
&lt;h1&gt;FPではないもの&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;「狭義のFP」は、前述のとおり(異論はあるであろうが、この記事ではそうする)&lt;/li&gt;
&lt;li&gt;「広義のFP」は、高階関数があればFPだというタワゴト含めいろいろあるので、
おいとく。&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;「パターンマッチ、遅延評価、タプル、ADT、静的型付け、高階型に代表される強力な型システム、型クラス、定理証明、カリー化と部分適用、モナド、do記法、内包表記、第一級関数、高階関数」などはFPではない。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ただしいずれもFPの適用を助ける面がある。これらがFPの本質と不可分だ、と言いたくなる気持を持つ人も出てくるだろうし、その気持はわからんでもない。しかし本記事ではそういう主張は趣旨に反するので抑える。&lt;/li&gt;
&lt;li&gt;上記を提供するのがいわゆる「関数型言語」の存在意義であり、実際有用。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;FPの効用&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;品質向上、バグ減少&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;状態更新がないので動作の見通しが立てやすく、コード修正(順序変更、追加、削除)の影響が限定的で安定的。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://developers.srad.jp/story/14/11/08/081210/&quot;&gt;プログラミング言語がソフトウェアの品質に与える影響&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;合成可能性の向上、部品化&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;文脈としての状態に依存しないので異なる場所での利用がしやすい。&lt;/li&gt;
&lt;li&gt;関数合成によるプログラミング(モナド、アロー、コンビネータライブラリ、モナドトランスフォーマー、ミドルウェアパターン、デコレータ関数)★&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;テストしやすさの向上&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;プロパティテスト★&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;状態を切り出すことによって実現が容易になる機能&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;タイムトラベリングデバッグ、…&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;高度な抽象概念をモナド、アロー等で表現・部品化★&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;演習&lt;/h1&gt;
&lt;h2&gt;(1)ループ操作をコレクションを操作する高階関数で表現する&lt;/h2&gt;
&lt;p&gt;リスト(言語によっては配列、シーケンスなどで良い)を逆順にするプログラムを関数型プログラミングスタイルで記述せよ。例として、ループで書かれたプログラム(Groovy)を前述のFPの定義に従って修正する。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Groovy&quot;&gt;List func1(List list) {
    def a = []
    def b = []
    def c = []
    list.reverseEach {
        a.add(it.a)
        b.add(it.b)
        c.add(it.c)
    }
    return [a, b, c]
}
println func1([[a:1, b:2, c:3],[a:11, b:12, c:13],[a:21, b:22, c:23]])
// ==&amp;#x26;gt; [[21, 11, 1], [22, 12, 2], [23, 13, 3]]
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;(2)ループの中断を遅延ストリームで表現し、部品化を高次元で達成する&lt;/h2&gt;
&lt;p&gt;ファイルが複数個(n個)あるとします。それぞれのファイルサイズはわかっています。これらのファイル群のファイルサイズを整数のリスト[s1, s2, s3, … sn]で表現します(sn&gt;=0)。これをlistと呼びます。listの長さはnになります(n&gt;=0)。この「ファイルサイズのリストlist」が表現するファイルをこの順序で、容量limitSizeのフロッピーディスクにコピーする必要があるとします(limitSize&gt;=0)。合計値がlimitSize以下になるように、ファイルを選択してください。具体的には、listの先頭からの部分リストで、その合計値がlimitSize以下であり、長さが最長のものを返す関数を任意の言語で(関数型っぽく)書いてください。listの順序は変更できませんし、listの先頭からスキップすることなく順にコピーする必要があります。Groovyのコード例(関数型っぽくない元の例)は以下のとおり。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Groovy&quot;&gt;List&amp;#x26;lt;Integer&amp;#x26;gt; func0(List&amp;#x26;lt;Integer&amp;#x26;gt; list, int limitSize) {
    int sum = 0
    for (int i=0; i&amp;#x26;lt;list.size(); i++) {
        sum += list[i]
        if (sum&amp;#x26;gt;limitSize) {
            if (i == 0) {
                return []
            }
            else {
                return list[0..i-1]
            }
        }
    }
    return list
}
println func0([15,50,2,20,8,16,7,22], 100) // =&amp;#x26;gt; [15, 50, 2, 20, 8]
println func0([15], 100) // =&amp;#x26;gt; [15]
println func0([15,50,2,20,8,16,7,22], 1000) // =&amp;#x26;gt; [15, 50, 2, 20, 8, 16, 7, 22]
println func0([15,50,2,20,8,16,7,22], 0) // =&amp;#x26;gt; []
println func0([15,50,2,20,8,16,7,22], 95) // =&amp;#x26;gt; [15, 50, 2, 20, 8]
println func0([15,50,2,20,8,16,7,22], 94) // =&amp;#x26;gt; [15, 50, 2, 20]
println func0([], 100) // =&amp;#x26;gt; []
println func0([15,50,2,0,0,0,0,20,0,0,8,16,7,22,0,0], 94) // =&amp;#x26;gt; [15, 50, 2, 0, 0, 0, 0, 20, 0, 0]
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;(3)キューを非破壊的に実装し、状態を切り出す&lt;/h2&gt;
&lt;p&gt;待ち行列をFP、つまり非破壊的操作のみで実装してみましょう。以下はGroovyの例(破壊的操作での例)です。状態を切り出して、とかになるはずです。並列処理は考えないでも良い例外やエラーについても考慮しても良い(Optionとか)&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;class Queue&amp;#x26;lt;E&amp;#x26;gt; {
  ArrayList&amp;#x26;lt;E&amp;#x26;gt; list = []
  void add(E e) {
    list.add(e)
  }
  E remove() {
    if (list.size() &amp;#x26;gt; 0) {
       return list.remove(0)
    }
    else return null
  }
}
q = new Queue&amp;#x26;lt;Integer&amp;#x26;gt;()
q.add(3)
q.add(4)
q.add(5)
assert q.remove() == 3
assert q.remove() == 4
assert q.remove() == 5
assert q.remove() == null
q.add(6)
assert q.remove() == 6
&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt;非関数型言語でのFP適用の勘所&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;「(1)再代入をしない」「(2)破壊的操作をしない」
は高階関数の活用により可能。便利な高階関数ライブラリや非破壊的
データ構造のライブラリがあればなおよい(cf.純粋関数型データ構造)。&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;細かく見ると、(2)は以下にわかれる。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;(2-1)状態の処理を持たない&lt;/li&gt;
&lt;li&gt;(2-2)本質的に状態を必要とする処理&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;(2-1)は慣れれば容易。練習あるのみ。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;map(collect), fold(join),scan(accumulate),zipなどを息を吐くように使えるようになる。&lt;/li&gt;
&lt;li&gt;十分な機能をもった高階関数ライブラリは欲しい(Rx,EclipseCollection,underscore,lodash,ES2015…)。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;(2-2)は原理的には「引数に状態を渡して返り値として新しい状態も返す」関数に書きかえれば良い&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ただし読みにくくなる(連続して操作する場合特に)&lt;/li&gt;
&lt;li&gt;状態書き換え後に、古い状態を使う必要なければむしろ状態をとりちがえるバグの元となる。&lt;/li&gt;
&lt;li&gt;Stateモナド導入できると良いのだが★&lt;/li&gt;
&lt;li&gt;とりあえずの工夫としては「状態の外出しによる純粋操作」と
「状態管理に特化した部分」に分離し、選択的に使用する
(両者の結合はクロージャがあれば簡単)。&lt;/li&gt;
&lt;li&gt;もしくは割りきって、状態書き換えを許容する。(特に大きな問題があるわけではない)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;OOPとの併用のための留意点&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;レシーバ形式のレシーバ(this)をメソッド第一引数として見る&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Java 8のメソッド参照演算子::とGroovyの.&amp;#x26;演算子の差異&lt;/li&gt;
&lt;li&gt;上記のクロージャでの代用&lt;/li&gt;
&lt;li&gt;参考: &lt;a href=&quot;http://d.hatena.ne.jp/lyrical_logical/20111107/1320671610&quot;&gt;open recursion&lt;/a&gt;, &lt;a href=&quot;http://tune.hateblo.jp/entry/2015/03/27/035648&quot;&gt;Haskellオブジェクト指向に触れてみよう〜初級編〜&lt;/a&gt;, Lens&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;クラス定義、継承、仮想関数&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;例外処理との相性&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;型による失敗の表現: Optional(Option,Maybe,Either)&lt;/li&gt;
&lt;li&gt;非同期例外(RuntimeException)は副作用&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;flatMapの真実&lt;/h1&gt;
&lt;p&gt;tbd&lt;/p&gt;
&lt;h1&gt;非関数型言語でのFP適用の限界&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;言語のサポートがないので自力でがんばる&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;FP言語をたとえばScalaやHaskellで学び、その知識を持ち込む&lt;/li&gt;
&lt;li&gt;課題は前提知識のない他の開発者には不自然に感じられるかもしれないこと
(本記事でカバーしたい点でもある)。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;「★」で示したところは、現時点では、非関数型プログラミング言語での開発に無理に
持ち込まない方がよいと思っているところ。&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;FPを活用するライブラリの使用が一番問題がない。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用途にあえば是非トライを&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;FPを活用するライブラリなど&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;FRP, &lt;a href=&quot;http://reactivex.io/&quot;&gt;ReactiveX(Rx)&lt;/a&gt;, &lt;a href=&quot;https://gist.github.com/masakielastic/5897831&quot;&gt;BaconJS&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;React/ &lt;a href=&quot;https://github.com/reactjs/redux&quot;&gt;Redux&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Promise/Future/Observable&lt;/li&gt;
&lt;li&gt;Immutable.JS&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.functionaljava.org/&quot;&gt;FunctionalJava(fj)&lt;/a&gt;, &lt;a href=&quot;https://github.com/mperry/functionalgroovy&quot;&gt;Functional Groovy&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.eclipse.org/collections/&quot;&gt;Eclipse Collection&lt;/a&gt;(旧GS Collection)&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;関連トピックス紹介&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;CQRS&lt;/li&gt;
&lt;li&gt;RESTfulアーキテクチャ&lt;/li&gt;
&lt;li&gt;べき等性&lt;/li&gt;
&lt;li&gt;STM&lt;/li&gt;
&lt;li&gt;Datomic&lt;/li&gt;
&lt;li&gt;イミュータブルデータモデル&lt;/li&gt;
&lt;li&gt;Elm, Frege&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;さあみなさんも関数型ライフを!&lt;/p&gt;</content:encoded></item><item><title><![CDATA[DockerfileのCMDとENTRYPOINTを改めて解説する]]></title><description><![CDATA[TL;DR dockerで、コンテナ内で実行するプロセスを指定してのコンテナ起動方法は以下のとおり。 docker run <コンテナ指定> <プロセス指定> [ <プロセスに与える引数指定> ] docker run…]]></description><link>https://ganevru.github.io/gatsby-starter-blog-grommet/blog/e6dd013e28593c26372d/</link><guid isPermaLink="false">https://ganevru.github.io/gatsby-starter-blog-grommet/blog/e6dd013e28593c26372d/</guid><pubDate>Thu, 20 Feb 2020 15:08:12 GMT</pubDate><content:encoded>&lt;h1&gt;TL;DR&lt;/h1&gt;
&lt;p&gt;dockerで、コンテナ内で実行するプロセスを指定してのコンテナ起動方法は以下のとおり。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;docker run &amp;#x3C;コンテナ指定&gt; &amp;#x3C;プロセス指定&gt; [ &amp;#x3C;プロセスに与える引数指定&gt; ]&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;docker runで、起動するプロセスを毎回指定するのが面倒で、決まった特定のプロセスを指定したいなら、以下のどれかを選択する。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;(ENTRYPOINTを指定しない場合)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;DockerfileのCMD項目でプロセスおよびそれへの引数を指定する。この場合、&lt;code&gt;docker run &amp;#x3C;コンテナ指定&gt; [RET]&lt;/code&gt; のようにプロセス指定を省略して起動したときに、CMD項目で指定した内容が起動するプロセスのおよびそれへの引数の指定となる。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;   docker run &amp;#x3C;コンテナ指定&gt; &amp;#x3C;プロセス指定&gt; [ &amp;#x3C;プロセスに与える引数指定&gt; ]
                            &amp;#x3C;----------CMDで省略値を与えられる---------&gt; 
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;(ENTRYPOINTを指定する場合)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;DockerfileのENTRYPOINT項目で決まった特定のプロセスを指定する。この場合、それ以外のプロセスは起動できなくなる。(もっとも/bin/shなどがENTRYPOINTで指定されているなら、/bin/shは任意のプロセスを起動する機能があるので、引数の与え型によっては任意のプロセスを起動できる。また、—entrypoint=引数で上書き指定ができる)。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ENTRYPOINTで指定したプロセスには次のように追加引数をあたえて起動することができる。&lt;code&gt;docker run &amp;#x3C;コンテナ指定&gt; &amp;#x3C;追加引数指定&gt; RET&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;docker run &amp;#x3C;コンテナ指定&gt; RET&lt;/code&gt;のように追加引数を指定しなかったときのデフォルトの追加引数をCMD項目から与えることができる。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;   docker run &amp;#x3C;コンテナ指定&gt; [ &amp;#x3C;プロセスに与える追加引数指定&gt; ]
                            &amp;#x3C;--CMDで省略値を与えられる------&gt; 
   #プロセス指定はENTRYPOINTで別途与えられている。
&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt;なぜこの文章を書いたか&lt;/h1&gt;
&lt;p&gt;Dockerfileの設定項目にはENTRYPOINTとCMDという項目があるが、これらが対になる意味をもつかのような説明や、「CMD とENTRYPOINT」のように、同列で比較対照する記事を良く見る。&lt;/p&gt;
&lt;p&gt;しかし両者は意味レベルが異なる存在であり、そのことを理解しないと良くわからないことになる(自分はなった)。また、CMDについてはもともとのDocker仕様としても、歴史的経緯っぽくてすっきりしないところがある。なので、整理してみた。&lt;/p&gt;
&lt;p&gt;結論だけ書いておくと、「ENTRYPOINTの指定」に対になるのは、「runコマンドで実行プロセスを指定する」方法であり、CMDの指定ではない。CMDは両者に対して適用可能であり、それぞれ別の意味がある。詳しくは本文参照のこと。&lt;/p&gt;
&lt;h1&gt;はじめに&lt;/h1&gt;
&lt;p&gt;CMDとENTRYPOINTは、いずれもDockerfileの設定項目であり、コンテナを「実行可能コンテナ」として使用する場合の設定。
「実行可能コンテナ」とは、他のコンテナのベースイメージとして利用するのではなく、&lt;code&gt;docker run&lt;/code&gt;で直接実行することを目的としたコンテナイメージのこと。(もっとも、コンテナは実行可能かつベースイメージとなることもできるので、この2つの種別は排他的ではない。CMDとENTRYPOINTを持つイメージを元にしてビルドした場合の動作については、別途試す)。&lt;/p&gt;
&lt;h1&gt;コンテナの実行と、起動プロセスの指定&lt;/h1&gt;
&lt;p&gt;構築されたDockerイメージに対して、コンテナを生成し、その中で &lt;strong&gt;何か1つのプロセスを起動・実行&lt;/strong&gt; することで、意味のある動作をさせることができる(サーバとして継続的に実行したり、コマンドラインから1ショットで処理をするなど)。&lt;/p&gt;
&lt;p&gt;コンテナ内で起動する(唯一の)プロセスの指定方法には以下の2つがある。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;docker run の後にコマンドを記述&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;run時にイメージ内の任意のコマンドからプロセスを実行できる、自由度が高いコンテナ&lt;/li&gt;
&lt;li&gt;「docker run コマンド指定(+引数)」でプロセスを起動する&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Dockerfile内のENTRYPOINT項目で指定&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;あらかじめビルド時に起動するプロセスが特定され、run時にはそのプロセスに対する引数だけが指定できる自由度の低いコンテナ&lt;/li&gt;
&lt;li&gt;この場合でも実行するにはdocker runでイメージを起動する&lt;/li&gt;
&lt;li&gt;この場合にdocker runの後に指定するのはプロセス指定ではなく、ENTRYPOINTで指定されるプロセスに与える引数&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;これら2つの指定方法は基本的に排他&lt;sup id=&quot;fnref-1&quot;&gt;&lt;a href=&quot;#fn-1&quot; class=&quot;footnote-ref&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;である。つまり、ENTRYPOINTを指定したときは、runの後の記述は起動するプロセスを特定する指示としては機能しないし、&lt;code&gt;docker run&lt;/code&gt;で起動するプロセスを指定できるのは、DockerfileでENDTRYPOINTを指定せずに構築されたコンテナに対してのみである。&lt;/p&gt;
&lt;p&gt;ENTRYPOINTでの指定は、ビルド時に確定してイメージに封入されてしまうことも留意。(必要ならrun —entrypoint=&quot;&quot;で上書きすることもできるとのこと)&lt;/p&gt;
&lt;h2&gt;ENTRYPOINTの意味&lt;/h2&gt;
&lt;p&gt;ENTRYPOINTは、前項「2.」の方法において、実行可能コンテナを利用する際の特定の「主たるプロセス」を起動するコマンドの指定である。「任意のコマンド」でコンテナの内容物を利用できるようにしたい場合、ENTRYPOINTを指定する必要はないし、指定すると任意のコマンドは実行できなくなる(run —entrypoint=&quot;&quot;で上書すればできるが)。&lt;/p&gt;
&lt;p&gt;ENTRYPOINTの良くある用例として、シェル(例えば&lt;code&gt;/bin/bash -c&lt;/code&gt;など)を指定することもできる。この場合、「インタラクティブシェルから様々な操作をしたり-cオプションで任意のコマンドを実行を指定して起動プロセスとして実行できる、任意のコマンドを実行できるコンテナ」になる。たとえば、&lt;code&gt;docker run &amp;#x3C;コンテナ指定&gt; --rm -it &apos;(cd /app; ls -la)&apos;&lt;/code&gt;など。&lt;/p&gt;
&lt;p&gt;シェル以外の「主たるプロセス」の起動を指定する用例としては、例えば、「gitのコンテナ」を作る場合には、&lt;code&gt;/usr/bin/git&lt;/code&gt;をENTRYPOINTに固定登録する、などである。その際には、&lt;code&gt;docker run&lt;/code&gt;コマンド実行時の引数もしくはCMD指定によって、ENTRYPOINTで指定したプログラムに引数を追加して起動することができる。たとえば、&lt;code&gt;docker run &amp;#x3C;コンテナ指定&gt; log&lt;/code&gt;で&lt;code&gt;/usr/bin/git log&lt;/code&gt;を実行するなどである。このようにENTRYPOINTで指定したプログラムにrun時に追加する引数を、本文書では「追加引数」と呼ぶ(一般的ではない)。&lt;/p&gt;
&lt;h1&gt;CMD指定の2つの意味&lt;/h1&gt;
&lt;p&gt;結局のところ、CMD指定は全く異なる2つの異なる意味をもつ。&lt;/p&gt;
&lt;p&gt;1つ目の意味は、前項「1.」の方法(docker runでコマンドを指定する)において、「docker run」で実際のコマンドを何も指定しなかったとき &lt;strong&gt;実行するコマンド(と引数)のデフォルト値&lt;/strong&gt;である。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-sh&quot;&gt;# ENTRYPOINT項目が指定されていないとして
  docker run &amp;#x3C;コンテナ指定&gt; ls -la [enter] # 「ls -la」がコンテナ内で実行される
  docker run &amp;#x3C;コンテナ指定&gt; [enter]  # &amp;#x3C;この場合に実行される「コマンドと引数」をCMD項目に設定する&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2つ目の意味は、前項「2.」の方法(DockerfileのENTRYPOINT項目でコマンドを指定する)において、ENTRYPOINTに指定したコマンドの&lt;strong&gt;追加引数&lt;/strong&gt;の、コマンドラインから指定しなかった場合の&lt;strong&gt;デフォルト値&lt;/strong&gt;である。(「CMD」だからコマンドかと思うが、この場合はそうではない。引数なのである。ここがわかりにくい!)&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-sh&quot;&gt;# ENTRYPOINT項目に[&quot;/usr/bin/git&quot;]が指定されているとして
  docker run &amp;#x3C;コンテナ指定&gt; status[enter]  # 「/bin/git status」がコンテナ内で実行される
  docker run &amp;#x3C;コンテナ指定&gt; [enter]  # &amp;#x3C;この場合に実行される/bin/gitへの「引数」をCMD項目に設定する&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;いずれの場合でも、CMDはrunの後に続ける引数のデフォルト値指定であると言える。&lt;/p&gt;
&lt;h2&gt;ENTRYPOINTと追加引数&lt;/h2&gt;
&lt;p&gt;以上について、いくつかの例を通じて見ていく。&lt;/p&gt;
&lt;h3&gt;追加引数をdocker runコマンドの引数から与える&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;ENTRYPOINT: /usr/bin/git
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;して&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker run &amp;#x3C;コンテナ指定&gt; checkout
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;とすれば、ENTRYPOINT指定に追加引数として「checkout」が追加されて、run時のコンテナ内でのプロセス起動のためのコマンドラインとしては「&lt;code&gt;/usr/bin/git checkout&lt;/code&gt;」が実行される。&lt;/p&gt;
&lt;h3&gt;追加引数のデフォルト値をCMDで与える&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;ENTRYPOINT: /usr/bin/git
CMD: [&quot;status&quot;]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;して&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker run &amp;#x3C;コンテナ指定&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;とすれば、コンテナ内でのプロセス起動のためのコマンドラインとしては、追加引数のデフォルト値として&lt;code&gt;CMD: [&quot;status&quot;]&lt;/code&gt;が使用されて、「&lt;code&gt;git status&lt;/code&gt;」が実行される。
CMDはあくまで「&lt;code&gt;docker run&lt;/code&gt;↵」で追加引数が省略されたときのデフォルト値の指定なので、&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker run &amp;#x3C;コンテナ指定&gt; checkout
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;のように、明示的にrunコマンドで追加引数を与えた時には(&lt;code&gt;CMD: [&quot;status&quot;]&lt;/code&gt;の指定は無視されて)、run時のコンテナ内でのプロセス起動のためのコマンドラインとしては「&lt;code&gt;/usr/bin/git checkout&lt;/code&gt;」が実行される。&lt;/p&gt;
&lt;h1&gt;文字列指定と配列指定&lt;/h1&gt;
&lt;p&gt;前項では、CMD項目は、&lt;code&gt;CMD: &quot;status&quot;&lt;/code&gt;のような&lt;strong&gt;空白区切り文字列形式&lt;/strong&gt;ではなく、&lt;code&gt;CMD: [&quot;status&quot;]&lt;/code&gt;のような&lt;strong&gt;配列形式&lt;/strong&gt;で設定していた。この理由を説明する。&lt;/p&gt;
&lt;p&gt;ENTRYPOINT、CMDともに、「空白区切りの文字列」で指定すると「&lt;code&gt;/bin/sh -c&lt;/code&gt;」が付与されてシェル経由、「文字列の配列」で指定するとexecシステムコールがプロセスの起動に使用される。
CMDに関して、「&lt;code&gt;/bin/sh -c&lt;/code&gt;」の付与は、ENTRYPOINTの「追加引数」として使用される場合も区別されずに適用され、「[“/bin/sh”,“-c”]」が引数に含まれるようになる。この動作は意図しないものである可能性が高いので、一般には、ENTRYPOINTに対するCMDは文字列の配列形式で指定することが多いだろう。(このへんでも、CMDの仕様は、つきつめて考え抜かれている、というより、機能拡張の歴史的経緯に引きずられてるっぽい感じがするぜぇー)&lt;/p&gt;
&lt;h1&gt;まとめ&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;実行可能コンテナ内で起動するプロセスを指定する方法は以下の1,2のいずれか&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;docker runコマンドの一部で指定&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;docker run &amp;#x3C;コンテナ指定&gt; XXX YYY...&lt;/code&gt;↵の形式&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;例: &lt;code&gt;docker run &amp;#x3C;コンテナ指定&gt; /bin/sh -c echo hoge&lt;/code&gt;↵&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;XXXは任意のプロセスを起動するコマンド&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;YYY…はそのコマンドラインに与える引数&lt;/li&gt;
&lt;li&gt;「&lt;code&gt;docker run &amp;#x3C;コンテナ指定&gt;&lt;/code&gt;↵」のみで「XXX YYY…」を省略した場合の「XXX YYY…」部分のデフォルト値をDockerfileのCMD項目で与えることができる&lt;/li&gt;
&lt;li&gt;例：
&lt;code&gt;CMD: /bin/sh -c echo hoge&lt;/code&gt; &lt;br /&gt; のとき、「&lt;code&gt;docker run &amp;#x3C;コンテナ指定&gt;&lt;/code&gt;↵」の実行は先述の&lt;br/&gt;&lt;code&gt;docker run &amp;#x3C;コンテナ指定&gt; /bin/sh echo hoge&lt;/code&gt;↵&lt;br/&gt;と同じ。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;ENTRYPOINTで指定&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ENTRYPOINT: XXX YYY…の形式&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;例: &lt;code&gt;ENTRYPOINT: /usr/bin/git&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;XXXは固定の主たるプロセスを起動するコマンド(/usr/bin/git)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;YYY…はそのコマンドに与える引数(もしあれば)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;docker run ZZZで、追加引数を与えることができる&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;例: &lt;code&gt;docker run &amp;#x3C;コンテナ指定&gt; --version&lt;/code&gt;↵&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;つまり「XXX YYY… ZZZ」というコマンドラインで起動できる&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;上の例の場合： &lt;code&gt;/usr/bin/git --version&lt;/code&gt;の「—version」が追加引数ZZZ&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;「&lt;code&gt;docker run &amp;#x3C;コンテナ指定&gt;&lt;/code&gt;↵」のみで「ZZZ」を省略してrunした場合の、追加的引数ZZZのデフォルト値をCMDで与えることができる&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;例: &lt;code&gt;CMD: status&lt;/code&gt;&lt;br/&gt; のとき、「&lt;code&gt;docker run &amp;#x3C;コンテナ指定&gt;&lt;/code&gt;↵」で&lt;code&gt;/usr/bin/git status&lt;/code&gt;が実行される。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;docker-composeについて(追記)&lt;/h1&gt;
&lt;p&gt;Docker Composeのdocker-compose.ymlファイルでは、entrypointはentrypointのまま、CMDはcommand項目に対応する。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://docs.docker.jp/compose/compose-file.html#entrypoint&quot;&gt;http://docs.docker.jp/compose/compose-file.html#entrypoint&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://docs.docker.jp/compose/compose-file.html#command&quot;&gt;http://docs.docker.jp/compose/compose-file.html#command&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;footnotes&quot;&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id=&quot;fn-1&quot;&gt;
&lt;p&gt;よく考えると、実はENTRYPOINT項目を設定しなかった場合のデフォルト値が/bin/sh -cだと言う話で両者を説明しつくせる気がしてきた。&lt;/p&gt;
&lt;a href=&quot;#fnref-1&quot; class=&quot;footnote-backref&quot;&gt;↩&lt;/a&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</content:encoded></item><item><title><![CDATA[As You]]></title><description><![CDATA[This is my first post on my new fake blog! How exciting! I’m sure I’ll write a lot more interesting things in the future. Oh, and here’s a…]]></description><link>https://ganevru.github.io/gatsby-starter-blog-grommet/blog/as-you/</link><guid isPermaLink="false">https://ganevru.github.io/gatsby-starter-blog-grommet/blog/as-you/</guid><pubDate>Sat, 01 Sep 2018 22:12:03 GMT</pubDate><content:encoded>&lt;p&gt;This is my first post on my new fake blog! How exciting!&lt;/p&gt;
&lt;p&gt;I’m sure I’ll write a lot more interesting things in the future.&lt;/p&gt;
&lt;p&gt;Oh, and here’s a great quote from this Wikipedia on
&lt;a href=&quot;http://en.wikipedia.org/wiki/Salted_duck_egg&quot;&gt;salted duck eggs&lt;/a&gt;.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A salted duck egg is a Chinese preserved food product made by soaking duck
eggs in brine, or packing each egg in damp, salted charcoal. In Asian
supermarkets, these eggs are sometimes sold covered in a thick layer of salted
charcoal paste. The eggs may also be sold with the salted paste removed,
wrapped in plastic, and vacuum packed. From the salt curing process, the
salted duck eggs have a briny aroma, a gelatin-like egg white and a
firm-textured, round yolk that is bright orange-red in color.&lt;/p&gt;
&lt;/blockquote&gt;</content:encoded></item><item><title><![CDATA[Some Else]]></title><description><![CDATA[This is my first post on my new fake blog! How exciting! I’m sure I’ll write a lot more interesting things in the future. Oh, and here’s a…]]></description><link>https://ganevru.github.io/gatsby-starter-blog-grommet/blog/some-else/</link><guid isPermaLink="false">https://ganevru.github.io/gatsby-starter-blog-grommet/blog/some-else/</guid><pubDate>Tue, 01 May 2018 22:12:03 GMT</pubDate><content:encoded>&lt;p&gt;This is my first post on my new fake blog! How exciting!&lt;/p&gt;
&lt;p&gt;I’m sure I’ll write a lot more interesting things in the future.&lt;/p&gt;
&lt;p&gt;Oh, and here’s a great quote from this Wikipedia on
&lt;a href=&quot;http://en.wikipedia.org/wiki/Salted_duck_egg&quot;&gt;salted duck eggs&lt;/a&gt;.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A salted duck egg is a Chinese preserved food product made by soaking duck
eggs in brine, or packing each egg in damp, salted charcoal. In Asian
supermarkets, these eggs are sometimes sold covered in a thick layer of salted
charcoal paste. The eggs may also be sold with the salted paste removed,
wrapped in plastic, and vacuum packed. From the salt curing process, the
salted duck eggs have a briny aroma, a gelatin-like egg white and a
firm-textured, round yolk that is bright orange-red in color.&lt;/p&gt;
&lt;/blockquote&gt;</content:encoded></item><item><title><![CDATA[New And]]></title><description><![CDATA[This is my first post on my new fake blog! How exciting! I’m sure I’ll write a lot more interesting things in the future. Oh, and here’s a…]]></description><link>https://ganevru.github.io/gatsby-starter-blog-grommet/blog/new-and/</link><guid isPermaLink="false">https://ganevru.github.io/gatsby-starter-blog-grommet/blog/new-and/</guid><pubDate>Mon, 01 May 2017 22:12:03 GMT</pubDate><content:encoded>&lt;p&gt;This is my first post on my new fake blog! How exciting!&lt;/p&gt;
&lt;p&gt;I’m sure I’ll write a lot more interesting things in the future.&lt;/p&gt;
&lt;p&gt;Oh, and here’s a great quote from this Wikipedia on
&lt;a href=&quot;http://en.wikipedia.org/wiki/Salted_duck_egg&quot;&gt;salted duck eggs&lt;/a&gt;.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A salted duck egg is a Chinese preserved food product made by soaking duck
eggs in brine, or packing each egg in damp, salted charcoal. In Asian
supermarkets, these eggs are sometimes sold covered in a thick layer of salted
charcoal paste. The eggs may also be sold with the salted paste removed,
wrapped in plastic, and vacuum packed. From the salt curing process, the
salted duck eggs have a briny aroma, a gelatin-like egg white and a
firm-textured, round yolk that is bright orange-red in color.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;./building.jpg&quot; alt=&quot;Chinese Salty Egg&quot;&gt;&lt;/p&gt;</content:encoded></item><item><title><![CDATA[New Beginnings - no image post]]></title><description><![CDATA[Far far away, behind the word mountains, far from the countries Vokalia and
Consonantia, there live the blind texts. Separated they live in…]]></description><link>https://ganevru.github.io/gatsby-starter-blog-grommet/blog/hi-folks/</link><guid isPermaLink="false">https://ganevru.github.io/gatsby-starter-blog-grommet/blog/hi-folks/</guid><pubDate>Thu, 28 May 2015 22:40:32 GMT</pubDate><content:encoded>&lt;p&gt;Far far away, behind the word mountains, far from the countries Vokalia and
Consonantia, there live the blind texts. Separated they live in Bookmarksgrove
right at the coast of the Semantics, a large language ocean. A small river named
Duden flows by their place and supplies it with the necessary regelialia.&lt;/p&gt;
&lt;h2&gt;On deer horse aboard tritely yikes and much&lt;/h2&gt;
&lt;p&gt;The Big Oxmox advised her not to do so, because there were thousands of bad
Commas, wild Question Marks and devious Semikoli, but the Little Blind Text
didn’t listen. She packed her seven versalia, put her initial into the belt and
made herself on the way.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;This however showed weasel&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Well uncritical so misled&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;this is very interesting&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Goodness much until that fluid owl&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;When she reached the first hills of the &lt;strong&gt;Italic Mountains&lt;/strong&gt;, she had a last
view back on the skyline of her hometown &lt;em&gt;Bookmarksgrove&lt;/em&gt;, the headline of
&lt;a href=&quot;http://google.com&quot;&gt;Alphabet Village&lt;/a&gt; and the subline of her own road, the Line
Lane. Pityful a rethoric question ran over her cheek, then she continued her
way. On her way she met a copy.&lt;/p&gt;
&lt;h3&gt;Overlaid the jeepers uselessly much excluding&lt;/h3&gt;
&lt;p&gt;But nothing the copy said could convince her and so it didn’t take long until a
few insidious Copy Writers ambushed her, made her drunk with
&lt;a href=&quot;http://google.com&quot;&gt;Longe and Parole&lt;/a&gt; and dragged her into their agency, where
they abused her for their projects again and again. And if she hasn’t been
rewritten, then they are still using her.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Far far away, behind the word mountains, far from the countries Vokalia and
Consonantia, there live the blind texts. Separated they live in Bookmarksgrove
right at the coast of the Semantics, a large language ocean.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;It is a paradisematic country, in which roasted parts of sentences fly into your
mouth. Even the all-powerful Pointing has no control about the blind texts it is
an almost unorthographic life One day however a small line of blind text by the
name of Lorem Ipsum decided to leave for the far World of Grammar.&lt;/p&gt;
&lt;h3&gt;According a funnily until pre-set or arrogant well cheerful&lt;/h3&gt;
&lt;p&gt;The Big Oxmox advised her not to do so, because there were thousands of bad
Commas, wild Question Marks and devious Semikoli, but the Little Blind Text
didn’t listen. She packed her seven versalia, put her initial into the belt and
made herself on the way.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;So baboon this&lt;/li&gt;
&lt;li&gt;Mounted militant weasel gregariously admonishingly straightly hey&lt;/li&gt;
&lt;li&gt;Dear foresaw hungry and much some overhung&lt;/li&gt;
&lt;li&gt;Rash opossum less because less some amid besides yikes jeepers frenetic
impassive fruitlessly shut&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;When she reached the first hills of the Italic Mountains, she had a last view
back on the skyline of her hometown Bookmarksgrove, the headline of Alphabet
Village and the subline of her own road, the Line Lane. Pityful a rethoric
question ran over her cheek, then she continued her way. On her way she met a
copy.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The copy warned the Little Blind Text, that where it came from it would have
been rewritten a thousand times and everything that was left from its origin
would be the word “and” and the Little Blind Text should turn around and
return to its own, safe country.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;But nothing the copy said could convince her and so it didn’t take long until a
few insidious Copy Writers ambushed her, made her drunk with Longe and Parole
and dragged her into their agency, where they abused her for their projects
again and again. And if she hasn’t been rewritten, then they are still using
her. Far far away, behind the word mountains, far from the countries Vokalia and
Consonantia, there live the blind texts.&lt;/p&gt;
&lt;h4&gt;Silent delightfully including because before one up barring chameleon&lt;/h4&gt;
&lt;p&gt;Separated they live in Bookmarksgrove right at the coast of the Semantics, a
large language ocean. A small river named Duden flows by their place and
supplies it with the necessary regelialia. It is a paradisematic country, in
which roasted parts of sentences fly into your mouth.&lt;/p&gt;
&lt;p&gt;Even the all-powerful Pointing has no control about the blind texts it is an
almost unorthographic life One day however a small line of blind text by the
name of Lorem Ipsum decided to leave for the far World of Grammar. The Big Oxmox
advised her not to do so, because there were thousands of bad Commas, wild
Question Marks and devious Semikoli, but the Little Blind Text didn’t listen.&lt;/p&gt;
&lt;h5&gt;Wherever far wow thus a squirrel raccoon jeez jaguar this from along&lt;/h5&gt;
&lt;p&gt;She packed her seven versalia, put her initial into the belt and made herself on
the way. When she reached the first hills of the Italic Mountains, she had a
last view back on the skyline of her hometown Bookmarksgrove, the headline of
Alphabet Village and the subline of her own road, the Line Lane. Pityful a
rethoric question ran over her cheek, then she continued her way. On her way she
met a copy.&lt;/p&gt;
&lt;h6&gt;Slapped cozy a that lightheartedly and far&lt;/h6&gt;
&lt;p&gt;The copy warned the Little Blind Text, that where it came from it would have
been rewritten a thousand times and everything that was left from its origin
would be the word “and” and the Little Blind Text should turn around and return
to its own, safe country. But nothing the copy said could convince her and so it
didn’t take long until a few insidious Copy Writers ambushed her, made her drunk
with Longe and Parole and dragged her into their agency, where they abused her
for their projects again and again.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[My Second Post!]]></title><description><![CDATA[Wow! I love blogging so much already. Did you know that “despite its name, salted duck eggs can also be made from
chicken eggs, though the…]]></description><link>https://ganevru.github.io/gatsby-starter-blog-grommet/blog/my-second-post/</link><guid isPermaLink="false">https://ganevru.github.io/gatsby-starter-blog-grommet/blog/my-second-post/</guid><pubDate>Wed, 06 May 2015 23:46:37 GMT</pubDate><content:encoded>&lt;p&gt;Wow! I love blogging so much already.&lt;/p&gt;
&lt;p&gt;Did you know that “despite its name, salted duck eggs can also be made from
chicken eggs, though the taste and texture will be somewhat different, and the
egg yolk will be less rich.”?
(&lt;a href=&quot;http://en.wikipedia.org/wiki/Salted_duck_egg&quot;&gt;Wikipedia Link&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;Yeah, I didn’t either.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[Hello World]]></title><description><![CDATA[This is my first post on my new fake blog! How exciting! I’m sure I’ll write a lot more interesting things in the future. Oh, and here’s a…]]></description><link>https://ganevru.github.io/gatsby-starter-blog-grommet/blog/hello-world/</link><guid isPermaLink="false">https://ganevru.github.io/gatsby-starter-blog-grommet/blog/hello-world/</guid><pubDate>Fri, 01 May 2015 22:12:03 GMT</pubDate><content:encoded>&lt;p&gt;This is my first post on my new fake blog! How exciting!&lt;/p&gt;
&lt;p&gt;I’m sure I’ll write a lot more interesting things in the future.&lt;/p&gt;
&lt;p&gt;Oh, and here’s a great quote from this Wikipedia on
&lt;a href=&quot;http://en.wikipedia.org/wiki/Salted_duck_egg&quot;&gt;salted duck eggs&lt;/a&gt;.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A salted duck egg is a Chinese preserved food product made by soaking duck
eggs in brine, or packing each egg in damp, salted charcoal. In Asian
supermarkets, these eggs are sometimes sold covered in a thick layer of salted
charcoal paste. The eggs may also be sold with the salted paste removed,
wrapped in plastic, and vacuum packed. From the salt curing process, the
salted duck eggs have a briny aroma, a gelatin-like egg white and a
firm-textured, round yolk that is bright orange-red in color.&lt;/p&gt;
&lt;/blockquote&gt;</content:encoded></item></channel></rss>